'<PCODE "STRGEN">

<GDECL (PATTRNS) <UVECTOR [REST <LIST [REST <OR ATOM LIST>]>]> (RESTERS NTHERS 
PUTTERS) VECTOR (STYPES) <UVECTOR [REST ATOM]>> 

<SETG PREG?  %<RSUBR!- '[ %<PCODE!- "STRGEN" 0> PREG? #DECL ("VALUE" ANY ANY ANY
) GOODACS FUNCTION:VALUE REGSTO ADD:STACK STACK:ARGUMENT GETUVT TYPESAME GETBSYZ
 OFFPTR D:B:TAG TOACT SPEC-GEN TYPE-MERGE PREFER-DATUM GET-ELE-TYPE DEFERN 
DELAY-KILL MESSAGE MINL GET-RANGE UPDATE-WHERE ISTYPE-GOOD? ADDR:TYPE ADDR:VALUE
 GET:TEMPLATE:LENGTH SGETREG STRUCTYP MOVE:ARG REFERENCE RET-TMP-AC BRANCH:TAG 
MUNG-AC FREE-ACS LABEL:TAG EMIT VAR-STORE FLIP DATTYP-FLUSH TOACV GEN MAKE:TAG 
DATUM GETREG ANY2ACS ISTYPE? TUPLE ![STRING BYTES FRAME TUPLE LOCD!] %<TYPE-C 
DATUM LIST> %<TYPE-C AC VECTOR> T ANY-AC %<TYPE-W DATUM LIST> %<TYPE-W AC VECTOR
> FLUSHED %<TYPE-W NODE VECTOR> DONT-CARE ![==? G? G=? 1? 0?!] ![G? G=?!] ![L? 
L=?!] L=? G? %<TYPE-W OPCODE!-OP WORD> %<TYPE-W TRANS VECTOR> TRANSFORM %<TYPE-C
NODE VECTOR> VECTOR FIX LIST <`MOVSI  0 131072> TEMPLATE ![UVECTOR VECTOR TUPLE 
STORAGE!] UVECTOR STORAGE STRING BYTES COMMON-SUB (<OR FALSE COMMON>) %<RGLOC 
RESTERS T> %<RGLOC STYPES T> REST NO-KILL (LIST) CAREFUL ERROR 
"ARG OUT OF RANGE " %<TYPE-W MUDREF!-OP WORD> ALL PUT-COMMON-DAT %<RGLOC PATTRNS
T> T1 A11 IA11 A1 A2 IA1 IA2 T2 (<OR FALSE COMMON <LIST [REST COMMON]>>) %<RGLOC
NTHERS T> NTH INTH CHARACTER " ARG OUT OF RANGE " %<RGLOC LAST-AC T> %<RGLOC 
LAST-AC-1 T> %<RGLOC ALLACS T> STORE-SET <`MOVEI  `O*  36> .HERE!-OP (DATUM) [
UVECTOR STORAGE] %<RGLOC PUTTERS T> PUT GETYP!-OP TYPE-CODE!-OP %<RGLOC ACO T> 
STK %<RGLOC AC-A T> %<RGLOC AC-B T> %<RGLOC AC-C T> %<RGLOC AC-D T> %<RGLOC PUT 
T> %<RGLOC REST T> %<RGLOC SNODES T> %<TYPE-C SYMTAB VECTOR> TDEFER!-OP %<TYPE-W
COMMON VECTOR> %<TYPE-C COMMON VECTOR> %<TYPE-W SYMTAB VECTOR> ![STORAGE UVECTOR
STRING!] %<RGLOC NO-DATUM T>]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,PREG? PGLUE ![715827882 -22906492246 
-22906490881 -1 -1 -1 -1 -1048576 0!]>> 


<SETG REG? %<RSUBR-ENTRY '[PREG? REG? #DECL ("VALUE" ANY ATOM ANY "OPTIONAL" ANY
)] 29>> 

<SETG LIST-LNT-SPEC %<RSUBR-ENTRY '[PREG? LIST-LNT-SPEC #DECL ("VALUE" ANY NODE 
ANY ANY ANY ANY FIX)] 156>> 

<SETG LNTH-GEN %<RSUBR-ENTRY '[PREG? LNTH-GEN #DECL ("VALUE" ANY NODE ANY)] 674>
> 

<SETG MT-GEN %<RSUBR-ENTRY '[PREG? MT-GEN #DECL ("VALUE" ANY NODE ANY "OPTIONAL"
ANY <OR ATOM FALSE> ANY)] 1195>> 

<SETG TRUE-FALSE %<RSUBR-ENTRY '[PREG? TRUE-FALSE #DECL ("VALUE" ANY NODE ATOM <
OR DATUM ATOM> "OPTIONAL" ANY)] 1614>> 

<SETG REST-GEN %<RSUBR-ENTRY '[PREG? REST-GEN #DECL ("VALUE" DATUM NODE ANY)] 
1689>> 

<SETG VEC-REST %<RSUBR-ENTRY '[PREG? VEC-REST #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> ANY ANY ANY FIX NODE NODE <OR ATOM FALSE> <OR ATOM FALSE> <OR FALSE <LIST
FIX FIX>>)] 1858>> 

<SETG LIST-REST %<RSUBR-ENTRY '[PREG? LIST-REST #DECL ("VALUE" ANY NODE <OR ATOM
DATUM> ANY ATOM <OR ATOM FALSE> FIX NODE NODE <OR ATOM FALSE> <OR ATOM FALSE> <
OR FALSE <LIST FIX FIX>> "OPTIONAL" <OR ATOM FALSE AC> NODE ANY)] 2305>> 

<SETG PATTRNS '![() () ((`JUMPE  A11 |CERR2 ) (`HRRZ  A1 IA11)) ((`HRRZ  A1 IA11
)) ((`JUMPE  A11 |CERR2 ) (`HRRZ  A1 IA11) (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1))
((`HRRZ  A1 IA11) (`HRRZ  A1 IA1)) (T1 (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (
`SOJG  A2 T1)) (T1 (`HRRZ  A1 IA1) (`SOJG  A2 T1)) ((`JUMPL  A2 |CERR1 ) (
`JUMPE  A2 T2) T1 (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (`SOJG  A2 T1) T2) ((
`JUMPE  A2 T2) T1 (`HRRZ  A1 IA1) (`SOJG  A2 T1) T2) ((`JUMPE  A2 T2) T1 (
`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (`SOJG  A2 T1) T2) (T1 (`JUMPE  A1 |CERR2 ) 
(`HRRZ  A1 IA1) (`SOJG  A2 T1)) ((`JUMPE  A1 |CERR2 )) () ((`JUMPE  A11 |CERR2 )
(`HRRZ  A1 IA11) (`JUMPE  A1 |CERR2 )) ((`HRRZ  A1 IA11)) ((`JUMPE  A11 |CERR2 )
(`HRRZ  A1 IA11) (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (`JUMPE  A1 |CERR2 )) ((
`HRRZ  A1 IA11) (`HRRZ  A1 IA1)) (T1 (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (
`SOJG  A2 T1) (`JUMPE  A1 |CERR2 )) (T1 (`HRRZ  A1 IA1) (`SOJG  A2 T1)) ((
`JUMPLE  A2 |CERR2 ) (`SOJE  A2 T2) T1 (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (
`SOJG  A2 T1) T2 (`JUMPE  A1 |CERR2 )) ((`SOJE  A2 T2) T1 (`HRRZ  A1 IA1) (
`SOJG  A2 T1) T2) ((`JUMPLE  A2 |CERR1 ) (`SOJE  A2 T2) T1 (`HRRZ  A1 IA1) (
`SOJG  A2 T1) T2) ((`SOJE  A2 T2) T1 (`JUMPE  A1 |CERR2 ) (`HRRZ  A1 IA1) (
`SOJG  A2 T1) T2 (`JUMPE  A1 |CERR2 ))!]> 

<SETG RCHK %<RSUBR-ENTRY '[PREG? RCHK #DECL ("VALUE" ANY AC <OR FALSE ATOM>)] 
3527>> 

<SETG NTH-GEN %<RSUBR-ENTRY '[PREG? NTH-GEN #DECL ("VALUE" ANY NODE ANY 
"OPTIONAL" ANY ANY ANY)] 3573>> 

<SETG VEC-NTH %<RSUBR-ENTRY '[PREG? VEC-NTH #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> ANY ANY <OR FALSE ATOM> FIX NODE NODE ANY)] 4026>> 

<SETG LIST-NTH %<RSUBR-ENTRY '[PREG? LIST-NTH #DECL ("VALUE" ANY NODE <OR DATUM 
ATOM> ANY ANY ANY FIX NODE NODE ANY)] 4192>> 

<SETG STRING-REST %<RSUBR-ENTRY '[PREG? STRING-REST #DECL ("VALUE" ANY NODE ANY 
ANY ANY ANY FIX NODE NODE ANY ANY <OR FALSE <LIST FIX FIX>> "OPTIONAL" <OR NODE 
FALSE>)] 4292>> 

<SETG STRING-NTH %<RSUBR-ENTRY '[PREG? STRING-NTH #DECL ("VALUE" ANY NODE ANY 
ANY ANY ANY ANY NODE ANY ANY)] 5741>> 

<SETG STRING-PUT %<RSUBR-ENTRY '[PREG? STRING-PUT #DECL ("VALUE" ANY ANY ANY ANY
ANY ANY ANY ANY ANY ANY <OR FALSE <LIST FIX FIX>> ANY)] 5910>> 

<SETG STRINGER %<RSUBR-ENTRY '[PREG? STRINGER #DECL ("VALUE" <OR AC FALSE> <OR 
FALSE FIX> DATUM DATUM)] 5981>> 

<SETG RSTRING %<RSUBR-ENTRY '[PREG? RSTRING #DECL ("VALUE" DATUM DATUM AC ANY)] 
6205>> 

<SETG RESTERS [,STRING-REST ,STRING-REST ,STRING-REST ,VEC-REST ,VEC-REST ,
VEC-REST ,VEC-REST ,LIST-REST]> 

<SETG STYPES ![LIST TUPLE VECTOR UVECTOR STORAGE STRING BYTES TEMPLATE!]> 

<SETG NTH-PRED %<RSUBR-ENTRY '[PREG? NTH-PRED #DECL ("VALUE" <OR ATOM FALSE> FIX
)] 6380>> 

<SETG NTHERS [,TEMPLATE-NTH ,STRING-NTH ,STRING-NTH ,VEC-NTH ,VEC-NTH ,VEC-NTH ,
VEC-NTH ,LIST-NTH]> 

<SETG PUT-GEN %<RSUBR-ENTRY '[PREG? PUT-GEN #DECL ("VALUE" DATUM NODE ANY 
"OPTIONAL" ANY)] 6397>> 

<SETG VEC-PUT %<RSUBR-ENTRY '[PREG? VEC-PUT #DECL ("VALUE" ANY NODE ANY ANY ANY 
ANY FIX NODE NODE NODE <OR FALSE <LIST FIX FIX>> ANY)] 6779>> 

<SETG LIST-PUT %<RSUBR-ENTRY '[PREG? LIST-PUT #DECL ("VALUE" ANY NODE ANY ANY 
ANY ANY FIX NODE NODE ANY ANY ANY)] 7469>> 

<SETG PUTTERS [,TEMPLATE-PUT ,STRING-PUT ,STRING-PUT ,VEC-PUT ,VEC-PUT ,VEC-PUT 
,VEC-PUT ,LIST-PUT]> 

<SETG DATCLOB %<RSUBR-ENTRY '[PREG? DATCLOB #DECL ("VALUE" ANY NODE DATUM FIX 
FIX DATUM ANY ANY "OPTIONAL" FIX)] 7531>> 

<SETG MPCNT %<RSUBR-ENTRY '[PREG? MPCNT #DECL ("VALUE" FIX ATOM)] 7802>> 

<SETG IPUT-GEN %<RSUBR-ENTRY '[PREG? IPUT-GEN #DECL ("VALUE" ANY NODE ANY)] 7821
>> 

<SETG IREMAS-GEN %<RSUBR-ENTRY '[PREG? IREMAS-GEN #DECL ("VALUE" ANY NODE ANY)] 
7995>> 

<SETG PUTREST-GEN %<RSUBR-ENTRY '[PREG? PUTREST-GEN #DECL ("VALUE" ANY NODE ANY)
] 8108>> 

<SETG SIDE-EFFECTS? %<RSUBR-ENTRY '[PREG? SIDE-EFFECTS? #DECL ("VALUE" ANY NODE)
] 8576>> 

<SETG COMMUTE-STRUC %<RSUBR-ENTRY '[PREG? COMMUTE-STRUC #DECL ("VALUE" ANY ANY 
NODE NODE)] 8598>> 

<SETG DEFER-IT %<RSUBR-ENTRY '[PREG? DEFER-IT #DECL ("VALUE" DATUM NODE DATUM)] 
8782>> 

\ 

"ROUTINES TO DO COMMON SUBEXPRESSION HACKING IN SIMPLE CASES
 (CURRENTLY NTH REST)." 

<NEWTYPE COMMON VECTOR '<VECTOR ATOM <OR COMMON SYMTAB> FIX ANY <PRIMTYPE LIST>>
> 

<SETG COMMON-TYPE 1> 

"TYPE OF COMMON (ATOM)" 

<SETG COMMON-SYMT 2> 

"POINTER TO OR COMMON SYMTAB" 

<SETG COMMON-ITEM 3> 

"3RD ARGUMENT TO NTH,REST,PUT ETC." 

<SETG COMMON-PRIMTYPE 4> 

"PRIMTYPE OF OBJECT IN COMMON" 

<SETG COMMON-DATUM 5> 

"DATUM FOR THIS COMMON" 

<MANIFEST COMMON-TYPE COMMON-SYMTAB COMMON-ITEM COMMON-PRIMTYPE COMMON-DATUM> 

"ROUTINE TO CREATE A COMMON" 

<SETG COMMON %<RSUBR-ENTRY '[PREG? COMMON #DECL ("VALUE" COMMON ATOM <OR SYMTAB 
COMMON> FIX ANY ANY)] 9102>> 

"THIS ROUTINE BUILDS A CANONACAILZED COMMON.  THIS ROUTINE CAN RETURN
 EITHER A COMMON OR A LIST OF COMMONS." 

<SETG BUILD-COMMON %<RSUBR-ENTRY '[PREG? BUILD-COMMON #DECL ("VALUE" ANY ATOM <
OR SYMTAB COMMON LIST> FIX ANY ANY)] 9133>> 

"ROUTINE TO FIND A COMMON GIVEN A NODE" 

<SETG FIND-COMMON %<RSUBR-ENTRY '[PREG? FIND-COMMON #DECL ("VALUE" <OR COMMON 
FALSE> NODE "OPTIONAL" ANY ANY)] 9376>> 

"ROUTINE TO SEE IF A COMMON AND A NODE ARE EQUAL" 

<SETG COMMON-EQUAL %<RSUBR-ENTRY '[PREG? COMMON-EQUAL #DECL ("VALUE" ANY <OR 
NODE SYMTAB> <OR SYMTAB COMMON>)] 9491>> 

"ROUTINE TO SEE IF THE CODES OF THE COMMONS ARE EQUAL" 

<SETG EQCODE %<RSUBR-ENTRY '[PREG? EQCODE #DECL ("VALUE" <OR ATOM FALSE> NODE 
COMMON "OPTIONAL" ANY)] 9541>> 

"ROUTINE TO SEE IF THE NUMBERS OF A COMMON AND A NODE ARE EQUAL" 

<SETG EQNUM %<RSUBR-ENTRY '[PREG? EQNUM #DECL ("VALUE" <OR ATOM FALSE> NODE 
COMMON "OPTIONAL" ANY)] 9596>> 

"ROUTINE TO SEE IF THE KIDS OF A COMMON AND A NODE ARE EQUAL" 

<SETG EQKIDS %<RSUBR-ENTRY '[PREG? EQKIDS #DECL ("VALUE" ANY NODE COMMON 
"OPTIONAL" ANY)] 9642>> 

"ROUTINE TO FLUSH COMMONS IF PUTS OR PUTRESTS COME ALONG
 IF TYP IS FALSE THEN KILL ALL COMMONS. 
 OTHERWISE KILL THOSE COMMONS WHICH ARE TYE SAME TYPE AS TYP OR UNKNOWN." 

<SETG KILL-COMMON %<RSUBR-ENTRY '[PREG? KILL-COMMON #DECL ("VALUE" <OR FALSE AC>
ANY)] 9690>> 

"FLUSH-COMMONS IS USED TO FLUSH ALL THE COMMONS FROM AN AC" 

<SETG FLUSH-COMMONS %<RSUBR-ENTRY '[PREG? FLUSH-COMMONS #DECL ("VALUE" <OR FALSE
LIST> LIST ANY)] 9737>> 

"FLUSH? SEES IF A COMMON SHOULD BE FLUSHED" 

<SETG FLUSH? %<RSUBR-ENTRY '[PREG? FLUSH? #DECL ("VALUE" <OR ATOM FALSE> ANY ANY
)] 9814>> 

"FLUSH-COMMON-SYMT IS USED TO FLUSH THE COMMONS ASSOCATED WITH A GIVEN SYMTAB" 

<SETG FLUSH-COMMON-SYMT %<RSUBR-ENTRY '[PREG? FLUSH-COMMON-SYMT #DECL ("VALUE" <
OR FALSE AC> SYMTAB)] 9849>> 

<SETG EQSYMT %<RSUBR-ENTRY '[PREG? EQSYMT #DECL ("VALUE" ANY ANY ANY)] 9963>> 

"SEE IF NODE CONTAINS SYMTABS" 

<SETG SYMTAB? %<RSUBR-ENTRY '[PREG? SYMTAB? #DECL ("VALUE" ANY NODE "OPTIONAL" 
ANY)] 10000>> 

"SEE IF THIS IS A NTH OR REST OR PUT CODE" 

<SETG NTH-REST-PUT? %<RSUBR-ENTRY '[PREG? NTH-REST-PUT? #DECL ("VALUE" <OR ATOM 
FALSE> NODE)] 10037>> 

"SMASH A COMMON INTO AN DATUM" 

<SETG SMASH-COMMON %<RSUBR-ENTRY '[PREG? SMASH-COMMON #DECL ("VALUE" COMMON 
COMMON DATUM)] 10061>> 

<SETG HACK-COMMON %<RSUBR-ENTRY '[PREG? HACK-COMMON #DECL ("VALUE" <OR COMMON 
FALSE LIST> ANY ANY ANY ANY DATUM ANY ANY ANY ANY)] 10148>> 

<SETG FIND-COMMON-AC %<RSUBR-ENTRY '[PREG? FIND-COMMON-AC #DECL ("VALUE" <OR 
COMMON FALSE> ANY)] 10270>> 

<SETG FIND-COMMON-REST-NODE %<RSUBR-ENTRY '[PREG? FIND-COMMON-REST-NODE #DECL (
"VALUE" <OR COMMON FALSE> NODE)] 10322>> 

<SETG SPEC-COMMON-EQUAL %<RSUBR-ENTRY '[PREG? SPEC-COMMON-EQUAL #DECL ("VALUE" 
ANY ATOM NODE FIX COMMON)] 10356>> 

<SETG COMMON-CLOBBER %<RSUBR-ENTRY '[PREG? COMMON-CLOBBER #DECL ("VALUE" ANY 
COMMON NODE NODE FIX NODE ANY ANY)] 10394>> 

<SETG LOC-COMMON %<RSUBR-ENTRY '[PREG? LOC-COMMON #DECL ("VALUE" ANY COMMON NODE
ANY NODE NODE <OR ATOM DATUM>)] 10676>> 

<SETG GET-COMMON-DATUM %<RSUBR-ENTRY '[PREG? GET-COMMON-DATUM #DECL ("VALUE" 
DATUM COMMON)] 10745>> 


<PACKAGE "SUBRFY">

<ENTRY SUBRIFY KILL-SUBRFY>

<USE "SORTX">

<BLOCK (<ROOT>)>

<SETG SUBRFY-CURR-ITEM <FREEZE <IVECTOR 64 0>>>

<SETG SUBRFY-ITEM-LIST (,SUBRFY-CURR-ITEM)>

<NEWTYPE INTERNAL-RSUBR-TABLE UVECTOR>

<SET GLUE T>

<ENDBLOCK>

<SETG INSTRUCTION-FIELD <BITS 9 27>>

<SETG AC-FIELD <BITS 4 23>>

<SETG @-BIT <BITS 1 22>>

<SETG INDEX-AC-FIELD <BITS 4 18>>

<SETG RHW <BITS 18>>

<SETG LHW <BITS 18 18>>

<SETG R 14>

<SETG M 13>

<FLOAD "BTB;LOC NBIN">

<FLOAD "CLR;BYTER NBIN">

<FLOAD "BTB;SUBRAD NBIN">

<MANIFEST R
	  M
	  LHW
	  RHW
	  INSTRUCTION-FIELD
	  AC-FIELD
	  @-BIT
	  INDEX-AC-FIELD>

<GDECL (SUBRFY-CURR-ITEM) VECTOR>

<GDECL (SUBRFY-ITEM-LIST) <LIST [REST VECTOR]>>

""

<DEFINE SUBRIFY BAD-EXIT (GRP CHANNEL-NAME
			  "OPTIONAL" (INFO-CHN <>)
			  "AUX" RIENTS GRPLST CHN (RSUBRS ()) (RSUBR-ENTRYS ())
				(RVEC-ITEMS ()) (CODLST ()) (IENTCNT 0) IENTUVEC
				(IENTIND (())) (RSBIND (())) IENTS BR ELOC
				(ERR <>) (DECLLST ()) (ENTLOCIND (()))
				(WARNINGS ()) (MCALLS ()))
   #DECL ((GRP) ATOM (CHANNEL-NAME) STRING (INFO-CHN) <OR FALSE CHANNEL>
	  (CODLST MCALLS) LIST (CHN) <OR FALSE CHANNEL>
	  (RSUBRS) <LIST [REST RSUBR]> (RSUBR-ENTRYS) <LIST [REST RSUBR-ENTRY]>
	  (BAD-EXIT) <SPECIAL ACTIVATION> (RVEC-ITEMS) LIST (IENTCNT) FIX
	  (IENTUVEC) UVECTOR (DECLLST) LIST (WARNINGS) <SPECIAL LIST>)
   <NOPURE>
   <COND (<NOT <SET GRPLST <GROUP? .GRP>>>
	  <SET ERR T>
	  <RETURN <ERRMSG .GRP "not a group."> .BAD-EXIT>)>
   <COND (<NOT <SET CHN <OPEN "PRINT" .CHANNEL-NAME>>>
	  <RETURN .CHN .BAD-EXIT>)>
   <UNWIND
    <PROG ()
      <OUT-INFO .INFO-CHN "Beginning SUBRification of" .GRP>
      <MAPF <>
       <FUNCTION (RSB "AUX" RSBR) 
	       <COND (<SET RSBR <POSSIBLE-RSUBR? .RSB>>
		      <COND (<TYPE? .RSBR RSUBR>
			     <COND (<NOT <GET .RSBR GLUE>>
				    <SET ERR T>
				    <RETURN <ERRMSG <2 .RSBR>
						    "lacks glue bits.">
					    .BAD-EXIT>)
				   (<NOT <TYPE? <1 .RSBR> CODE>>
				    <SET ERR T>
				    <RETURN <ERRMSG <2 .RSBR> "is not an NBIN.">
					    .BAD-EXIT>)>
			     <SET RSUBRS (.RSBR !.RSUBRS)>)
			    (<TYPE? .RSBR RSUBR-ENTRY>
			     <SET RSUBR-ENTRYS (.RSBR !.RSUBR-ENTRYS)>)>)>>
       .GRPLST>
      <MAPF <>
       <FUNCTION (RSEB "AUX" (NAME <2 .RSEB>) RSUBR) 
	       #DECL ((RSEB) RSUBR-ENTRY)
	       <R-E-PUT .RSEB 1 <SET RSUBR <2 <1 .RSEB>>>>
	       <COND (<NOT <MEMQ ,.RSUBR .RSUBRS>>
		      <SET ERR T>
		      <RETURN <ERRMSG <SET NAME <2 .RSEB>>
				      "is RSUBR-ENTRY of RSUBR not in GROUP.">
			      .BAD-EXIT>)>
	       <COND (<NOT <SET RIENTS <GET .RSUBR .RSBIND>>>
		      <PUT .RSUBR .RSBIND (.RSEB <ENTRY-LOC .RSEB>)>)
		     (ELSE
		      <SET BR .RIENTS>
		      <COND (<L? <SET ELOC <ENTRY-LOC .RSEB>> <2 .BR>>
			     <SET RIENTS (.RSEB .ELOC !.RIENTS)>)
			    (<REPEAT ((RR <REST .RIENTS 2>))
				     #DECL ((RR) LIST)
				     <COND (<OR <EMPTY? .RR>
						<L=? .ELOC <2 .RR>>>
					    <PUTREST .BR (.RSEB .ELOC !.RR)>
					    <RETURN>)>>)>
		      <PUT .RSUBR .RSBIND .RIENTS>)>
	       <OUT-INFO .INFO-CHN "RSUBR-ENTRY named:" .NAME>>
       .RSUBR-ENTRYS>
      <MAPR <>
       <FUNCTION (RSBRS
		  "AUX" (RSBR <1 .RSBRS>) (NAME <2 .RSBR>) GLUE-BITS GLUESTR LNT
			NUM (CNT 0) RENTS CODE SLNT SORTED-IENTS)
	  #DECL ((RSBR) RSUBR (NAME) ATOM (GLUE-BITS) <PRIMTYPE UVECTOR>
		 (GLUESTR) STRING (LNT NUM CNT) FIX (RSBRS) LIST
		 (RSBRS) <LIST [REST RSUBR]> (CODE) <PRIMTYPE UVECTOR>)
	  <CHUTYPE <SET CODE <1 .RSBR>> FIX>
	  <OUT-INFO .INFO-CHN "SUBRifying RSUBR:" .NAME>
	  <SET GLUE-BITS <GET .RSBR GLUE>>
	  <SET GLUESTR <BYTER .GLUE-BITS>>
	  <SET LNT
	       </ <+ <SET SLNT
			  <+ <SET LNT <LENGTH .CODE>>
			     <- <CHTYPE <GETBITS <NTH .CODE .LNT> ,LHW> FIX>>
			     <- <CHTYPE <GETBITS <NTH .CODE .LNT> ,RHW> FIX>>
			     -1>>
		     17>
		  18>>
	  <SET CODE
	       <SUBSTRUC .CODE
			 0
			 .SLNT
			 <REST .CODE <- <LENGTH .CODE> .SLNT>>>>
	  <SET IENTS <BUILD-IENTS <REST .GLUE-BITS .LNT>>>
	  <SET SORTED-IENTS <SORT <> ![!.IENTS!] 2 1>>
	  <PROG ((IENTLST .IENTS)
		 (RENTS <GET .NAME .RSBIND>)
		 (ONEIENTS ()))
	    #DECL ((IENTLST ONEIENTS) LIST (RENTS) <OR FALSE LIST>)
	    <COND
	     (<EMPTY? .RENTS> <PUT .NAME .IENTIND .IENTS>)
	     (ELSE
	      <REPEAT ((LOW <2 .RENTS>))
		      #DECL ((LOW) FIX)
		      <COND (<EMPTY? .IENTLST> <RETURN>)
			    (<G=? <2 .IENTLST> .LOW> <RETURN>)
			    (<SET ONEIENTS
				  <ADDON .ONEIENTS
					 (<1 .IENTLST> <2 .IENTLST>)>>)>
		      <SET IENTLST <REST .IENTLST 2>>>
	      <PUT .NAME .IENTIND .ONEIENTS>
	      <REPEAT ()
		      <PUT <2 <1 .RENTS>>
			   .ENTLOCIND
			   <UPDATE-M <2 .RENTS> .SORTED-IENTS>>
		      <SET ONEIENTS ()>
		      <COND (<==? <LENGTH .RENTS> 2> <SET ONEIENTS .IENTLST>)
			    (<REPEAT ((LOW <4 .RENTS>))
				     #DECL ((LOW) FIX)
				     <COND (<EMPTY? .IENTLST> <RETURN>)
					   (<G=? <2 .IENTLST> .LOW> <RETURN>)
					   (<SET ONEIENTS
						 <ADDON
						  .ONEIENTS
						  (<1 .IENTLST>
						   <2 .IENTLST>)>>)>
				     <SET IENTLST <REST .IENTLST 2>>>)>
		      <PUT <2 <1 .RENTS>> .IENTIND .ONEIENTS>
		      <COND (<EMPTY? <SET RENTS <REST .RENTS 2>>> <RETURN>)>>)>>
	  <REPEAT ((COD .CODE) (BITSTR .GLUESTR) BIT WRD ITEM (PTRCOD .COD)
		   PUTIN)
	    #DECL ((BIT) FIX (COD PTRCOD) <PRIMTYPE UVECTOR> (WRD) FIX
		   (BITSTR) STRING (PUTIN) <OR ATOM FALSE>)
	    <COND (<EMPTY? .PTRCOD> <RETURN>)>
	    <SET WRD <1 .PTRCOD>>
	    <SET BIT <CHTYPE <1 .BITSTR> FIX>>
	    <SET PUTIN T>
	    <COND (<==? .BIT 3>
		   <SET ITEM <GET-RITEM .WRD .RSBR>>
		   <SET NUM <ADD-ITEM .ITEM>>
		   <SET WRD <R-TO-ITEM .WRD .NUM>>
		   <SET RVEC-ITEMS (.ITEM !.RVEC-ITEMS)>)
		  (<==? .BIT 2>
		   <SET ITEM <GET-RITEM .WRD .RSBR>>
		   <COND (<TYPE? .ITEM RSUBR RSUBR-ENTRY>)
			 (<AND <GASSIGNED? .ITEM>
			       <TYPE? ,.ITEM RSUBR RSUBR-ENTRY>>
			  <SET ITEM ,.ITEM>)
			 (<WARNING "UNASSIGNED RSUBR or FUNCTION" .ITEM>)>
		   <SET NUM <ADD-ITEM .ITEM>>
		   <OR <TYPE? .ITEM ATOM>
		       <MEMQ <2 .ITEM> .MCALLS>
		       <SET MCALLS (<2 .ITEM> .NUM !.MCALLS)>>
		   <SET WRD <R-TO-ITEM .WRD .NUM>>)
		  (<==? .BIT 1>
		   <COND (<R? .WRD>
			  <SET ERR T>
			  <RETURN <ERRMSG .ITEM "Contains impure slot">
				  .BAD-EXIT>)>
		   <SET WRD
			<PUTBITS .WRD
				 ,RHW
				 <UPDATE-M <CHTYPE <GETBITS .WRD ,RHW> FIX>
					   .SORTED-IENTS>>>)
		  (<SET ITEM
			<REPEAT ((PTR .IENTS))
				#DECL ((PTR) <LIST [REST FIX]>)
				<COND (<EMPTY? .PTR> <RETURN <>>)>
				<COND (<==? .CNT <2 .PTR>>
				       <RETURN <REST .PTR>>)>
				<SET PTR <REST .PTR 2>>>>
		   <COND (<NOT <==? .WRD ,SUBM-M-P>>
			  <SET ERR T>
			  <RETURN <ERRMSG "RSUBR in bad format" .NAME>
				  .BAD-EXIT>)>
		   <PUT .ITEM 1 <UPDATE-M .CNT .SORTED-IENTS>>
		   <SET PUTIN <>>)
		  (<==? .WRD ,JRST-MPOPJ> <SET WRD ,POPJ-P>)
		  (<==? .WRD ,SUBM-M-P> <SET WRD ,JFCL>)>
	    <COND (.PUTIN <PUT .COD 1 .WRD> <SET COD <REST .COD>>)>
	    <SET CNT <+ .CNT 1>>
	    <SET BITSTR <REST .BITSTR>>
	    <SET PTRCOD <REST .PTRCOD>>>
	  <SET CODE
	       <SUBSTRUC .CODE 0 <- <LENGTH .CODE> </ <LENGTH .IENTS> 2>>>>
	  <SET CODLST (.CODE !.CODLST)>
	  <SET DECLLST (<3 .RSBR> !.DECLLST)>
	  <PUT <SET RSBR
		    <SETG .NAME
			  <SET RSBR
			       <RSUBR [<CHTYPE .CODE CODE>
				       <2 .RSBR>
				       <3 .RSBR>
				       <CHTYPE
					<BUILD-INTERNAL-ENTRY .IENTS>
					INTERNAL-RSUBR-TABLE>]>>>>
	       GLUE
	       .GLUE-BITS>
	  <CHECK-OBJECT .NAME .MCALLS>
	  <REPEAT ((PTR .RSUBR-ENTRYS) RSB)
		  #DECL ((PTR) <LIST [REST RSUBR-ENTRY]>)
		  <COND (<EMPTY? .PTR> <RETURN>)>
		  <COND (<==? <1 <SET RSB <1 .PTR>>> .NAME>
			 <PUT .PTR
			      1
			      <SETG <2 .RSB>
				    <RSUBR-ENTRY [.RSBR <2 .RSB> <3 .RSB>]
						 <GET <2 .RSB> .ENTLOCIND>>>>
			 <CHECK-OBJECT <2 .RSB> .MCALLS>
			 <PUT <2 .RSB> .ENTLOCIND>)>
		  <SET PTR <REST .PTR>>>
	  <PUT .RSBRS 1 .RSBR>
	  <SET IENTCNT <+ .IENTCNT <LENGTH .IENTS>>>>
       .RSUBRS>
      <SET IENTUVEC <IUVECTOR .IENTCNT 0>>
      <OUT-INFO .INFO-CHN "Beginning PURIFICATION">
      <PURIFY !.RSUBRS
	      !.RSUBR-ENTRYS
	      !.RVEC-ITEMS
	      .IENTUVEC
	      !.DECLLST>
      <OUT-INFO .INFO-CHN "Beginning Pass-2">
      <MAPF <>
       <FUNCTION (RSBR "AUX" CODE GBYTE (NAME <2 .RSBR>) LOCATION) 
	       #DECL ((RSBR) RSUBR (CODE) <<PRIMTYPE UVECTOR> [REST FIX]>
		      (GBYTE) STRING)
	       <SET LOCATION <LOC <SET CODE <1 .RSBR>>>>
	       <SET GBYTE <BYTER <GET .RSBR GLUE>>>
	       <PUT .RSBR GLUE>
	       <SET IENTS <BUILD-IENTS <4 .RSBR>>>
	       <UNRELATE .CODE .LOCATION .GBYTE .IENTS>
	       <SET CODE <4 .RSBR>>
	       <UPINT1 .CODE .LOCATION>
	       <SEND-OUT-INFO .CHN
			      <2 .RSBR>
			      <3 .RSBR>
			      <GET <2 .RSBR> .IENTIND>>
	       <REPEAT ((PTRBITS .CODE) WRD)
		       #DECL ((PTRBITS) <PRIMTYPE UVECTOR>)
		       <COND (<EMPTY? .PTRBITS> <RETURN>)>
		       <SET WRD <CHTYPE ,MOVEI FIX>>
		       <SET WRD
			    <PUTBITS .WRD
				     ,RHW
				     <CHTYPE <GETBITS <1 .PTRBITS> ,RHW> FIX>>>
		       <PUT .IENTUVEC 1 .WRD>
		       <PUT .IENTUVEC 2 ,JRST-RMCALL>
		       <SET WRD <1 .PTRBITS>>
		       <SET WRD <PUTBITS .WRD ,RHW <LOC .IENTUVEC>>>
		       <PUT .PTRBITS 1 .WRD>
		       <SET PTRBITS <REST .PTRBITS 1>>
		       <SET IENTUVEC <REST .IENTUVEC 2>>>
	       <PUT <2 .RSBR> .RSBIND>
	       <PUT <2 .RSBR> .IENTIND>>
       .RSUBRS>
      <REPURE .IENTUVEC>
      <MAPF <>
	    <FUNCTION (RSB) 
		    <REPURE .RSB>
		    <REPURE <1 .RSB>>
		    <REPURE <3 .RSB>>
		    <REPURE <4 .RSB>>>
	    .RSUBRS>
      <MAPF <>
	    <FUNCTION (RENTRY "AUX" (IENTS <GET <2 .RENTRY> .IENTIND>)) 
		    #DECL ((RENTRY) RSUBR-ENTRY (IENTS) LIST)
		    <SEND-OUT-INFO .CHN <2 .RENTRY> <3 .RENTRY> .IENTS>
		    <REPURE .RENTRY>
		    <PUT <2 .RENTRY> .IENTIND>>
	    .RSUBR-ENTRYS>
      <CLOSE .CHN>
      <SET-PUR>
      "DONE">
    <PROG ()
	  <COND (<NOT .ERR>
		 <PRINC "You really didn't want to do that" ,OUTCHAN>
		 <CRLF ,OUTCHAN>)>
	  <CLOSE .CHN>>>>

""

"OUT-INFO IS USED TO SEND OUT INFORMATION TO THE USER."

<DEFINE OUT-INFO (CHN "TUPLE" INFO) 
	#DECL ((CHN) <OR CHANNEL FALSE>)
	<COND (.CHN
	       <MAPF <>
		     <FUNCTION (INF) 
			     <COND (<TYPE? .INF STRING> <PRINC .INF .CHN>)
				   (<PRIN1 .INF .CHN>)>
			     <PRINC !"  .CHN>>
		     .INFO>
	       <CRLF .CHN>)>>

"ROUTINE TO SEE IF WE HAVE A VALID GROUP."

<DEFINE GROUP? (ATM) 
	#DECL ((ATM) ATOM)
	<AND <ASSIGNED? .ATM> <TYPE? ..ATM LIST> ..ATM>>

"ROUTINE TO SEE IF WE HAVE A SETG TO A RSUBR OR RSUBR-ENTRY."

<DEFINE POSSIBLE-RSUBR? (FRM) 
	<AND <TYPE? .FRM FORM>
	     <==? <LENGTH .FRM> 3>
	     <==? <1 .FRM> SETG>
	     <TYPE? <3 .FRM> RSUBR RSUBR-ENTRY>
	     <==? <2 .FRM> <2 <3 .FRM>>>
	     <3 .FRM>>>

"ROUTINE TO RETURN A #FALSE (ERRSTRING)."

<DEFINE ERRMSG ("TUPLE" ITEMS) 
	<CHTYPE (<MAPF ,STRING
		       <FUNCTION (ITEM) 
			       <COND (<TYPE? .ITEM STRING> <MAPRET .ITEM !" >)
				     (<MAPRET <UNPARSE .ITEM> !" >)>>
		       .ITEMS>)
		FALSE>>

"ROUTINE TO BUILD A WORKABLE INTERNAL ENTRIES LIST FROM THE GLUE-BITS FORMAT
 THE NEW FORMAT IS (# OF ARGS ADDRESS ...)."

<DEFINE BUILD-IENTS (UVEC "AUX" (FINLST ())) 
	#DECL ((UVEC) <PRIMTYPE UVECTOR> (FINLST) LIST)
	<MAPF <>
	      <FUNCTION (ELE) 
		      #DECL ((ELE) <PRIMTYPE WORD>)
		      <SET FINLST
			   (<CHTYPE <GETBITS .ELE ,RHW> FIX>
			    <CHTYPE <GETBITS .ELE ,LHW> FIX>
			    !.FINLST)>>
	      .UVEC>
	<LREVERSE .FINLST>>

"UNRELEATE UNRELATIVIZES A CODE UVECTOR."

<DEFINE UNRELATE (CODE NLOC GLUE-BITS IENTS) 
   #DECL ((NLOC) FIX (CODE) <PRIMTYPE UVECTOR> (GLUE-BITS) STRING
	  (IENTS) <LIST [REST FIX]>)
   <REPEAT (WRD BIT (CNT 0))
	   #DECL ((WRD BIT CNT) FIX)
	   <SET WRD <1 .CODE>>
	   <SET BIT <CHTYPE <1 .GLUE-BITS> FIX>>
	   <COND (<REPEAT ((PTR .IENTS))
			#DECL ((PTR) <LIST [REST FIX]>)
			  <COND (<EMPTY? .PTR> <RETURN <>>)
				(<==? .CNT <2 .PTR>> <RETURN>)>
			  <SET PTR <REST .PTR 2>>>
		  <SET GLUE-BITS <REST .GLUE-BITS>>
		  <SET BIT <CHTYPE <1 .GLUE-BITS> FIX>>)>
	   <COND (<==? .BIT 1>
		  <SET WRD
		       <PUTBITS <PUTBITS .WRD
					 ,RHW
					 <+ <CHTYPE <GETBITS .WRD ,RHW> FIX>
					    .NLOC>>
				,INDEX-AC-FIELD
				0>>
		  <PUT .CODE 1 .WRD>)>
	   <SET GLUE-BITS <REST .GLUE-BITS>>
	   <COND (<EMPTY? <SET CODE <REST .CODE>>> <RETURN>)>
	   <SET CNT <+ .CNT 1>>>>

<DEFINE UPINT1 (UVC NLOC "AUX") 
	#DECL ((OLOC NLOC ADDEND) FIX (UVC) <PRIMTYPE UVECTOR>)
	<REPEAT ((PTR .UVC))
		#DECL ((PTR) <<PRIMTYPE UVECTOR> [REST FIX]>)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<PUT .PTR
		     1
		     <PUTBITS <1 .PTR>
			      ,RHW
			      <+ <CHTYPE <GETBITS <1 .PTR> ,RHW> FIX> .NLOC>>>
		<SET PTR <REST .PTR>>>>

<DEFINE BUILD-INTERNAL-ENTRY (IENTLST
			      "AUX" (UVEC
				     <IUVECTOR </ <LENGTH .IENTLST> 2> 0>))
	#DECL ((IENTLST) LIST (UVEC) <UVECTOR [REST FIX]>)
	<REPEAT ((PTR .IENTLST) (UVPTR .UVEC))
		#DECL ((PTR) LIST (UVPTR) <UVECTOR [REST FIX]>)
		<COND (<EMPTY? .PTR> <RETURN .UVEC>)>
		<PUT .UVPTR
		     1
		     <PUTBITS <PUTBITS 0 ,LHW <1 .PTR>> ,RHW <2 .PTR>>>
		<SET PTR <REST .PTR 2>>
		<SET UVPTR <REST .UVPTR 1>>>>

<DEFINE SEND-OUT-INFO (CHN NAME DECL INTERNAL-ENTRIES) 
	#DECL ((NAME) ATOM (DECL) DECL (INTERNAL-ENTRIES) LIST (CHN) CHANNEL)
	<COND (<NOT <EMPTY? .INTERNAL-ENTRIES>>
	       <PROG ((OUTCHAN .CHN))
		     <PRINC "<SETG ">
		     <PRIN1 .NAME>
		     <PRINC " #IRSUBR (">
		     <PRIN1 .DECL>
		     <PRINC " (">
		     <REPEAT ((PTR .INTERNAL-ENTRIES))
			     #DECL ((PTR) <LIST [REST <PRIMTYPE WORD>]>)
			     <PRIN1 <CHTYPE <1 .PTR> FIX>>
			     <PRINC !" >
			     <COND (<EMPTY? <SET PTR <REST .PTR 2>>> <RETURN>)>>
		     <PRINC "))>">
		     <CRLF>>)>>

<DEFINE GET-RITEM (WRD RVEC) 
	#DECL ((WRD) FIX (RVEC) <PRIMTYPE VECTOR>)
	<NTH .RVEC </ <+ <CHTYPE <GETBITS .WRD ,RHW> FIX> 2> 2>>>

<DEFINE R? (WRD) <==? <CHTYPE <GETBITS .WRD ,INDEX-AC-FIELD> FIX> ,R>>

<DEFINE LREVERSE (LST "AUX" (VAL ()) TMP) 
	#DECL ((LST VAL TMP VALUE) LIST)
	<REPEAT ()
		<COND (<EMPTY? .LST> <RETURN .VAL>)>
		<SET TMP <REST .LST>>
		<SET VAL <PUTREST .LST .VAL>>
		<SET LST .TMP>>>

<DEFINE ADDON (OB AD) 
	#DECL ((AD OB) <PRIMTYPE LIST>)
	<COND (<EMPTY? .OB> .AD)
	      (ELSE <PUTREST <REST .OB <- <LENGTH .OB> 1>> .AD> .OB)>>

<DEFINE WARNING ("TUPLE" MSGS "AUX" WRNLST) 
	<COND (<MEMBER <SET WRNLST (!.MSGS)> .WARNINGS>)
	      (<PRINC "WARNING: " ,OUTCHAN>
	       <SET WARNINGS (.WRNLST !.WARNINGS)>
	       <MAPF <>
		     <FUNCTION (ITEM) 
			     <COND (<TYPE? .ITEM STRING> <PRINC .ITEM ,OUTCHAN>)
				   (<PRIN1 .ITEM ,OUTCHAN>)>
			     <PRINC " " ,OUTCHAN>>
		     .MSGS>
	       <CRLF ,OUTCHAN>)>>

<DEFINE UPDATE-M (NUM IENTS) 
	#DECL ((NUM) FIX (IENTS) <UVECTOR [REST FIX]>)
	<REPEAT ((CNT 0))
	  #DECL ((CNT) FIX)
		<COND (<OR <EMPTY? .IENTS> <L=? .NUM <2 .IENTS>>>
		       <RETURN <- .NUM .CNT>>)
		      (<SET CNT <+ .CNT 1>>)>
		<SET IENTS <REST .IENTS 2>>>>


""

<DEFINE ADD-ITEM (ITEM) 
	<COND (<ITEM-MEMQ .ITEM>)
	      (ELSE
	       <COND (<EMPTY? ,SUBRFY-CURR-ITEM>
		      <SETG SUBRFY-CURR-ITEM <FREEZE <IVECTOR 64 0>>>
		      <SETG SUBRFY-ITEM-LIST (,SUBRFY-CURR-ITEM !,SUBRFY-ITEM-LIST)>)>
	       <PUT ,SUBRFY-CURR-ITEM 1 .ITEM>
	       <SET ITLOC <LOC ,SUBRFY-CURR-ITEM>>
	       <SETG SUBRFY-CURR-ITEM <REST ,SUBRFY-CURR-ITEM>>
	       .ITLOC)>>

<DEFINE ITEM-MEMQ (ITEM) 
	<MAPF <>
	      <FUNCTION (ITL "AUX" ITM) 
		      #DECL ((ITL) VECTOR)
		      <COND (<SET ITM <MEMBER .ITEM .ITL>>
			     <MAPLEAVE <LOC .ITM>>)>>
	      ,SUBRFY-ITEM-LIST>>

<DEFINE R-TO-ITEM (WRD NUM) 
	#DECL ((WRD NUM) FIX)
	<PUTBITS <PUTBITS .WRD ,INDEX-AC-FIELD 0>
		 <BITS 17 1>
		 </ .NUM 2>>>


<DEFINE CHECK-OBJECT (ITEM MCALLS "AUX" LST) 
	#DECL ((ITEM) ATOM (MCALLS) LIST)
	<COND (<SET LST <MEMQ .ITEM .MCALLS>> <SMASH ,.ITEM <2 .LST>>)>>


<DEFINE KILL-SUBRFY ("AUX" (DC <DECL-CHECK>)) 
	<DECL-CHECK <>>
	<KILL-OBLIST ISUBRFY!-SUBRFY!-PACKAGE>
	<KILL-OBLIST SUBRFY!-PACKAGE>
	<KILL-OBLIST OP!-PACKAGE>
	<DECL-CHECK .DC>
	<GUNASSIGN <UNASSIGN <REMOVE KILL-OBLIST>>>
	T>

<DEFINE KILL-OBLIST (ATM "AUX" OBL) 
   #DECL ((ATM) ATOM)
   <SET OBL <GET .ATM OBLIST>>
   <PUT .ATM OBLIST>
   <PUT .OBL OBLIST>
   <REMOVE .ATM>
   <MAPF <>
    <FUNCTION (OBELE) 
	    <MAPF <>
	     <FUNCTION (ATM) 
		     <COND (<N==? .ATM KILL-OBLIST>
			    <GUNASSIGN <UNASSIGN <REMOVE .ATM>>>)>>
	     .OBELE>>
    .OBL>>

""

<FLOAD "BTB;OPHACK GBIN">

<FLOAD "CLR;MUDHAK >">

<BEGIN-HACK "BTB">

<BEGIN-MHACK>

<DEFINE IEMIT ("TUPLE" ARGS "AUX" (WRD 0) (FIXES 0)) 
	<MAPF <>
	      <FUNCTION (ITEM) 
		      #DECL ((ITEM) <PRIMTYPE WORD>)
		      <COND (<TYPE? .ITEM FIX> <SET FIXES <+ .ITEM .FIXES>>)
			    (<TYPE? .ITEM MUDREF!-OP>
			     <SET FIXES <+ <SQUOTA .ITEM> .FIXES>>)
			    (ELSE <SET WRD <CHTYPE <ORB .ITEM .WRD> FIX>>)>>
	      .ARGS>
	<CHTYPE <PUTBITS .WRD
			 ,RHW
			 <+ <CHTYPE <GETBITS .WRD ,RHW> FIX> .FIXES>>
		FIX>>

<SETG JFCL <IEMIT #OPCODE!-OP!-PACKAGE *255000000000*>>

<SETG JRST-MPOPJ
      <IEMIT #OPCODE!-OP!-PACKAGE *254000000000* |MPOPJ >>

<SETG JRST-RMCALL
      <IEMIT #OPCODE!-OP!-PACKAGE *254000000000* |RMCALL >>

<SETG SUBM-M-P
      <IEMIT #OPCODE!-OP!-PACKAGE *276000000000*
	     #OPCODE!-OP!-PACKAGE *000640000000*
	     #OPCODE!-OP!-PACKAGE *000017000000*>>

<SETG POPJ-P
      <IEMIT #OPCODE!-OP!-PACKAGE *263000000000*
	     #OPCODE!-OP!-PACKAGE *000740000000*>>

<SETG MOVEI <IEMIT `MOVEI>>

<GDECL (JFCL JRST-MPOPJ JRST-RMCALL POPJ-P SUBM-M-P) FIX>

<END-HACK>

<ENDPACKAGE>

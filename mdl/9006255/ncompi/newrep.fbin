'<PCODE "1NEWREP">

" Generate code for a poor innocent PROG or REPEAT." 

<PUT REP-STATE DECL '<LIST [5 <LIST [REST SYMTAB DATUM <OR FALSE ATOM> <OR ATOM 
FALSE>]>]>> 

"" 

<SETG PROG-REP-GEN  %<RSUBR!- '[ %<PCODE!- "1NEWREP" 0> PROG-REP-GEN #DECL (
"VALUE" ANY NODE <OR ATOM DATUM>) FLUSH-RESIDUE ADDR:VALUE LADDR MESSAGE 
KILL-STORE SINACS ADDR:TYPE STOREV SMASH-INACS STACK:ARGUMENT UNIQUE:TAG EMIT 
DATUM GEN SUBR-GEN END-FRAME FIX-ACLINK LABEL:OFF ISTYPE? MOVE:ARG CHECK:VARS 
VAR-STORE BRANCH:TAG UNBIND:LOCS UNBIND:FUNNY POP:LOCS PROG:END RET-TMP-AC 
SEQ-GEN CALL-INTERRUPT LABEL:TAG SAVE:RES BIND-CODE BUILD:FRAME MAKE:TAG 
FUNCTION:VALUE ADD:STACK EMIT-PRE GOODACS BEGIN-FRAME REGSTO STACK:L PNOD (NODE)
 BSTB NTSLOTS (LIST) SPECD (ANY) START:TAG (ATOM) STB STK PRE TMPS BASEF FRMS 
AC-HACK (<PRIMTYPE LIST>) SPEC-LIST RPNOD %<RGLOC BIND T> TOT-SPEC FLUSHED (FIX)
 T %<RGLOC FRAMLN T> FRMID FUZZ GVAL "EXIT" %<RGLOC REPEAT T> "AGAIN" %<RGLOC 
NO-DATUM T> NPRUNE %<TYPE-C DATUM LIST> %<TYPE-C AC VECTOR> %<TYPE-W AC VECTOR> 
%<TYPE-W DATUM LIST> %<TYPE-W NODE VECTOR> %<RGLOC PROG T> %<TYPE-C NODE VECTOR>
 FCN (FUNNY-STACK) <`MOVE  `TB*  |OTBSAV  `(TB) > ATOM DONT-CARE <MCALL!-OP 1 GO
> %<TYPE-W OPCODE!-OP WORD> <`SUBI  `O*  `(M) > <`PUSH  `TP*  <TYPE-WORD!-OP FIX
>> <`PUSH  `TP*  0> <`PUSHJ  `P*  |MAKACT > <`PUSH  `TP*  `A > <`PUSH  `TP*  
`B > <MCALL!-OP 2 TAG> ANY-AC %<RGLOC ALLACS T> %<TYPE-W SYMTAB VECTOR> %<RGLOC 
POTLV T> TMP %<TYPE-C SYMTAB VECTOR> CODE:PTR RETURN-ST SCODE:PTR INCONSISTENCY 
"BAD ACLINK" CODE:TOP "VAR" KILL-LIST]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,PROG-REP-GEN PGLUE ![715827882 -22906492246 
-22906404865 -1 -1 -1 -67108864 0!]>> 


"" 

" Generate code for a RETURN." 

<SETG RETURN-GEN %<RSUBR-ENTRY '[PROG-REP-GEN RETURN-GEN #DECL ("VALUE" ANY NODE
<OR ATOM DATUM>)] 1097>> 

<SETG GO:BACK:FRAMES %<RSUBR-ENTRY '[PROG-REP-GEN GO:BACK:FRAMES #DECL ("VALUE" 
ATOM FIX)] 1494>> 

"" 

" Generate code for an AGAIN." 

<SETG AGAIN-GEN %<RSUBR-ENTRY '[PROG-REP-GEN AGAIN-GEN #DECL ("VALUE" ANY NODE 
ANY)] 1518>> 

" Generate code for a GO in a PROG/REPEAT." 

<SETG GO-GEN %<RSUBR-ENTRY '[PROG-REP-GEN GO-GEN #DECL ("VALUE" ANY NODE <OR 
ATOM DATUM>)] 1759>> 

<SETG TAG-GEN %<RSUBR-ENTRY '[PROG-REP-GEN TAG-GEN #DECL ("VALUE" ANY NODE ANY)]
1836>> 

" Update ACs with respect to their datums." 

<SETG ACFIX %<RSUBR-ENTRY '[PROG-REP-GEN ACFIX #DECL ("VALUE" ATOM ANY ANY)] 
1905>> 

" Generate code to flush stack for leaving a PROG etc." 

<SETG PROG:UNBIND %<RSUBR-ENTRY '[PROG-REP-GEN PROG:UNBIND #DECL ("VALUE" ANY)] 
1950>> 

"" 

"ROUTINES TO ALLOW KEEPING VARIABLES IN AC'S THRU LOOPS.  THE OUTINES KEEP INFORMATION
 IN THE PROG NODE TELLING INFORMATION AT VARIOUS POINTS (I.E. AGAIN AND RETURN POINTS).
 VARIABLES KEPT IN ACS WILL CONTAIN POINTERS TO THE PROG NODES INVOLVED AND THE DECISION
 WILL BE MADE TO KEEP THEM IN AC'S WHEN THEY ARE FIRST REFERENCED.  AGAINS AND RETURNS
 WILL EMIT NULL MACROS AND A FIXUP ROUTINE WILL BE USED AT THE END TO COERCE THE STATES
 CORRECTLY." 

"ROUTINE TO INITIALIZE STATE INFORMATION ON ENTERING LOOPS.  IT TAKES A PROG/REPEAT NODE
 AND WILL UPDATE INFORMATION CONTAING SLOTS AS WELL AS PUTTING THE NODE INTO PROG-AC
 SLOTS OF APPROPRIATE SYMTABS. THE SLOTS MAY CONTAIN MULTIPLE PROG NODES BUT THE ONE
 CURRENTLY BEING HACKED WILL BE FIRST.  IF FLUSHING A VAR THE ENTIRE SLOT WILL BE
 FLUSHED." 

"MANIFESTS FOR PROG-AC" 

<SETG PROG-SLOT 1> 

<SETG NUM-SYM-SLOT 2> 

<SETG STORED-SLOT 3> 

<SETG INACS-SLOT 4> 

"MANIFESTED VARIABLES FOR SLOT STORE IN PROG-VARS" 

<SETG SYM-SLOT 1> 

<SETG SAVED-NUM-SYM-SLOT 2> 

<SETG SAVED-PROG-AC-SLOT 3> 

<SETG SAVED-POTLV-SLOT 4> 

<SETG LENGTH-PROG-VARS 4> 

"MANIFESTS FOR AGAIN AND RETURN STATES" 

<SETG SAVED-AC-STATE 1> 

<SETG SAVED-CODE:PTR 2> 

<SETG SAVED-STACK-STATE 3> 

<SETG SAVED-RET-FLAG 4> 

<SETG LENGTH-CONTROL-STATE 4> 

"OFFSETS FOR STACK:INFO" 

<SETG SAVED-FRMS 1> 

<SETG SAVED-BSTB 2> 

<SETG SAVED-NTSLOTS 3> 

<SETG SAVED-STK 4> 

"SLOTS FOR SAVED-AC-SLOT" 

<SETG CSYMT-SLOT 1> 

<SETG CINACS-SLOT 2> 

<SETG CSTORED-SLOT 3> 

<SETG CPOTLV-SLOT 4> 

<SETG LENGTH-CSTATE 4> 

"SLOTS FOR LOOP-VARS" 

<SETG LSYM-SLOT 1> 

<SETG LINACS-SLOT 2> 

<SETG LOOPVARS-LENGTH 2> 

<MANIFEST NUM-SYM-SLOT LSYM-SLOT LOOPVARS-LENGTH LINACS-SLOT SAVED-FRMS 
CSYMT-SLOT CINACS-SLOT CSTORED-SLOT CPOTLV-SLOT LENGTH-CSTATE SAVED-BSTB 
SAVED-NTSLOTS SAVED-STK STORED-SLOT INACS-SLOT PROG-SLOT SYM-SLOT 
SAVED-NUM-SYM-SLOT SAVED-POTLV-SLOT SAVED-PROG-AC-SLOT LENGTH-PROG-VARS 
LENGTH-CONTROL-STATE SAVED-AC-STATE SAVED-CODE:PTR SAVED-STACK-STATE 
SAVED-RET-FLAG> 

<SETG PROG-START-AC %<RSUBR-ENTRY '[PROG-REP-GEN PROG-START-AC #DECL ("VALUE" 
ATOM NODE)] 1996>> 

<SETG CLEAN-AC %<RSUBR-ENTRY '[PROG-REP-GEN CLEAN-AC #DECL ("VALUE" <OR FALSE 
SYMTAB> AC)] 2209>> 

<SETG AGAIN-UP %<RSUBR-ENTRY '[PROG-REP-GEN AGAIN-UP #DECL ("VALUE" NODE NODE 
"OPTIONAL" <OR ATOM FALSE>)] 2470>> 

<SETG RETURN-UP %<RSUBR-ENTRY '[PROG-REP-GEN RETURN-UP #DECL ("VALUE" <OR FALSE 
NODE> NODE "OPTIONAL" LIST)] 2540>> 

<SETG STACK:INFO %<RSUBR-ENTRY '[PROG-REP-GEN STACK:INFO #DECL ("VALUE" <LIST 
ANY ANY ANY ANY>)] 2661>> 

"" 

"OK FOLKS HERE IT IS.  THIS IS THE ROUTINE THAT MERGES ALL THE STATES IN LOOPS
 AND DOES THE RIGHT THING IN ALL CASES (MAYBE?).  IT TAKES A PROG AND MAKES SURE
 THAT STATES ARE CONSISTENT AT AGAIN AND RETURN POINTS.  FOR AGAIN POINTS IT
 MAKES SURE THAT ALL LOOP VARIABLES IN THE RIGHT ACS." 

<SETG CLEANUP-STATE %<RSUBR-ENTRY '[PROG-REP-GEN CLEANUP-STATE #DECL ("VALUE" <
OR ATOM FALSE> NODE)] 2686>> 

<SETG LOOP-REPEAT %<RSUBR-ENTRY '[PROG-REP-GEN LOOP-REPEAT #DECL ("VALUE" ATOM 
ANY ANY)] 2742>> 

<SETG LOOP-RESTORE %<RSUBR-ENTRY '[PROG-REP-GEN LOOP-RESTORE #DECL ("VALUE" ATOM
<PRIMTYPE LIST> <PRIMTYPE LIST> REP-STATE <PRIMTYPE LIST> <OR ATOM FALSE>)] 2863
>> 

<SETG MOVE-AROUND-ACS %<RSUBR-ENTRY '[PROG-REP-GEN MOVE-AROUND-ACS #DECL (
"VALUE" ATOM LIST REP-STATE <OR ATOM FALSE>)] 2955>> 

<SETG ONE-EXCH-AC %<RSUBR-ENTRY '[PROG-REP-GEN ONE-EXCH-AC #DECL ("VALUE" <LIST 
[5 LIST]> <DATUM ANY AC> <DATUM ANY AC> REP-STATE ANY ANY ANY)] 3086>> 

<SETG TWO-AC-EXCH %<RSUBR-ENTRY '[PROG-REP-GEN TWO-AC-EXCH #DECL ("VALUE" <OR 
ATOM LIST> DATUM DATUM REP-STATE ANY ANY ANY)] 3187>> 

"" 

<SETG CURRENT-AC-STATE %<RSUBR-ENTRY '[PROG-REP-GEN CURRENT-AC-STATE #DECL (
"VALUE" <LIST [5 <LIST [REST SYMTAB DATUM <OR FALSE ATOM> <OR ATOM FALSE>]>] [
REST LIST]> "OPTIONAL" ANY)] 3557>> 

<SETG KILL-LOOP-AC %<RSUBR-ENTRY '[PROG-REP-GEN KILL-LOOP-AC #DECL ("VALUE" <OR 
FALSE SYMTAB> ANY)] 3756>> 

<SETG LVAL-UP %<RSUBR-ENTRY '[PROG-REP-GEN LVAL-UP #DECL ("VALUE" <OR ATOM FALSE
SYMTAB> SYMTAB "OPTIONAL" ANY)] 3801>> 

"" 

<SETG STORE-SAVED-ACS %<RSUBR-ENTRY '[PROG-REP-GEN STORE-SAVED-ACS #DECL (
"VALUE" <OR ATOM FALSE> LIST REP-STATE)] 3980>> 

<SETG AC? %<RSUBR-ENTRY '[PROG-REP-GEN AC? #DECL ("VALUE" ANY SYMTAB LIST)] 4122
>> 

"THIS ROUTINE SWAPS PORTIONS OF DATUMS.  IT TAKES TWO ACS AND THE ACS LIST AND SWAPS THE
 INFORMATION IN THE ACS LIST. AC2 IS THE GOAL AC AND ENDS UP CONTAINING ONLY ONE DATUM." 

<SETG SWAP-INAC %<RSUBR-ENTRY '[PROG-REP-GEN SWAP-INAC #DECL ("VALUE" <LIST [5 
LIST]> AC AC REP-STATE ANY <OR ATOM FALSE> ANY LIST)] 4205>> 

<SETG SWAP-DATUMS %<RSUBR-ENTRY '[PROG-REP-GEN SWAP-DATUMS #DECL ("VALUE" ANY <
OR FALSE <LIST [REST DATUM]>> ANY ANY)] 4570>> 

<SETG GET-ACS-FROM-STACK %<RSUBR-ENTRY '[PROG-REP-GEN GET-ACS-FROM-STACK #DECL (
"VALUE" ATOM LIST REP-STATE)] 4653>> 

"" 

<SETG NON-LOOP-CLEANUP %<RSUBR-ENTRY '[PROG-REP-GEN NON-LOOP-CLEANUP #DECL (
"VALUE" <OR FALSE SYMTAB> NODE)] 4884>> 

"ROUTINES TO HANDLE LOOP-RETURNS." 

<SETG LOOP-RETURN %<RSUBR-ENTRY '[PROG-REP-GEN LOOP-RETURN #DECL ("VALUE" <OR 
ATOM FALSE> LIST)] 4975>> 

"ROUTINE TO FIGURE OUT A MERGE BETWEEN DIFFERENT RETURN POINTS.  IN THE END A LIST OF
 THINGS TO REMAIN IN AC'S ARE PRODUCED." 

<SETG MERGE-RETURNS %<RSUBR-ENTRY '[PROG-REP-GEN MERGE-RETURNS #DECL ("VALUE" 
LIST <LIST [REST REP-STATE <PRIMTYPE LIST> LIST <OR ATOM FALSE>]>)] 5105>> 

"ROUTINE TO FIGURE OUT IF THINGS MERGE" 

<SETG MERG-IT %<RSUBR-ENTRY '[PROG-REP-GEN MERG-IT #DECL ("VALUE" LIST LIST LIST
)] 5204>> 

<SETG MERGE-SINGLE-RETURN %<RSUBR-ENTRY '[PROG-REP-GEN MERGE-SINGLE-RETURN #DECL
("VALUE" <OR ATOM FALSE> LIST LIST LIST LIST)] 5522>> 

<SETG SPEC-STOREV %<RSUBR-ENTRY '[PROG-REP-GEN SPEC-STOREV #DECL ("VALUE" ANY 
ANY ANY ANY)] 5796>> 

<SETG CLEANUP-SYMT %<RSUBR-ENTRY '[PROG-REP-GEN CLEANUP-SYMT #DECL ("VALUE" 
SYMTAB SYMTAB)] 5900>> 

<SETG SEMIT %<RSUBR-ENTRY '[PROG-REP-GEN SEMIT #DECL ("VALUE" LIST ANY)] 5920>> 

"" 

<SETG FLUSH-SYMTAB-FROM-AC %<RSUBR-ENTRY '[PROG-REP-GEN FLUSH-SYMTAB-FROM-AC #
DECL ("VALUE" ANY ANY)] 5973>> 

<SETG SMASH-ITEM-INTO-DATUM %<RSUBR-ENTRY '[PROG-REP-GEN SMASH-ITEM-INTO-DATUM #
DECL ("VALUE" ANY SYMBOL DATUM)] 6023>> 

<SETG GET-NUM-SYM %<RSUBR-ENTRY '[PROG-REP-GEN GET-NUM-SYM #DECL ("VALUE" ANY 
ANY)] 6103>> 

<SETG SMASH-NUM-SYM %<RSUBR-ENTRY '[PROG-REP-GEN SMASH-NUM-SYM #DECL ("VALUE" 
SYMTAB SYMTAB)] 6165>> 

<SETG CLEANUP-VARS %<RSUBR-ENTRY '[PROG-REP-GEN CLEANUP-VARS #DECL ("VALUE" ATOM
LIST)] 6184>> 

<SETG FIXUP-STORES %<RSUBR-ENTRY '[PROG-REP-GEN FIXUP-STORES #DECL ("VALUE" ATOM
<LIST [REST REP-STATE <PRIMTYPE LIST> LIST <OR ATOM FALSE>]>)] 6276>> 

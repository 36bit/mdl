'<PCODE "CODGEN">

<SETG FUDGE <>> 

"	This file contains the major general codde generators.  These include
 variable access functions (LVAL, SETG etc.), FSUBRs (COND, AND, REPEAT)
 and a few assorted others." 

"	All generators are called with a node and a destination for the 
 result.  The destinations are either DATUMs (lists of ACs or types)
 or the special atoms DONT-CARE or FLUSHED.  Generators for
 SUBRs that can be predicates may have additional arguments when they
 are being invoked for their branching effect." 

"	The atom STK always points to a list that specifies the model
 of the TP stack." 

" Main generator, dispatches to specific code generators. " 

<SETG OTBSAV <PROG (TEM) <COND (<AND <SET TEM <LOOKUP "OTBSAV" <GET MUDDLE 
OBLIST>>> <GASSIGNED? .TEM>> ,.TEM) (ELSE <SQUOTA |OTBSAV >)>>> 

<GDECL (OTBSAV) FIX> 

<SETG GEN  %<RSUBR!- '[ %<PCODE!- "CODGEN" 0> GEN #DECL ("VALUE" ANY NODE <OR 
ATOM DATUM>) TIME:CHECK TIME:STACK POP:LOCS SGETREG FAST:SETG FAST:GVAL FREE-ACS
 OFFPTR SPEC-OFFPTR SPEC:REFERENCE:STACK FIX:ADDR STORE-VAR STORE-TVAR 
GET-NUM-SYM SINACS FLUSH-COMMON-SYMT KILL-LOOP-AC FLUSH-RESIDUE ARG? MUNG-AC 
FAST:SET FAST:VAL LVAL-UP TRUE-FALSE ADDR:TYPE REG? MERGE-STATE CHECK:VARS 
SAVE-STATE FIX-NUM-SYM TYPE-OK? RESTORE-STATE SAVE-NUM-SYM PREFER-DATUM SAVE:RES
 COUNTP PRED:BRANCH:GEN PCOUNTER INTERNAL-RSUBR DATTYP-FLUSH GEN:FALSE D:B:TAG 
SEGMENT:FINAL SEGMENT:STACK SEGMENT:LIST SUBR:CALL TUPLE:FINAL BUMP:CNTR 
REFERENCE:ARGPNTR TEST:ARGPNTR BUMP:ARGPNTR COPY:ARGPNTR GOOD-TUPLE ADDRESS:PAIR
 SMASH-INACS CREATE-TMP ISTYPE-GOOD? MAKE:ACT REFERENCE REFERENCE:STACK TEST:ARG
 PUSH:ATB PUSH:PAIR STORE:PAIR STORE:BIND REFERENCE:ARG MAKE:ENV STACK:ARGUMENT 
ACT:FINAL EMIT-PRE BRANCH:TAG REFERENCE:UNBOUND BIND:END PUSH:BIND ADDRESS:C 
ALLOC:SLOTS SALLOC:SLOTS ACT:INITIAL END-FRAME MOVE:ARG FIX-ACLINK UNBIND:LOCS 
ISTYPE? ACFIX EMIT BEGIN-FRAME MAKE:TAG FUNCTION:VALUE VAR-STORE RET-TMP-AC 
DATUM LABEL:TAG UNIQUE:TAG REGSTO MESSAGE ISTAG? %<RGLOC GENERATORS T> %<TYPE-W 
NODE VECTOR> NPRUNE ATOM WARNING " TAG SEEN IN PROG/REPEAT " T %<TYPE-C DATUM 
LIST> FLUSHED BASEF (NODE) TOT-SPEC (FIX) NTSLOTS GVAL (LIST) IDT STK PRE (ANY) 
FRMID FRMS BSTB SPECD TMPS START:TAG (ATOM) AC-HACK (<PRIMTYPE LIST>) "AGAIN" 
"EXIT" SPEC-LIST NO-KILL KILL-LIST <INTGO!-OP> %<RGLOC NO-DATUM T> %<TYPE-C AC 
VECTOR> (FUNNY-STACK) %<RGLOC ALLACS T> %<TYPE-W AC VECTOR> %<TYPE-C SYMTAB 
VECTOR> NSLOTS ![(STACK) (FUNNY-STACK)!] INTERNAL-ENTRY!-OP <`SUBM  `M*  
`(P) > PSTACK %<TYPE-W SYMTAB VECTOR> %<RGLOC POTLV T> %<TYPE-W OPCODE!-OP WORD>
 - ![0 0 0 0 1 0 0 0 0 1 0 1 1!] %<RGLOC BINDERS T> FUDGE %<RGLOC SNODES T> 
DONT-CARE DATUM %<TYPE-W DATUM LIST> %<TYPE-C TEMPV LIST> FCN %<TYPE-W TEMPV 
LIST> ANY-AC TYPE-WORD!-OP [0] %<TYPE-C NODE VECTOR> ITUPLE TUPLE <`PUSH  
`P*  `A > <`PUSHJ  `P*  |MAKTU2 > <`POP  `TP*  `B > <`POP  `TP*  `A > <`MOVE  
`B*  `AB > <`HLRZ  `A*  |OTBSAV  `(TB) > <`HRLI  `A*  <TYPE-CODE!-OP TUPLE>> FIX
 INTH %<RGLOC NTH T> ERROR " NON APPLICABLE OBJECT " EVAL %<RGLOC COPIERS T> [
|IILIST  |CIVEC  |CIUVEC  TUPLE] LIST %<TYPE-W MUDREF!-OP WORD> %<RGLOC SUBRS T>
 %<RGLOC TEMPLATES T> (ANY ANY) STACK <`SKIPA > %<RGLOC AC-A T> %<RGLOC AC-B T> 
<`POP  `P*  `A > %<RGLOC RET-TMP-AC T> ALL "BAD ARG TO " IND GROUP-NAME (STACK) 
%<TYPE-W IRSUBR LIST> ![!] <`MOVE  `A*  `AB > [<2 (2)>] <`HLRES  `A > <`ASH  
`A*  -1> <`MOVMS  `A > <`JRST  |FINIS > CAREFUL <`JRST  |COMPER > MQUOTE!-OP <
`HRLI  `A*  131072> APPLY %<TYPE-W SAVED-STATE LIST> "COND" %<RGLOC FUDGE T> 
FALSE "NON REACHABLE COND CLAUSE(S) " "PHRASE" "COND PREDICATE ALWAYS FALSE" 
NO-RETURN "NON REACHABLE COND CLAUSE(S)" <NOT FALSE> NOTE "BOOL" ANY 
"NON REACHABLE AND/OR CLAUSE" GETYP!-OP <TYPE-CODE!-OP UNBOUND> %<RGLOC DEATH T>
 STORE-SET PSLOT INCONSISTENCY "BAD CALL TO ADD:STACK " (-2) FUZZ %<RGLOC OTBSAV
T> VECTOR INCONSISTANCY "BAD FRAME MODEL " (0) "BAD VARIABLE ADDRESS " %<RGLOC 
USE-RGLOC T> GLUE LOCR TYPE-CODE!-OP %<RGLOC AC-C T> %<RGLOC AC-E T> <`PUSHJ  
`P*  |POPUNW > <`JRST  |UNWIN2 > ![READCHR NEXTCHR!] READCHR <`CAIA > %<RGLOC 
GETTERS T> %<RGLOC AC-D T> ![|CIGETP  |CIGTPR  |CIGETL  |CIGET !] <`JFCL >]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,GEN PGLUE ![715827882 -22906492246 
-22906492246 -22906492246 -22906492246 -22906404865 -1 -1 -1 -1 -1 -1 -1 -1 
-17179869184 0!]>> 


" Generate a sequence of nodes flushing all values except the ladt." 

<SETG SEQ-GEN %<RSUBR-ENTRY '[GEN SEQ-GEN #DECL ("VALUE" <OR ATOM DATUM> <LIST [
REST NODE]> <OR ATOM DATUM> "OPTIONAL" ANY ANY ANY)] 43>> 

" The main code generation entry (called from CDRIVE).  Sets up initial
 stack model, calls to generate code for the bindings and generates code for
 the function's body." 

<SETG CODE-GEN %<RSUBR-ENTRY '[GEN CODE-GEN #DECL ("VALUE" ANY NODE)] 219>> 

" Generate code for setting up and binding agruments." 

<SETG BIND-CODE %<RSUBR-ENTRY '[GEN BIND-CODE #DECL ("VALUE" ANY NODE "OPTIONAL"
ANY)] 745>> 

<SETG OPT-CHECK %<RSUBR-ENTRY '[GEN OPT-CHECK #DECL ("VALUE" <OR ATOM FALSE> <
LIST [REST SYMTAB]> FIX <UVECTOR [REST ATOM]>)] 1555>> 

" Generate \"BIND\" binding code." 

<SETG BIND-B %<RSUBR-ENTRY '[GEN BIND-B #DECL ("VALUE" ANY SYMTAB)] 1735>> 

" Do code generation for normal  arguments." 

<SETG NORM-B %<RSUBR-ENTRY '[GEN NORM-B #DECL ("VALUE" ANY SYMTAB)] 1751>> 

" Initialized optional argument binder." 

<SETG OPT1-B %<RSUBR-ENTRY '[GEN OPT1-B #DECL ("VALUE" ANY SYMTAB)] 1815>> 

" Uninitialized optional argument binder." 

<SETG OPT2-B %<RSUBR-ENTRY '[GEN OPT2-B #DECL ("VALUE" ANY SYMTAB)] 1835>> 

" Create a binding either by pushing or moving if slots PRE created." 

<SETG BINDUP %<RSUBR-ENTRY '[GEN BINDUP #DECL ("VALUE" ANY SYMTAB DATUM 
"OPTIONAL" ANY)] 1848>> 

" Push or store a non special argument." 

<SETG CLOB:PAIR %<RSUBR-ENTRY '[GEN CLOB:PAIR #DECL ("VALUE" ANY SYMTAB ANY 
DATUM)] 1951>> 

" Create a binding for either intitialized or unitialized optional." 

<SETG OPTBIND %<RSUBR-ENTRY '[GEN OPTBIND #DECL ("VALUE" ANY SYMTAB "OPTIONAL" 
NODE)] 1994>> 

" Do a binding for a named activation." 

<SETG ACT-B %<RSUBR-ENTRY '[GEN ACT-B #DECL ("VALUE" ANY SYMTAB)] 2205>> 

" Bind an \"AUX\" variable." 

<SETG AUX1-B %<RSUBR-ENTRY '[GEN AUX1-B #DECL ("VALUE" ANY SYMTAB)] 2224>> 

" Do a binding for an uninitialized \"AUX\" " 

<SETG AUX2-B %<RSUBR-ENTRY '[GEN AUX2-B #DECL ("VALUE" ANY SYMTAB)] 2461>> 

<SETG TUPCHK %<RSUBR-ENTRY '[GEN TUPCHK #DECL ("VALUE" ANY <OR FALSE NODE> 
"OPTIONAL" ANY)] 2611>> 

" Do a \"TUPLE\" binding." 

<SETG TUPLE1-B %<RSUBR-ENTRY '[GEN TUPLE1-B #DECL ("VALUE" ANY SYMTAB)] 2716>> 

<SETG TUPL-B %<RSUBR-ENTRY '[GEN TUPL-B #DECL ("VALUE" ANY SYMTAB)] 2750>> 

" Generate the code to actually build a TUPLE." 

<SETG BUILD:TUPLE %<RSUBR-ENTRY '[GEN BUILD:TUPLE #DECL ("VALUE" ANY FIX)] 2812>
> 

" Dispatch table for binding generation code." 

<SETG BINDERS ![,ACT-B ,AUX1-B ,AUX2-B ,TUPL-B ,NORM-B ,OPT1-B ,OPT1-B ,OPT2-B ,
OPT2-B ,NORM-B ,BIND-B ,NORM-B ,NORM-B!]> 

<COND (<GASSIGNED? NOTIMP> <SETG MBINDERS [,ACT-B ,AUX1-B ,AUX2-B ,NOTIMP ,
MENTROPY ,MOPTG ,MOPTG ,MOPTG2 ,MOPTG2 ,MENTROPY ,BIND-B ,MENTROPY ,MENTROPY]>)> 

" Appliacation of a form could still be an NTH." 

<SETG FORM-F-GEN %<RSUBR-ENTRY '[GEN FORM-F-GEN #DECL ("VALUE" ANY NODE ANY)] 
2855>> 

" Generate a call to EVAL for uncompilable FORM." 

<SETG FORM-GEN %<RSUBR-ENTRY '[GEN FORM-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 2972>> 

" Generate code for LIST/VECTOR etc. evaluation." 

<GDECL (COPIERS) <UVECTOR [REST ATOM]>> 

<SETG COPY-GEN %<RSUBR-ENTRY '[GEN COPY-GEN #DECL ("VALUE" DATUM NODE <OR ATOM 
DATUM>)] 3043>> 

<SETG COPIERS ![TUPLE UVECTOR VECTOR LIST!]> 

"Generate code for a call to a SUBR." 

<SETG SUBR-GEN %<RSUBR-ENTRY '[GEN SUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 3362>> 

" Compile call to a SUBR that doesn't compile or PUSHJ." 

<SETG COMP:SUBR:CALL %<RSUBR-ENTRY '[GEN COMP:SUBR:CALL #DECL ("VALUE" ANY ANY <
LIST [REST NODE]> FIX ANY)] 3384>> 

<GDECL (SUBRS TEMPLATES) UVECTOR> 

<SETG GET-TMPS %<RSUBR-ENTRY '[GEN GET-TMPS #DECL ("VALUE" <LIST [2 ANY]> ANY)] 
3530>> 

" Generate calls to SUBRs using the internal PUSHJ feature." 

<SETG ISUBR-GEN %<RSUBR-ENTRY '[GEN ISUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> "OPTIONAL" ANY ANY ANY)] 3573>> 

<SETG STACK-ARGS %<RSUBR-ENTRY '[GEN STACK-ARGS #DECL ("VALUE" <OR FALSE FIX> 
NODE ANY)] 3974>> 

" Get a bunch of goodies into ACs for a PUSHJ call." 

<SETG AC-ARGS %<RSUBR-ENTRY '[GEN AC-ARGS #DECL ("VALUE" <OR ATOM FALSE FIX> 
NODE LIST)] 4091>> 

<SETG SIDES %<RSUBR-ENTRY '[GEN SIDES #DECL ("VALUE" <OR ATOM FALSE> <LIST [REST
NODE]>)] 4327>> 

" Generate code for a call to an RSUBR (maybe PUSHJ)." 

<SETG RSUBR-GEN %<RSUBR-ENTRY '[GEN RSUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 4391>> 

" Generate a call to an internal compiled goodies using a PUSHJ." 

<SETG IRSUBR-GEN %<RSUBR-ENTRY '[GEN IRSUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM
DATUM>)] 4613>> 

" Get the arguemnts to a FUNCTION into the ACs." 

<SETG ARGS-TO-ACS %<RSUBR-ENTRY '[GEN ARGS-TO-ACS #DECL ("VALUE" ANY NODE)] 4699
>> 

" Push the args supplied in ACs onto the stack." 

<SETG ACS-TO-STACK %<RSUBR-ENTRY '[GEN ACS-TO-STACK #DECL ("VALUE" FIX LIST)] 
4979>> 

<SETG AC-SEG-CALL %<RSUBR-ENTRY '[GEN AC-SEG-CALL #DECL ("VALUE" ANY LIST)] 5031
>> 

" Generate PUSHJ in stack arg case (may go different places)" 

<SETG STACK-CALL %<RSUBR-ENTRY '[GEN STACK-CALL #DECL ("VALUE" ANY FIX FIX <
UVECTOR [REST ATOM]> <OR FIX FALSE> <OR ATOM FALSE>)] 5163>> 

" Generate code for a stackform." 

<SETG STACKFORM-GEN %<RSUBR-ENTRY '[GEN STACKFORM-GEN #DECL ("VALUE" ANY NODE <
OR ATOM DATUM>)] 5479>> 

" Generate code for a COND." 

<SETG COND-GEN %<RSUBR-ENTRY '[GEN COND-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> "OPTIONAL" ANY ANY ANY)] 5664>> 

<SETG PSEQ-GEN %<RSUBR-ENTRY '[GEN PSEQ-GEN #DECL ("VALUE" ANY <LIST [REST NODE]
> ANY ANY ANY ANY)] 6844>> 

<SETG COND-COMPLAIN %<RSUBR-ENTRY '[GEN COND-COMPLAIN #DECL ("VALUE" ANY ANY 
NODE)] 6903>> 

<SETG SAVE-TYP %<RSUBR-ENTRY '[GEN SAVE-TYP #DECL ("VALUE" <OR ATOM FALSE> NODE)
] 6922>> 

<SETG MERGE-STATES %<RSUBR-ENTRY '[GEN MERGE-STATES #DECL ("VALUE" ANY ANY)] 
6941>> 

" Fixup where its going better or something?" 

<SETG UPDATE-WHERE %<RSUBR-ENTRY '[GEN UPDATE-WHERE #DECL ("VALUE" <OR ATOM 
DATUM> NODE <OR ATOM DATUM>)] 7063>> 

" Generate code for OR use BOOL-GEN to do work." 

<SETG OR-GEN %<RSUBR-ENTRY '[GEN OR-GEN #DECL ("VALUE" ANY NODE ANY "OPTIONAL" 
ANY ANY ANY)] 7113>> 

" Generate code for AND use BOOL-GEN to do work." 

<SETG AND-GEN %<RSUBR-ENTRY '[GEN AND-GEN #DECL ("VALUE" ANY NODE ANY "OPTIONAL"
ANY ANY ANY)] 7175>> 

<SETG BOOL-GEN %<RSUBR-ENTRY '[GEN BOOL-GEN #DECL ("VALUE" ANY NODE <LIST [REST 
NODE]> ANY <OR DATUM ATOM> ANY <OR ATOM FALSE> ANY)] 7236>> 

" Get the best set of acs around for this guy." 

<SETG GOODACS %<RSUBR-ENTRY '[GEN GOODACS #DECL ("VALUE" <OR ATOM DATUM> NODE 
ANY)] 7951>> 

" Generate code for ASSIGNED?" 

<SETG ASSIGNED?-GEN %<RSUBR-ENTRY '[GEN ASSIGNED?-GEN #DECL ("VALUE" ANY NODE 
ANY "OPTIONAL" ANY ANY ANY)] 8035>> 

" Generate code for LVAL." 

<SETG LVAL-GEN %<RSUBR-ENTRY '[GEN LVAL-GEN #DECL ("VALUE" <OR DATUM FALSE> NODE
ANY)] 8232>> 

<SETG DELAY-KILL %<RSUBR-ENTRY '[GEN DELAY-KILL #DECL ("VALUE" ATOM LIST LIST)] 
8565>> 

<SETG RES-FLS %<RSUBR-ENTRY '[GEN RES-FLS #DECL ("VALUE" <OR FALSE <LIST <OR 
COMMON SYMTAB TEMP> [REST <OR TEMP SYMTAB COMMON>]>> <LIST [REST <OR TEMP SYMTAB
COMMON>]> SYMBOL)] 8696>> 

" Generate LVAL for free variable." 

<SETG FLVAL-GEN %<RSUBR-ENTRY '[GEN FLVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 8754
>> 

<SETG FSET-GEN %<RSUBR-ENTRY '[GEN FSET-GEN #DECL ("VALUE" ANY NODE ANY)] 8825>> 

" Generate code for an internal SET." 

<SETG SET-GEN %<RSUBR-ENTRY '[GEN SET-GEN #DECL ("VALUE" ANY NODE ANY)] 8908>> 

<SETG STOREV %<RSUBR-ENTRY '[GEN STOREV #DECL ("VALUE" ANY <OR TEMP SYMTAB 
COMMON> "OPTIONAL" ANY)] 9368>> 

" Update the stack model with a FIX or an ATOM." 

<SETG ADD:STACK %<RSUBR-ENTRY '[GEN ADD:STACK #DECL ("VALUE" ANY ANY)] 9520>> 

" Return the current distance between two stack places." 

<SETG STACK:L %<RSUBR-ENTRY '[GEN STACK:L #DECL ("VALUE" <OR FALSE <LIST FIX>> 
LIST LIST)] 9604>> 

" Compute the address of a local variable using the stack model." 

<SETG LOCAL-ADDR %<RSUBR-ENTRY '[GEN LOCAL-ADDR #DECL ("VALUE" DATUM NODE ANY)] 
9680>> 

<SETG LADDR %<RSUBR-ENTRY '[GEN LADDR #DECL ("VALUE" DATUM SYMTAB ANY ANY 
"OPTIONAL" ANY)] 9704>> 

<SETG STFIXIT %<RSUBR-ENTRY '[GEN STFIXIT #DECL ("VALUE" <LIST FIX LIST> <LIST 
FIX LIST> LIST)] 10555>> 

" Generate obscure stuff." 

<SETG DEFAULT-GEN %<RSUBR-ENTRY '[GEN DEFAULT-GEN #DECL ("VALUE" ANY NODE ANY)] 
10644>> 

" Do GVAL using direct locative reference." 

<SETG GVAL-GEN %<RSUBR-ENTRY '[GEN GVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 10665>
> 

" Do SETG using direct locative reference." 

<SETG SETG-GEN %<RSUBR-ENTRY '[GEN SETG-GEN #DECL ("VALUE" ANY NODE ANY)] 10718>
> 

<BLOCK (<ROOT>)> 

RGLOC 

<ENDBLOCK> 

<SETG GLOC? %<RSUBR-ENTRY '[GEN GLOC? #DECL ("VALUE" ANY ANY)] 10863>> 

<SETG USE-RGLOC T> 

" Generate GVAL calls." 

<SETG FGVAL-GEN %<RSUBR-ENTRY '[GEN FGVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 
10949>> 

" Generate a SETG call." 

<SETG FSETG-GEN %<RSUBR-ENTRY '[GEN FSETG-GEN #DECL ("VALUE" ANY NODE ANY)] 
10991>> 

<SETG CHTYPE-GEN %<RSUBR-ENTRY '[GEN CHTYPE-GEN #DECL ("VALUE" ANY NODE ANY)] 
11077>> 

" Generate do-nothing piece of code." 

<SETG ID-GEN %<RSUBR-ENTRY '[GEN ID-GEN #DECL ("VALUE" ANY NODE ANY)] 11304>> 

<SETG UNWIND-GEN %<RSUBR-ENTRY '[GEN UNWIND-GEN #DECL ("VALUE" ANY NODE ANY)] 
11324>> 

" Generate call to READ etc. with eof condition." 

<SETG READ2-GEN %<RSUBR-ENTRY '[GEN READ2-GEN #DECL ("VALUE" ANY NODE ANY)] 
11504>> 

<SETG GET-GEN %<RSUBR-ENTRY '[GEN GET-GEN #DECL ("VALUE" ANY ANY ANY)] 11724>> 

<SETG GET2-GEN %<RSUBR-ENTRY '[GEN GET2-GEN #DECL ("VALUE" ANY ANY ANY)] 11743>> 

<GDECL (GETTERS) UVECTOR> 

<SETG GETGET %<RSUBR-ENTRY '[GEN GETGET #DECL ("VALUE" ANY NODE ANY ANY)] 11763>
> 

<SETG GETTERS ![,GET ,GETL ,GETPROP ,GETPL!]> 

<SETG GENERATORS <DISPATCH ,DEFAULT-GEN (,FORM-CODE ,FORM-GEN) (,PROG-CODE ,
PROG-REP-GEN) (,SUBR-CODE ,SUBR-GEN) (,COND-CODE ,COND-GEN) (,LVAL-CODE ,
LVAL-GEN) (,SET-CODE ,SET-GEN) (,OR-CODE ,OR-GEN) (,AND-CODE ,AND-GEN) (,
RETURN-CODE ,RETURN-GEN) (,COPY-CODE ,COPY-GEN) (,AGAIN-CODE ,AGAIN-GEN) (,
GO-CODE ,GO-GEN) (,ARITH-CODE ,ARITH-GEN) (,RSUBR-CODE ,RSUBR-GEN) (,0-TST-CODE 
,0-TEST) (,NOT-CODE ,NOT-GEN) (,1?-CODE ,1?-GEN) (,TEST-CODE ,TEST-GEN) (,
EQ-CODE ,==-GEN) (,TY?-CODE ,TYPE?-GEN) (,LNTH-CODE ,LNTH-GEN) (,MT-CODE ,MT-GEN
) (,REST-CODE ,REST-GEN) (,NTH-CODE ,NTH-GEN) (,PUT-CODE ,PUT-GEN) (,PUTR-CODE ,
PUTREST-GEN) (,FLVAL-CODE ,FLVAL-GEN) (,FSET-CODE ,FSET-GEN) (,FGVAL-CODE ,
FGVAL-GEN) (,FSETG-CODE ,FSETG-GEN) (,STACKFORM-CODE ,STACKFORM-GEN) (,
MIN-MAX-CODE ,MIN-MAX) (,CHTYPE-CODE ,CHTYPE-GEN) (,FIX-CODE ,FIX-GEN) (,
FLOAT-CODE ,FLOAT-GEN) (,ABS-CODE ,ABS-GEN) (,MOD-CODE ,MOD-GEN) (,ID-CODE ,
ID-GEN) (,ASSIGNED?-CODE ,ASSIGNED?-GEN) (,ISTRUC-CODE ,ISTRUC-GEN) (,
ISTRUC2-CODE ,ISTRUC-GEN) (,BITS-CODE ,BITS-GEN) (,GETBITS-CODE ,GETBITS-GEN) (,
BITL-CODE ,BITLOG-GEN) (,PUTBITS-CODE ,PUTBITS-GEN) (,ISUBR-CODE ,ISUBR-GEN) (,
EOF-CODE ,ID-GEN) (,READ-EOF2-CODE ,READ2-GEN) (,READ-EOF-CODE ,SUBR-GEN) (,
IPUT-CODE ,IPUT-GEN) (,IREMAS-CODE ,IREMAS-GEN) (,GET-CODE ,GET-GEN) (,GET2-CODE
,GET2-GEN) (,IRSUBR-CODE ,IRSUBR-GEN) (,MAP-CODE ,MAPFR-GEN) (,MARGS-CODE ,
MPARGS-GEN) (,MAPLEAVE-CODE ,MAPLEAVE-GEN) (,MAPRET-STOP-CODE ,MAPRET-STOP-GEN) 
(,UNWIND-CODE ,UNWIND-GEN) (,GVAL-CODE ,GVAL-GEN) (,SETG-CODE ,SETG-GEN) (,
TAG-CODE ,TAG-GEN) (,PRINT-CODE ,PRINT-GEN) (,MEMQ-CODE ,MEMQ-GEN) (,
LENGTH?-CODE ,LENGTH?-GEN) (,FORM-F-CODE ,FORM-F-GEN) (,INFO-CODE ,INFO-GEN) (,
OBLIST?-CODE ,OBLIST?-GEN) (,AS-NXT-CODE ,AS-NXT-GEN) (,AS-IT-IND-VAL-CODE ,
ASSOC-FIELD-GET) (,ALL-REST-CODE ,ALL-REST-GEN) (,ROT-CODE ,ROT-GEN) (,LSH-CODE 
,LSH-GEN) (,BIT-TEST-CODE ,BIT-TEST-GEN) (,CASE-CODE ,CASE-GEN)>> 

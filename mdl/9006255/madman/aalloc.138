;"(c) Copyright 1978 Massachusetts Institute of Technology.  All Rights Reserved."

<SETG PGWRITE-FLAG!-ASYLUM!-PACKAGE T>

%%<PROG (C)
	<SETG 10X <SETG 20X <>>>
	<CRLF ,OUTCHAN>
	<PRINC "Is this assembly for Tenex? ">
	<COND (<MEMQ <TYI ,INCHAN> "YyTt">
	       <SETG 10X T>
		<PRINC "TOPS-20 flavor of TENEX? ">
		<COND	(<MEMQ <TYI ,INCHAN> "YyTt">
			<SETG 20X T>)>)>
	<CRLF ,OUTCHAN>
	<AND ,10X <USE "JSYS"> <CRLF ,OUTCHAN>>>

%%<DEFINE IFN10X (10X ITS) <COND (,10X .10X) (.ITS)>>
%%<DEFINE IFN20X (20X 10X ITS) <COND (,20X .20X) (,10X .10X) (.ITS)>>

<OR <GASSIGNED? NOFFSET>
    <DEFINE NOFFSET (VAR) <- <* <VALUE .VAR> 2> 1>>>


; "BIT DEFINITIONS FOR CALLS TO DATALLOC"

%%<SETG PAGBIT *400000*>
%%<SETG LOKBIT *200000*>
%%<SETG MFDBIT *40000*>
%%<SETG DIRBIT *20000*>
%%<SETG RNDBIT *10000*>

<SETG DIRID 4>

<SETG PLH <* ,P/L 1024>>

<SETG DATA-EXTEND-PAGES 20>

; "Storage allocator.  
   Takes the ASYLUM and number of words required"


<TITLE DATALLOC>
	<DECLARE ("VALUE" <OR FIX FALSE> ASYLUM FIX)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* DATA1>
	<JRST	FINIS>

<INTERNAL-ENTRY DATA1 2>
	<SUBM	M* (P)>
	<MOVE	A* -2(TP)>	; "THE ASYLUM"
	<MOVE	B* <NOFFSET MFDPAGE> (A)>
	<LSH	B* 10>		; "ADDRESS OF MFD PAGE"
	<PUSH	P* B>
	<MOVE	C* (TP)>
	<TLNE	C* LOKBIT>	; "CHECK FOR ALREADY LOCKED"
	<JRST	XAGAIN>
XXAGAIN	<ADDI	B* ALLOCLOCK>
	<PUSH	TP* <TYPE-WORD WORD>>
	<PUSH	TP* B>
	<MCALL	1 DHLOCK>	; "HARD LOCK THE ALLOCATOR"
	<GETYP	B* A>
	<CAIN	B* <TYPE-CODE FALSE>>
	<JRST	ALLOSE>		; "SORRY. ALREADY LOCKED"
XAGAIN	<MOVE	A* -2(TP)>
	<SKIPGE	(TP)>
	<JRST	PAGALL>		; "4.9 BIT FOR PAGE-TYPE ALLOCATIONS"
	<MOVE	B* <NOFFSET ALLOCPAGE> (A)>
	<LSH	B* 10>		; "ADDRESS OF ALLOCATION PAGE"
	<MOVE	C* (B)>		; "AOBJN TO TABLE"
	<TRZ	C* *776000*>	; "FLUSH HIGH BITS"
	<ADD	C* B>
	<JUMPGE	C* MUNGED>
	<PUSH	P* C>		; " ** SAVED TOP OF ALLOCATION TABLE **"
ARETRY	<MOVEI	O* 0>		; "USE 0 FOR BEST FIT"
	<MOVSI	E* *377777*>	; "MAKE E HIGH"
	<MOVEI	D* DATHDRLEN>
	<ADDB	D* (TP)>	; "AMOUNT NEEDED AND SAVE TOTAL LENGTH"
	<CAMLE	D* [<*777777*>]>
	<JRST	ALLOS1>
ALLOOP	<CAMGE	D* (C)>		; "BIG ENOUGH?"
	<PUSHJ	P* ALCHEK>	; "CHECK IT OUT"
	<JRST	LOCKED>
ALFROB	<ADD	C* [<2 (2)>]>	; "TRY NEXT ENTRY"
	<JUMPL	C* ALLOOP>

TBLOSE	<JUMPE	O* ALLOS1>	; "LOST IN TABLE SEARCH ==> A REAL LOSSAGE"
	<MOVE	C* O>		; "C HAS AOBJN PTR TO WINNER"
	<PUSHJ	P* PGLOCK>
	<JRST	ALLOS3>
	<MOVE	O* 1(C)>	; "WINNING BLOCK POINTER"
	<ADDM	D* 1(C)>	; "FIX UP THIS BLOCK'S LOCATION"
	<SUBM	D* (C)>
	<MOVNS	(C)>		; "FIX UP BLOCK LENGTH"
	<SUB	P* [<1 (1)>]>	; " ** RESTORED TOP OF ALLOC TABLE **"
	<JRST	ALWIN>		; "FINIS"

LOCKED	<ADD	C* [<2 (2)>]>	; "COME HERE IF BLOCK LARGE ENOUGH IS LOCKED"
	<JUMPL	C* ALLOOP>	; "GO BACK TO MAIN LOOP"
	<JUMPE	O* TPSPLT>	; "BREAK UP THE LAST ALLOCATION BLOCK"
	<JRST	TBLOSE 1>	; "HAVE A WINNING ENTRY"

; "COME HERE IF THERE IS A WINNING ENTRY CLOSE ENOUGH TO THE CORRECT SIZE
   TO MAKE IT A WINNER.  IT IS ALREADY LOCKED."

TBLWN1	<MOVE	O* 1(C)>	; "O HAS WINNING BLOCK POINTER"
	<MOVE	A* (C)>
	<MOVEM	A* (TP)>	; "SAVE REAL LENGTH OF BLOCK FOR HEADER"
	<MOVEI	A* 1(C)>
	<POP	P* D>		; " ** RESTORED TOP OF ALLOC TABLE **"
	<PUSHJ	P* BBLT>	; "REMOVE THIS TABLE ENTRY"
	<MOVE	A* -2(TP)>
	<MOVE	A* <NOFFSET ALLOCPAGE> (A)>
	<LSH	A* 10>
	<MOVEM	D* (A)>
	<JRST	ALWIN>		; "AND WIN"

BBLT	<SUBM	M* (P)>
	<MOVEI	B* 2(D)>
	<SUBI	A* -1(B)>	; "BLT TABLE UP TWO LOCATIONS"
	<MOVE	E* A>
	<HRLZS	A>
	<HRR	A* D>
	<ADDI	A* -1(E)>
	<MOVEI	C* (B)>
	<SUBI	C* (A)>
	<ADDI	C* -1(E)>
	<HRLI	C* A>
	<POP	A* @ C>
	<TLNE	A* *777777*>
	<JRST	HERE -2>
	<ADD	D* [<2 (2)>]>	; "REST THE TABLE 2"
	<JRST	MPOPJ>

ALWIN	<POP	P* B>		; " ** RESTORED ADDRESS OF MFD **"
	<PUSH	P* O>
	<MOVE	C* (TP)>
	<TLNE	C* LOKBIT>
	<JRST	ALWIN1>
	<ADDI	B* ALLOCLOCK>	
	<PUSH	TP* <TYPE-WORD WORD>>
	<PUSH	TP* B>
	<MCALL	1 DUNLOCK>	; "UNLOCK THE ALLOCATION TABLE"
ALWIN1	<MOVE	D* -2(TP)>
	<MOVE	B* <NOFFSET ALLOCPAGE> (D)>
	<PUSHJ	P* IPGWRI>	; "TASTEFUL CALL TO PGWRIT IMMEDIATE RETURN"
	<SKIPG	(TP)>		; "DONT LOSE WITH DIRECTORY HACKING"
	<JRST	WINDIR>
	<MOVE	A* <MQUOTE '%<RGLOC DATHDR T>>>
	<ADD	A* GLOTOP 1>	
	<MOVE	C* 1(A)>	; "GET THE EMPTY DATA HEADER"
	<MOVE	B* (TP)>
	<MOVEM	B* 4(C)>	; "SMASH LENGTH SLOT WITH CORRECTED LENGTH"
	<PUSH	TP* -3(TP)>
	<PUSH	TP* -3(TP)>	; "ASYLUM"
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* [5]>	; "HEADER LENGTH"
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* (P)>	; "LOCATION OF BLOCK"
	<PUSH	TP* (A)>
	<PUSH	TP* 1(A)>	; "UVECTOR (DATA HEADER)"
	<MOVE	B* <MQUOTE '%<RGLOC DATA-WRITE-WORD T>>>
	<ADD	B* GLOTOP 1>
	<MOVE	B* 1(B)>	; "GET CREATION TIME WORD"
	<MOVE	C* 1(A)>
	<MOVEM	B* DATCRT (C)>	; "AND MUNG CORRECT SLOT"
	<MOVE	B* <MQUOTE '%<RGLOC DATA-AUTHOR-WORD T>>>
	<ADD	B* GLOTOP 1 >
	<MOVE	B* 1(B)>
	<MOVEM	B* DATCHNCDR (C)>
	<MCALL	4 DATWRITE>
WINDIR	<MOVE	A* <TYPE-WORD FIX>>
	<POP	P* B>		; "RESTORE WINNING ADDRESS"
	<SUB	TP* [<4 (4)>]>	; "TASTE AND WINNAGE"
	<JRST	MPOPJ>

; "VARIOUS LOSSAGES"

; "ALLOCATOR LOCKED"

ALLOSE	<SUB	P* [<1 (1)>]>	
	<MOVE	B* <MQUOTE (6)>>
	<JRST	ALLOS2>

; "DATA AREA FULL OR LOCKED"

ALLOS1	
<IFN10X	#SPLICE ()
	#SPLICE (
	<PUSHJ	P* EXTEND>)>
	<MOVE	A* <MQUOTE (9)>>
ALFAL1	<SUB	P* [<1 (1)>]>

; "HERE FOR MOST LOSSAGES TO RETURN WHICH UNLOCK ALLOCATOR"

ALFALS	<EXCH	A* (P)>		; "SAVE THE FALSE"
	<PUSHJ	P* ALUNLK>	; "UNLOCK THE ALLOCATOR"
	<POP	P* B>		; "RESTORE THE FALSE"

; "HERE FOR LOSSAGES WHICH DONT UNLOCK ALLOCATOR"

ALLOS2	<MOVE	A* <TYPE-WORD FALSE>>
	<SUB	TP* [<4 (4)>]>
	<JRST	MPOPJ>

; "HERE TO EXTEND THE FILE"
; "MOST OF THIS CODE IS COMMENTED OUT UNTIL THE EXTENSION HACK
   OFFICIALLY ENTERS ITS"
; "CHUCKLE, CHUCKLE."

EXTEND	<SUBM	M* (P)>
	
<IFN10X	#SPLICE (
;10X	<JRST	MPOPJ>)
	#SPLICE (
;ITS	<PUSH	TP* -3(TP)>
	<PUSH	TP* -3(TP)>	; "PUSH THE ASYLUM"
	<PUSH	TP* <TYPE-WORD FIX>>
	<MOVE	A* <MQUOTE '%<RGLOC DATA-EXTEND-PAGES T>>>
	<ADD	A* GLOTOP 1 >
	<PUSH	TP* 1(A)>	; "PUSH THE NUMBER OF PAGES"
	<MCALL	2 EXTEND-FILE>	; "WILL FROB, RE-OPEN FILE"
	<SUB	P* [<(3) 3>]>	; "FLUSH CALL TO US AND PUSH OF MFD ADDR"
	<MOVE	A* -2(TP)>
	<MOVE	B* <NOFFSET MFDPAGE> (A)>
	<LSH	B* 10>
	<PUSH	P* B>		; "SET UP ACS AND SUCH"
	<JRST	XXAGAIN>)>	; "TRY AGAIN"

; "DEALLOCATION OUT OF RANGE"

ALLOS3	<MOVE	A* <MQUOTE (16)>>
	<JRST	ALFAL1>

; "NO ROOM FOR PAGE ALLOCATIONS"

ALLOS4	<MOVE	B* <NOFFSET MFDPAGE> (A)>
	<LSH	B* 10>
	<MOVEI	C* *2000*>
	<ADDM	C* MAXADR (B)>	; "FIX UP MAXADR"
<IFN10X	#SPLICE ()
	#SPLICE (
;ITS	<ADD	P* [<1 (1)>]>	; "DONT ASK"
;ITS	<PUSHJ	P* EXTEND>)>
ALOS4A	<MOVE	A* <MQUOTE (18)>>
	<JRST	ALFAL1>		; "AND LOSE CORRECTLY"

MUNGED	<ERRUUO* <MQUOTE MUNGED-ALLOCATION-TABLE!-ERRORS>>

; "HERE TO UNLOCK ALLOCATION TABLE IN TIMES OF LOSSAGE"

ALUNLK	<SUBM	M* (P)>
	<MOVE	C* (TP)>
	<TLNE	C* LOKBIT>
	<JRST	MPOPJ>
	<ADDI	A* ALLOCLOCK>
	<PUSH	TP* <TYPE-WORD WORD>>
	<PUSH	TP* A>
	<MCALL	1 DUNLOCK>
	<JRST	MPOPJ>

; "HERE TO CHECK WHETHER A TABLE ENTRY LARGE ENOUGH FOR THE REQUEST
   IS OTHERWISE SUITABLE.  ALSO CHECKS THAT THE ENTRY IS LOCKABLE"

ALCHEK	<SUBM	M* (P)>
	<MOVE	B* (C)>		; "LENGTH OF THIS ENTRY"
	<CAIL	B* MAXALLDIF (D)> ; "WITHIN FUDGE FACTOR?"
	<JRST	ALCHK1>		; "TAKE IT IMMEDIATELY"
	<PUSHJ	P* PGLOK1>	; "LOCK THESE PAGES"
	<JRST	MPOPJ>		; "BACK TO THE OLD DRAWING BOARD"
	<SUB	P* [<1 (1)>]>	; "FLUSH THIS PUSHJ FROB"
	<JRST	TBLWN1>		; "WINNAGE"
ALCHK1	<PUSH	P* A>
	<CAMG	E* B>		; "IS THIS A SMALLER WINNING ENTRY?"
	<JRST	[<SOS -1(P)>	; "NO. LEAVE WITH A SKIP"
		 <POP P* A>
		 <JRST MPOPJ>]>
	<PUSH	P* E>		; "SAVE BEST LENGTH"
	<PUSH	P* D>		; "SAVE REQUIRED LENGTH"
	<MOVE	A* -5(P)>	; "LOCATION OF ALLOCATOR"
	<ADD	D* 1(C)>	; "TOP LOCATION"
	<PUSHJ	P* BITHAK>	; "GET BP TO THIS"
	<JRST	ALCHLS>
	<MOVE	E* D>		; "AND SAVE IT"
	<MOVE	D* 1(C)>	; "LOW LOCATION"
	<PUSHJ	P* BITHAK>	; "AND BP TO IT"
	<JRST	ALCHLS>
ALCHLP	<LDB	A* D>		; "GET THIS BIT"
	<JUMPE	A* ALCHLS>	; "LOSE IF LOCKED"
	<CAMN	D* E>		; "DONE??"
	<JRST	ALCHWN>		; "WINNAGE (AND TASTE)"
	<IBP	D>		; "NEXT BIT"
	<JRST	ALCHLP>

ALCHWN	<MOVE	O* C>		; "SET E AND O TO POINT TO BEST SO FAR"
	<MOVE	E* (C)>
	<MOVEM	E* -1(P)>
	<SOS	-3(P)>		; "SKIP RETURN TO INDICATE WINNING LOCK"
ALCHLS	<POP	P* D>
	<POP	P* E>
	<POP	P* A>
	<JRST	MPOPJ>		


; "CALL FROM EXTEND-FILE, WITH ASYLUM AND # NEW PAGES.  ASSUMES ALLOCATOR
PAGE AND ASYLUM PAGE MAPPED IN ALREADY"
<SUB-ENTRY ALLOC-UPDATE ("VALUE" ANY ASYLUM FIX)>
	<DPUSH	TP* (AB)>
	<DPUSH	TP* 2(AB)>
	<PUSHJ	P* IALLOCU>
	<JRST	FINIS>

<INTERNAL-ENTRY IALLOCU 2>
	<SUBM	M* (P)>
	<MOVE	B* (TP)>
	<LSH	B* 10>		; "NUMBER OF WORDS OF EXTENSION"
	<MOVE	A* -2(TP)>	; "ASYLUM"
	<MOVE	D* <NOFFSET MFDPAGE> (A)>
	<LSH	D* 10>
	<MOVE	C* HIGHADR (D)>
	<ADDM	B* HIGHADR (D)>
	<MOVE	E* HIGHADR (D)>	; "UPDATE ALLOCATOR AND MAXADR"
	<MOVEM	E* MAXADR (D)>
	<SETZM	DINITRQ (D)>	; "SO WILL BE RE-INITIALIZED"
	<MOVE	E* <NOFFSET ALLOCPAGE> (A)>
	<LSH	E* 10>
	<MOVE	A* FIRSTALLOC (E)>
	<ADD	A* FIRSTALLOC 1 (E)>	; "END OF LAST ENTRY IN ALLOCATOR"
	<CAMN	A* C>
	 <JRST	EXTESY>
	<MOVE	D* (E)>
	<TRZ	D* *776000*>
	<ADD	D* E>		; "AOBJN TO ALLOCATOR IN CORE"
	<MOVEI	A* -2(D)>
	<MOVE	O* A>
	<TRZ	A* *776000*>
	<HRLI	O* (D)>
	<PUSH	P* [0]>
	<CAIGE	A* 4>		; "ALLOCATOR FULL?"
	 <JRST	[<HRLI	O* (D)>	; "THEN FLUSH THE FIRST ENTRY"
		 <SETOM	(P)>
		 <JRST	HERE 1>]>
	<BLT	O* 1020 (E)>	; "INSERT NEW ENTRY INTO ALLOCATOR"
	<MOVEM	B* 1021 (E)>
	<MOVEM	C* 1022 (E)>
	<SKIPL	(P)>		; "DON'T UPDATE IF ALLOC WAS FULL"
	 <SUB	D* [<2 (2)>]>
	<SUB	P* [<(1) 1>]>
	<SUB	D* E>		; "RELATIVIZE ALLOCATOR POINTER"
	<MOVEM	D* (E)>
EXTEXT	<POP	TP* B>
	<POP	TP* A>
	<SUB	TP* [<(2) 2>]>
	<JRST	MPOPJ>

EXTESY	<ADDM	B* FIRSTALLOC (E)>
	<JRST	EXTEXT>
	
<SUB-ENTRY FORCE ("VALUE" CHANNEL CHANNEL)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* IFORCE>
	<JRST	FINIS>

<INTERNAL-ENTRY IFORCE 1>
	<SUBM	M* (P)>
	<POP	TP* B>
	<POP	TP* A>
	<*CALL	[<SETZ>
		 <SIXBIT "FORCE">
		 <SETZ 1(B)>]>
	 <JFCL>
	<JRST	MPOPJ>

; "PGUNLOCK --
    Given the MFD address, the length of an allocation, and its address,
    unlock all of the pages within that allocation"

<SUB-ENTRY PGUNLOCK ("VALUE" 'T FIX FIX FIX)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* PGUNLOCK1>
	<JRST	FINIS>

<INTERNAL-ENTRY PGUNLOCK1 3>
	<SUBM	M* (P)>
	<MOVE	A* -4(TP)>
	<LSH	A* 10>		; "MFD ADDRESS"
	<MOVEI	B* 1>		; "UNLOCK BIT"
	<MOVEI	C* -1(TP)>	; "AOBJN POINTER"
	<MOVE	D* -2(TP)>	; "LENGTH"
	<PUSHJ	P* IPGLOK>
	<JFCL>
	<SUB	TP* [<6 (6)>]>
	<MOVE	A* <TYPE-WORD ATOM>>
	<MOVE	B* <MQUOTE T>>
	<JRST	MPOPJ>


; "Cons up a byte pointer to the page lock for location in D.
   Byte pointer (xx0100,,location) is returned in D
   Skip return unless page lock is illegal"

BITHAK	<SUBM	M* (P)>
	<PUSH	P* E>
	<LSH	D* -10>
	<IDIVI	D* P/L>
	<IDIVI	D* 36>
	<ADDI	D* PGLOCKS (A)>
	<CAIL	D* 1024 (A)>	; "IS THIS POINTER PAST THE ASYLUM PAGE??"
	<JRST	BITERR>		; "OOPS.  THIS BLOCK IS OUT OF BOUNDS"
	<TLO	D* *000100*>
	<SUBI	E* 35>
	<MOVNS	E>
	<LSH	E* 30>
	<IOR	D* E>
	<SOS	-1(P)>
BITERR	<POP	P* E>
	<JRST	MPOPJ>


; "PGLOCK to try to lock all pages for a given allocation
   Skip return if successful
   Unlock all previously locked if unsuccessful"

PGLOCK	<SUBM	M* (P)>
	<MOVE	A* -2(P)>	; "MFD LOCATION"
	<JRST	PGLOK2>

PGLOK1	<SUBM	M* (P)>
	<MOVE	A* -3(P)>
PGLOK2	<SETZ	B*>
	<JRST	HERE 2>

IPGLOK	<SUBM	M* (P)>
	<PUSH	P* E>
	<PUSH	P* D>		; "SAVE LENGTH"
	<PUSH	P* C>		; "AND AOBJN POINTER TO WINNING ENTRY"
	<ADD	D* 1(C)>	; "HIGH LOCATION FOR THIS BLOCK"
	<PUSHJ	P* BITHAK>	; "GET BP FOR THIS LOCATION"
	<JRST	LOKLSR>
	<MOVE	E* D>		; "SAVE HI LOCK IN E"
	<MOVE	D* 1(C)>	; "LOW LOCATION FOR THIS BLOCK"
	<PUSHJ	P* BITHAK>	; "GET BP FOR THIS LOCATION"
	<JRST	LOKLSR>
LOKLP	<LDB	C* D>		; "GET PAGE BIT"
	<JUMPN	B* HERE 2>
	<JUMPE	C* LOKLSR>
	<DPB	B* D>		; "LOCK IT"
	<CAMN	D* E>		; "DONE?"
	<JRST	LOKEND>
	<IBP	D>		; "NOPE. NEXT BYTE"
	<JRST	LOKLP>

LOKEND	<SOS	-3(P)>
LOKLSR	<POP	P* C>
	<POP	P* D>
	<POP	P* E>
	<JRST	MPOPJ>		
	
; "COME HERE FOR ALL PAGE ALLOCATIONS.
   THE ALLOCATOR IS LOCKED.
   A HAS THE ASYLUM
  "

PAGALL	<MOVE	B* (P)>
	<MOVE	O* MAXADR (B)>	; "USABLE END OF FILE"
	<SUBI	O* *2000*>	; "TAKE A PAGE"
	<MOVEM	O* MAXADR (B)>	; "MAKE THIS MAXADR"
	<HLRZ	D* (TP)>
	<TRNE	D* DIRBIT>
	<JRST	DIRALL>		; "DIRECTORY ALLOCATION"
	<TRNE	D* RNDBIT>
	<JRST	RNDALL>		; "RANDOM PAGE ALLOCATION"
MFDALL	<HRRZ	D* (TP)>	; "MFD ALLOCATION"
	<ADD	B* D>
	<MOVEM	O* DIRPTRS (B)>	; "MAKE A POINTER TO THIS DIRECTORY"
RNDALL	<MOVE	B* <NOFFSET ALLOCPAGE> (A)>
	<LSH	B* 10>	; "ADDRESS OF ALLOCATION PAGE"
	<MOVE	C* (B)>		; "AOBJN TO TABLE"
	<TRZ	C* *776000*>	; "FLUSH HIGH BITS"
	<ADD	C* B>
	<HLRE	D* C>
	<SUBM	C* D>		; "D POINTS TO LAST WORD IN ALLOC PAGE"
	<MOVE	C* -2(D)>
	<SUBI	C* *2000*>
	<JUMPLE	C* ALLOS4>	; "LAST ENTRY TOO SMALL. CHOMP, CHOMP"
	<MOVEM	C* -2(D)>
	<HLRZ	D* (TP)>
	<TRNN	D* DIRBIT>
	<JRST	ALWIN>		; "FOR MFD'S AND RANDOM'S LEAVE"
	<PUSH	P* O>
	<PUSH	TP* -3(TP)>
	<PUSH	TP* -3(TP)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<LSH	O* -10>
	<PUSH	TP* O>
	<MCALL	2 DIRMAP>	; "MAP IN THE NEW DIRECTORY"
	<GETYP	A* A>
	<CAIN	A* <TYPE-CODE FALSE>>
	<ERRUUO* <MQUOTE CANT-MAP-NEW-DIRECTORY!-ERRORS>>
	<LSH	B* 10>
	<HRRZ	C* (TP)>
	<TLO	C* *777777*>
	<MOVEM	C* DIRID (B)>
	<POP	P* O>
	<JRST	ALWIN>

DIRALL	<MOVE	B* <NOFFSET DIRPAGE> (A)>
	<MOVE	B* 1(B)>	; "PAGE NUMBER"
	<LSH	B* 10>
	<HRRZ	D* (TP)>
	<HRRZ	E* D>		; "TAKE MOD OF DIR NUMBER AND 1024"
	<LSH	E* -10>
	<LSH	E* 10>
	<SUBI	D* (E)>
	<ADDI	B* (D)>
	<MOVEM	O* (B)>
	<JRST	RNDALL>	


TPSPLT	<MOVE	A* -2(C)>	; "LENGTH OF FINAL ENTRY IN TABLE"
	<SUBI	A* PLH>	; "WANT THREE PAGES"
	<JUMPL	A* ALLOS1>	; "LOSE IF <0"
	<MOVE	B* A>
	<SUB	B* D>
	<JUMPL	B* ALLOS1>	; "LOSE IF AFTER THIS => STILL NO ROOM"
	<MOVEM	A* -2(C)>	; "TAKE 6K FROM ENTRY"
	<MOVEI	A* PLH>
	<MOVE	B* -1(C)>
	<ADDM	A* -1(C)>	; "ADD 6K TO STARTING LOCATION"
	<SUB	C* [<2 (2)>]>
	<PUSH	P* D>	
	<PUSH	P* E>
	<MOVE	D* -2(P)>	; "TOP OF TABLE"
	<MOVEI	A* -2(D)>	; "TOP OF TABLE - 2"
	<MOVE	E* A>
	<TRZ	A* *776000*>
	<CAIGE	A* 4>
	<JRST	OVFLW1>
	<HRL	E* D>
	<BLT	E* -3(C)>	; "BACK UP TWO"
	<MOVEM	B* -1(C)>	; "AND PUT IN NEW ENTRY"
	<MOVEI	A* PLH>
	<MOVEM	A* -2(C)>
	<SUB	D* [<2 (2)>]>
	<MOVE	A* -2(TP)>
	<MOVE	A* <NOFFSET ALLOCPAGE> (A)>
	<LSH	A* 10>
	<MOVEM	D* (A)>		; "TOP OF ALLOCATOR"
	<POP	P* E>
	<POP	P* D>
	<JRST	ALLOOP>

OVFLW1	<SUB	P* [<2 (2)>]>
	<JRST	ALLOS1>		; "MARK THIS AS DATA AREA FULL"


; "Storage deallocator.  
   Takes the ASYLUM , number of freed words and location of start
    of freed block
   The SALVAGER takes a special entry to avoid hard-lock conflict.
   The ALLOCATOR had better be locked when calling by SALVDEALLOC"

<SUB-ENTRY SALVDEALLOC ("VALUE" <OR 'T FALSE> ASYLUM FIX <PRIMTYPE WORD>)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* SALV1>
	<JRST	FINIS>

<INTERNAL-ENTRY SALV1 3>
	<SUBM	M* (P)>
	<MOVE	A* -4(TP)>
	<MOVE	B* <NOFFSET MFDPAGE> (A)>
	<LSH	B* 10>
	<PUSH	P* B>
	<MOVSI	C* *400000*>
	<IORM	C* (P)>		; "TURN ON CRETIN BIT FOR SALVATION"
	<JRST	SALVIN>

<SUB-ENTRY DATDEALLOC ("VALUE" <OR 'T FALSE> ASYLUM FIX <PRIMTYPE WORD>)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* DATA2>
	<JRST	FINIS>

<INTERNAL-ENTRY DATA2 3>
	<SUBM	M* (P)>
	<MOVE	A* -4(TP)>	; "THE ASYLUM"
	<MOVE	B* <NOFFSET MFDPAGE> (A)>
	<LSH	B* 10>		; "ADDRESS OF MFD PAGE"
	<PUSH	P* B>
	<ADDI	B* ALLOCLOCK>
	<PUSH	TP* <TYPE-WORD WORD>>
	<PUSH	TP* B>
	<MCALL	1 DHLOCK>
	<GETYP	B* A>
	<CAIN	B* <TYPE-CODE FALSE>>
	<JRST	ALLOSE>
	<MOVE	A* -4(TP)>
SALVIN	<MOVE	B* <NOFFSET ALLOCPAGE> (A)>
	<LSH	B* 10>		; "ADDRESS OF ALLOCATION PAGE"
	<MOVE	C* (B)>		; "AOBJN TO TABLE"
	<TRZ	C* *776000*>	; "FLUSH HIGH BITS"
	<ADD	C* B>
	<JUMPGE	C* MUNGED>
	<PUSH	P* C>
	<MOVE	B* (TP)>	; "LOCATION OF FREE BLOCK"
DELOOP	<CAMG	B* 1(C)>
	<JRST	DEALL1>
	<ADD	C* [<2 (2)>]>
	<JUMPL	C* DELOOP>
	<SUB	P* [<1 (1)>]>
	<POP	P* A>
	<SKIPL	A>		; "DONT UNLOCK IF IN SALVAGER"
	<PUSHJ	P* ALUNLK>	; "UNLOCK THE TABLE"
	<SUB	TP* [<2 (2)>]>
	<MOVE	B* <MQUOTE (15)>>
	<JRST	ALLOS2>

DEALL1	<SETO>
	<MOVE	D* B>
	<ADD	D* -2(TP)>	; "HIGH END OF THIS FROB"
	<CAME	D* 1(C)>	; "DO WE TOUCH ON RIGHT?"
	<JRST	DEALL2>
	<MOVEM	B* 1(C)>	; "TACK THIS ON"
	<MOVE	D* -2(TP)>
	<ADDM	D* (C)>
	<SETZ>

DEALL2	<MOVE	D* -2(C)>
	<ADD	D* -1(C)>
	<CAME	D* B>		; "DO WE TOUCH ON LEFT?"
	<JRST	TBLADD>
	<JUMPE	O* TBLREM>
	<MOVE	D* -2(TP)>
	<ADDM	D* -2(C)>
	<JRST	DEWIN1>

TBLADD	<JUMPE	O* DEWIN1>
	<POP	P* D>		; "TOP OF TABLE"
	<MOVEI	A* -2(D)>
	<MOVE	E* A>
	<TRZ	A* *776000*>
	<CAIGE	A* 4>
	<JRST	TBLFUL>
	<HRL	E* D>
	<BLT	E* -3(C)>	; "BACK UP TWO"
	<MOVEM	B* -1(C)>	; "AND PUT IN NEW ENTRY"
	<MOVE	A* -2(TP)>
	<MOVEM	A* -2(C)>
	<SUB	D* [<2 (2)>]>
	<JRST	TBLRM1>

TBLREM	<MOVE	B* (C)>
	<ADDM	B* -2(C)>	; "FIX UP BLOCKS"
	<MOVEI	A* 1(C)>
	<POP	P* D>
	<PUSHJ	P* BBLT>

TBLRM1	<MOVE	A* -4(TP)>	
	<MOVE	A* <NOFFSET ALLOCPAGE> (A)>
	<LSH	A* 10>
	<MOVEM	D* (A)>		; "UPDATE AOBJN POINTER"
TBLFUL	<POP	P* A>		; "HERE IF TABLE IS FULL. IGNORE"
	<JRST	DEWIN2>

DEWIN1	<SUB	P* [<1 (1)>]>
	<POP	P* A>

DEWIN2	<JUMPL	A* SLVWIN>
	<ADDI	A* ALLOCLOCK>
	<PUSH	TP* <TYPE-WORD WORD>>
	<PUSH	TP* A>
	<MCALL	1 DUNLOCK>
SLVWIN	<MOVE	B* -4(TP)>
	<MOVE	B* <NOFFSET ALLOCPAGE> (B)>
	<PUSHJ	P* IPGWRT>	; "WRITE THE ALLOCATOR"
	<MOVE	A* <TYPE-WORD ATOM>>
	<MOVE	B* <MQUOTE T>>
	<SUB	TP* [<6 (6)>]>
	<JRST	MPOPJ>

<SUB-ENTRY DATWRITE ("VALUE" ANY ASYLUM FIX
			<PRIMTYPE WORD> <OR UVECTOR <PRIMTYPE WORD>>)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* DWRITE1>
	<JRST	FINIS>

<INTERNAL-ENTRY DWRITE1 4>
	<SUBM	M* (P)>
	<PUSH	P* [-1]>
	<JRST	DREAD2>

<SUB-ENTRY DATREAD ("VALUE" ANY ASYLUM FIX 
			<PRIMTYPE WORD> <OR UVECTOR <PRIMTYPE WORD>>)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* DREAD1>
	<JRST	FINIS>

<INTERNAL-ENTRY DREAD1 4>
	<SUBM	M* (P)>
	<PUSH	P* [0]>
DREAD2	<PUSH	P* [0]>
	<MOVE	A* (TP)>		; "LOW DESTINATION ADDRESS (CORE)"
	<GETYP	O* -1(TP)>
	<TLZE	A* *777777*>		; "LOSE IF > 256K (CLEAR LH IN ANY CASE)"
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPA>
	<ERRUUO* <MQUOTE POTENTIAL-DISASTER!-ERRORS>>
	<ADD	A* -4(TP)>		; " + LENGTH = HIGH DESTINATION ADDRESS"
	<TLNE	A* *777777*>		; "LOSE IF > 256 K"
	<ERRUUO* <MQUOTE POTENTIAL-DISASTER!-ERRORS>>

; "BUG CHECK FINISHED, START REGULAR CODE"
	<MOVE	A* -2(TP)>		; "LOW SOURCE ADDRESS"
	<IDIVI	A* *2000*>		; "GET PAGE NUMBER AND NOFFSET"
	<PUSH	P* B>			; "SAVE OFFSET"
	<MOVE	B* -4(TP)>		; "LENGTH OF OBJECT"
	<ADD	B* -2(TP)>		; "TOP SOURCE ADDRESS"
	<IDIVI	B* *2000*>		; "DO THIS TO SAVE OFFSET"
	<PUSH	P* C>			; "PAGE LOW AND HIGH IN A & B"
					; "OFFSET LOW AND HIGH IN -1(P) AND (P)"
	<PUSH	P* A>			; "SAVE THIS AS PAGE COUNT"
RDLOOP	<MOVE	D* -6(TP)>		; "THE ASYLUM"
	<PUSHJ	P* MAPPER>		; "MAP IN THIS PAGE, PLEASE"
	<ERRUUO* <MQUOTE PAGE-MAPPING-FAILED!-ERRORS>>
	<LSH	A* 10>			; "TO PAGE NUMBER"
	<MOVE	C* (TP)>
	<ADD	C* -3(P)>
	<HRL	A* C>			; "DESTINATION"	
	<ADD	A* -2(P)>		; "ADD IN MAGIC OFFSET FIRST TIME"
	<SKIPL	-4(P)>			; "IF -1, MAKE THIS A WRITE"
	<MOVSS	A>			; "SWAP 'EM FOR THE BLT"
	<MOVEI	C* *1777*>		; "END OF PAGE"
	<CAME	B* (P)>			; "LAST PAGE?"
	<JRST	RDLOP1>
	<HRRZ	C* -1(P)>		; "GET END OF THIS PAGE"
	<JUMPE	C* RDFIN>		; "FIX OBSCURE BUG WITH WORD AT PG BOUNDARY"
	<SUBI	C* 1>
RDLOP1	<SUB	C* -2(P)>		; "START OF PAGE ==> C == LENGTH OF TRANSFER"
	<ADDM	C* -3(P)>		; "UPDATE DESTINATION POINTER"
	<AOS	-3(P)>			; "OOPS. FORGOT THIS ONE"
	<ADD	C* A>			; "ADD TO DESTINATION"
	<BLT	A* (C)>			; "DO THE BLT"
	<SETZM	-2(P)>			; "ZERO FIRST TIME ONLY FLAG"
	<SKIPL	-4(P)>			; "DO A PGWRIT IF A WRITE"
	<JRST	RDLOP2>
	<PUSH	P* B>			; "SAVE B"
	<MOVEI	B* (A)>			; "CORE ADDRESS BLT'D INTO (MSB 6/2/78)"
	<LSH	B* -10>			; "CONVERT TO PAGE #  (MSB 6/2/78)"
	<PUSHJ	P* IPGWRI>		; "PAGE WRITE IMMEDIATE"
	<POP	P* B>			; "GET IT BACK"
RDLOP2	<CAMN	B* (P)>			; "DONE YET?"
	<JRST	RDFIN>			; "THANK MRC"
	<AOS	(P)>			; "NEXT PAGE"
	<MOVE	A* (P)>
	<JRST	RDLOOP>			; "LOOP"

RDFIN	<MOVE	A* -1(TP)>		; "RETURN LAST ARGUMENT (UV OR WORD)"
	<MOVE	B* (TP)>
	<SUB	P* [<5 (5)>]>
	<SUB	TP* [<8 (8)>]>
	<JRST	MPOPJ>

; "Map in a directory page.  The page of the directory is in A"

<SUB-ENTRY DIRMAP ("VALUE" <OR FALSE FIX> ASYLUM FIX)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* IDIRMAP>
	<JRST	FINIS>

<INTERNAL-ENTRY IDIRMAP 2>
	<SUBM	M* (P)>
	<MOVE	D* -2(TP)>
	<MOVE	A* (TP)>
	<PUSHJ	P* MAPPR1>
	<JRST	DIRMLS>
	<MOVE	B* A>
	<MOVE	A* <TYPE-WORD FIX>>
	<SUB	TP* [<4 (4)>]>
	<JRST	MPOPJ>

DIRMLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVE	B* <MQUOTE (12)>>
	<SUB	TP* [<4 (4)>]>
	<JRST	MPOPJ>

; "Map in a page from a ASYLUM file, the ASYLUM is in D
   The page number is in A
   Return the page number of the in-core copy in A
   Only B and D are spared"

<SUB-ENTRY MAP-IN ("VALUE" FIX ASYLUM FIX)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* IMAP-IN>
	<JRST	FINIS>

<INTERNAL-ENTRY IMAP-IN 2>
	<SUBM	M* (P)>
	<MOVE	A* (TP)>
	<MOVE	B* A>
	<MOVE	D* -2(TP)>
	<PUSHJ	P* MAPPER>	
	<ERRUUO* <MQUOTE MAPPING-FAILED!-ERRORS>>
	<MOVE	B* A>
	<MOVE	A* <TYPE-WORD FIX>>
	<SUB	TP* [<4 (4)>]>
	<JRST	MPOPJ>

MAPPER	<SUBM	M* (P)>
	<PUSH	P* B>			; "POINT B AT THE PAGE MAP"
	<MOVE	O* B>			; "POINT O AT HIGH PAGE NEEDED"
	<MOVE	B* <NOFFSET PAGEMAP> (D)>; "(P) IS NOW HIGH PAGE NEEDED"
	<JRST	MAPPR2>

MAPPR1	<SUBM	M* (P)>
	<PUSH	P* [-1]>		; "INDICATES DIR HACK"
	<MOVE	O* A>
	<MOVE	B* <NOFFSET DIRPAGEMAP> (D)>

MAPPR2	<JUMPGE	B* MAPERR>
	<MOVE	C* <MQUOTE '%<RGLOC LRUCOUNT T>>>
	<ADD	C* GLOTOP 1>
	<AOS	C* 1(C)>		; "INCREMENT THE COUNTER"
	<PUSH	P* C>			; "AND SAVE THE COUNTER SO"
	<SETZ	E*>			; "ZERO E"
MAPLP	<SKIPGE	(B)>
	<JRST	MAPWIN>			; "NOTHING MAPPED IN HERE"
	<CAMN	A* (B)>			; "HAVE THE RIGHT PAGE?"
	<JRST	MAPWN1>			; "LUCKY"
	<CAMN	C* (P)>			; "WE SAVED THE COUNT"
	<JRST	MAPLP1>			; "FIRST TIME ==> TAKE ANYTHING"
	<SKIPL	-1(P)>			; "CHECK WHETHER THIS IS DIR MAPPING"
	<JRST	HERE 3>			; "NO FUNNY PAGE HACKING FOR DIR'S"
	<CAML	O* (B)>			; "IF THIS IS INCLUSIVELY BETWEEN"
	<CAML	A* (B)>			; "THE LOW PAGE AND THE HIGH PAGE"
	<CAMGE	C* 2(B)>		; "OR IF LRU IS HIGHER THAN CURRENT BEST"
	<JRST	MAPLP2>			; "THEN SKIP THIS PAGE"
MAPLP1	<SKIPGE	-1(P)>			; "SPECIAL HACK FOR DIR"
	<JRST	[<SKIPE 3(B)>		; "CHECK THE LOCK FOR THIS ENTRY"
		 <JRST MAPLP2>		; "DONT DO THIS IF ENTRY IS LOCKED"
		 <JRST MAPLP1A>]>
MAPLP1A	<MOVE	E* B>			; "YES. POINT E AT THIS SPOT"
	<MOVE	C* 2(B)>		; "AND MAKE C LRU SO FAR"
MAPLP2	<ADD	B* [<4 (4)>]>		; "NEXT ENTRY"
	<JUMPL	B* MAPLP>		; "LOOP"
	<JUMPE	E* [<SUB P* [<1 (1)>]>
		    <JRST MAPERR>]>	; "DO WE HAVE ANY WINNERS?"
	<MOVE	B* 1(E)>		; "GET CORE PAGE"
	<SKIPE	3(E)>			; "THIS PAGE WAS WRITTEN RECENTLY"
	<PUSHJ	P* PGSWAP>		; "THIS PAGE WANTS TO BE PGWRIT'en"
	<MOVEM	A* (E)>			; "STUFF WITH THIS PAGE NUMBER"
	<POP	P* C>			; "RESTORE THE LRU COUNTER"
	<MOVEM	C* 2(E)>		; "AND MARK AS UPDATED"
	<SETZM	3(E)>			; "CLEAR THE LOCK ENTRY"
	<SKIPGE	(P)>			; "DIR SWITCH"
	<JRST	MAPWN2>
	<SKIPE	-6(P)>	
	<SETOM	3(E)>			; "MARK AS WRITTEN NOW"
	<JRST	MAPWN2>
MAPWIN	<POP	P* C>			; "RESTORE THE LRU COUNTER"
	<MOVEM	C* 2(B)>		; "AND MARK AS UPDATED"
	<SETZM	3(B)>			; "CLEAR THE LOCK ENTRY"
	<SKIPGE	(P)>			; "DIR SWITCH"
	<JRST	HERE 3>
	<SKIPE	-6(P)>			; "R/W SWITCH"
	<SETOM	3(B)>			; "MARK AS WRITTEN NOW"
	<MOVEM	A* (B)>			; "STUFF FILE PAGE NUMBER"
	<MOVE	B* 1(B)>		; "GET CORE PAGE"
MAPWN2	<PUSH	TP* <TYPE-WORD CHANNEL>>
	<PUSH	TP* <NOFFSET DSKCHAN> (D)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>			; "PAGE IN FILE TO BE MAPPED"
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* B>			; "PAGE TO MAP INTO"
	<PUSH	P* B>			; "SAVE PAGE NUMBER FOR RETURN"
	<PUSHJ	P* MAP1>		; "INTERNAL CALL TO MAP-PAGE"
	<GETYP	B* A>
	<CAIE	B* <TYPE-CODE FALSE>>
	<SOS	-2(P)>			; "SOS FOR SKIP RETURN (BLETCH)"
	<POP	P* A>			; "CORE PAGE IN A FOR RETURN"
MAPERR	<POP	P* B>			; "RESTORE THE WINNING PAGE NUMBER"
	<JRST	MPOPJ>

MAPWN1	<POP	P* C>
	<MOVEM	C* 2(B)>		; "AOS THE USE COUNTER"
	<MOVE	A* 1(B)>		; "GET CORE PAGE"
	<POP	P* B>			; "RESTORE THE WINNING PAGE NUMBER"
	<SOS	(P)>			; "SKIP RETURN NOW"
	<JRST	MPOPJ>

; "Here if a page must be forced out of core.
   A directory swap request is marked by -1 in -2(P)"

PGSWAP	<SUBM	M* (P)>
	<SKIPGE	-2(P)>			; "IS THIS A DIRECTORY HACK"
	<JRST	DIRSWP>			; "YES. DO IT"
	<PUSH	P* A>
	<PUSH	P* B>
	<PUSHJ	P* IPGWRT>		; "PGWRITE IF JUST A RANDOM PAGE"
	<POP	P* B>
	<POP	P* A>
	<JRST	MPOPJ>

DIRSWP	<SUB	P* [<2 (2)>]>		; "FLUSH THIS CALL AND SAVED C"
	<JRST	MAPERR>			; "REMEMBER -- PAGE SWAPPING ILLEGAL FOR DIRS"


<SUB-ENTRY PGWRITE ("VALUE" 'T FIX)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* PGWRITE1>
	<JRST	FINIS>

<INTERNAL-ENTRY PGWRITE1 1>
	<SUBM	M* (P)>
	<MOVE	B* (TP)>		;"B/ NUMBER OF PAGE TO BE WRITTEN (ITS PAGES)"
	<PUSH	P* [-1]>		;"INDICATES THIS WAS CALLED AS AN RSUBR"
	<SETZ	C*>			;"DON'T HANG UNTIL PAGE WRITTEN (ITS ONLY)"
	<JRST	PGWRT1>


 ;"B/ NUMBER OF PAGE TO BE WRITTEN (ITS PAGES)"

IPGWRI	<SUBM	M* (P)>
	<PUSH	P* [0]>			;"INDICATES THIS WAS CALLED AS AN INTERNAL"
	<MOVEI	C* 1>			;"DON'T HANG UNTIL PAGE WRITTEN (ITS ONLY)"
	<JRST	PGWRT1>


;"B/ NUMBER OF PAGE TO BE WRITTEN (ITS PAGES)"

IPGWRT	<SUBM	M* (P)>
	<PUSH	P* [0]>			;"INDICATES THIS WAS CALLED AS AN INTERNAL"
	<SETZ	C*>			;"HANG UNTIL PAGE WRITTEN (ITS ONLY)"


;"B/ NUMBER OF PAGE TO BE WRITTEN (ITS PAGES)"
	
PGWRT1	<MOVE	A* <MQUOTE %'<RGLOC PGWRITE-FLAG!-ASYLUM!-PACKAGE T>>>
	<ADD	A* GLOTOP 1>
	<SKIPN	1(A)>			; TEST FLAG FOR PGWRITING
	 <JRST	PGWWIN>

<IFN20X
	#SPLICE (
;20X		<MOVEI	A* (B)>			;"A/ NO. OF CORE PAGE (ITS FORMAT)"
		<LSH	A* 1>			;"TWO TWENEX PAGES PER ITS PAGE"
		<HRLI	A* *400000*>		;" 'THIS FORK' DESIGNATOR"
		<RMAP>				;"PUT JFN AND FILE PAGE NO. INTO A"
		<MOVEI	B* 2>			;"TWO TWENEX PAGES PER ITS PAGE"
		<UFPGS>				;"FORCE PAGES TO DISK"
		<JRST	HUH>			;"JUMP IF FAILS")

	#SPLICE (
;10X		)

	#SPLICE (
;ITS		<MOVEI	A* 10>
;ITS	PGWLP	<JUMPE	A* HUH>
;ITS		<*CALL	[<SETZ>
;ITS			 <SIXBIT "PGWRIT">
;ITS			 <MOVS C>		; "CONTROL BIT"
;ITS			 <SETZ B>]>
;ITS		<SOJA	A* PGWLP>)>		;"TRY 8 TIMES IF IT FAILS"


;"HERE IF PAGE SUCCESSFULLY FORCED TO DISK"

PGWWIN	<POP	P* A>
	<JUMPE	A* CHOMP>			;"NO RETURN VALUE IF CALLED AS INTERNAL"
	<MOVE	A* <TYPE-WORD ATOM>>
	<MOVE	B* <MQUOTE T>>
	<SUB	TP* [<2 (2)>]>
CHOMP	<JRST	MPOPJ>


;"HERE IF COULDNT'T FORCE PAGE TO DISK"

HUH	<POP	P* A>
	<JUMPE	A* CHOMP>			;"NO RETURN VALUE IF CALLED AS INTERNAL"
	<MOVE	A* <TYPE-WORD FALSE>>
	<SETZ	B*>
	<SUB	TP* [<2 (2)>]>
	<JRST	MPOPJ>



<SUB-ENTRY MAP-PAGE ("VALUE" <OR FALSE 'T> CHANNEL FIX FIX)>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* MAP1>
	<JRST	FINIS>

<INTERNAL-ENTRY MAP1 3>
	<SUBM	M* (P)>

<IFN10X #SPLICE (
;10X		<MOVE	A*	-2	(TP)>
;10X		<LSH	A*	1>
;10X		<MOVE	B*	-4	(TP)>
;10X		<HRL	A*	1	(B)>
;10X		<MOVE	B*	(TP)>
;10X		<LSH	B*	1>
;10X		<TLO	B*	*400000*>
;10X		<PUSH	P*	C>)
	#SPLICE (
;ITS		)>

<IFN20X	#SPLICE (
;20X		<MOVSI	C*	*540000*>
;20X		<HRRI	C*	2>	;"MAP TWO CONSECUTIVE PAGES"
;20X		<PMAP>
;20X		<POP	P*	C>)
	#SPLICE (
;10X		<MOVSI	C*	*140000*>
;10X		<PMAP>
;10X		<AOJ	A*>
;10X		<AOJ	B*>
;10X		<PMAP>
;10X		<POP	P*	C>)
	#SPLICE (
;ITS		<MOVE	A* -4(TP)>
;ITS		<*CALL [<SETZ>
;ITS			<SIXBIT "CORBLK">
;ITS		   	<MOVEI *150000*>
;ITS			[-1]
;ITS			<(TP)>
;ITS			<1(A)>
;ITS			<SETZ -2(TP)>]>
;ITS		<JRST	MAPLOSE>)>

	<MOVE	A* <TYPE-WORD ATOM>>
	<MOVE	B* <MQUOTE T>>
	<SUB	TP* [<6 (6)>]>
	<JRST	MPOPJ>

<IFN10X #SPLICE ()
	#SPLICE (
;ITS	MAPLOSE	<MOVE	A* <TYPE-WORD FALSE>>
;ITS		<SETZ	B*>
;ITS		<SUB	TP* [<6 (6)>]>
;ITS		<JRST	MPOPJ>)>


<SUB-ENTRY UNMAP-PAGE ("VALUE" <OR FALSE 'T> FIX)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* UNMAP1>
	<JRST	FINIS>

<INTERNAL-ENTRY UNMAP1 1>
	<SUBM	M* (P)>

<IFN10X #SPLICE (
;10X		<SETOM		A>
;10X		<MOVE	B*	(TP)>
;10X		<LSH	B*	1>
;10X		<TLO	B*	*400000*>)
	#SPLICE (
;ITS		)>

<IFN20X	#SPLICE (
;20X		<MOVSI	C*	*400000*>
		<HRRI	C*	2>
		<PMAP>)
	#SPLICE (
;10X		<MOVEI	C*	0>
;10X		<PMAP>
		<AOJ	B*>
		<PMAP>)
	#SPLICE (
;ITS		<MOVE	A* -4(TP)>
;ITS		<*CALL [<SETZ>
;ITS			<SIXBIT "CORBLK">
;ITS		   	<MOVEI 0>
;ITS			[-1]
;ITS			<SETZ	(TP)>]>
;ITS		<JRST	UNMAPLOSE>)>

	<MOVE	A* <TYPE-WORD ATOM>>
	<MOVE	B* <MQUOTE T>>
	<SUB	TP* [<2(2)>]>
	<JRST	MPOPJ>

<IFN10X #SPLICE ()
	#SPLICE (
;ITS	UNMAPLOSE	<MOVE	A* <TYPE-WORD FALSE>>
;ITS		<SETZ	B*>
;ITS		<SUB	TP* [<2(2)>]>
;ITS		<JRST	MPOPJ>)>



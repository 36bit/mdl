MADMAN User Documentation

    This document is, by intention, incomplete in that it provides
the common user with enough information to use the MADMAN package
in its most important functions.  In fact, the new COMSYS demon, which
uses MADMAN and ASYLUM extensively, uses only those primitives within
the first half of this document.  More complete documentation of
internal routines, internal structure, etc. can be found in the file
MADMAN;MADMAN INTERN.  However, being caught reading said document
is grounds for divorce in 38 states and is sufficient for committment
to state psychiatric institutions in 45.  
  
    There are two sections to this document, the first describing
the basic set of MADMAN primitives, and the second including some
extra detail about these primitives.  In my experience, the material
in the second section is not necessary to use MADMAN to its full
potential.

						Marc Blank


MADMAN for the Previously Sane

I.  Overview

    The MADMAN package provides a facility for creating, manipulating,
and performing input/output routines on MUDDLE structures which do
not reside in MUDDLEs garbage collected storage area.  There are two
major advantages to having MUDDLE objects outside of garbage collected
storage, namely the ability to share MUDDLE objects between jobs
(much like the MUDDLE FBIN facility) and the ability to perform fast
disk i/o on MUDDLE objects.

II. Creating a Non-Garbage Collected SPACE

    In the MADMAN package, the unit of non-garbage collected storage
is the MUDDLE object of TYPE SPACE.  An object of TYPE SPACE can be
generated by a call to AFIND.
	
	<AFIND number-of-pages:fix OPTIONAL space:space>

    where number-of-pages is the number of ITS-size (1024 word) pages
of storage desired.  Unless MUDDLE has no more remaining core, AFIND
will return the SPACE, containing number-of-pages*1024 words of 
contiguous storage.  The pages are always initialized to zeros.
SPACEs have a funny PRINTTYPE which is described far below.

    The optional argument of a SPACE will cause the MUDDLE structure
of PRIMTYPE VECTOR which is the SPACE to be reused, thus avoiding
the use of extra garbage-collected storage.

III. Limitations on SPACEs

    It should be obvious that any MUDDLE structure outside of garbage
collected storage had best not contain references to other MUDDLE
objects which reside within garbage collected storage.  If one does,
the next garbage collection will cause such references to become
either wrong, ridiculous, or fatal, depending on your luck.

    The most important MUDDLE TYPE which cannot correctly be part
of a SPACE is TYPE ATOM, which must point to OBLISTs, etc. which
lie within the garbage collector's easy reach.  On the other hand,
MUDDLE objects of PRIMTYPEs WORD, LIST, VECTOR, STRING, UVECTOR, and
TEMPLATE may be used within SPACEs.

    A warning about the use of NEWTYPEs should be made: although
NEWTYPEs are legal within SPACEs, one must be certain that the
MUDDLE which is reading that structure uses the same type codes
as that MUDDLE which wrote it.  Otherwise, the warranty is voided.

IV. Creating MUDDLE Objects in a SPACE

    MUDDLE objects may be created within a SPACE by calls to MADMAN
routines which parallel MUDDLEs structure-creating SUBRs.  There
are two types of calling sequences possible, those with and those
without explicit reference to a SPACE.  The general form of the
former is

	<Atype space:space element1:any element2:any ....>

    and that of the latter is

	<ALtype element1:any element2:any ....>

    where type is the name of a MUDDLE TYPE.
    
    The former is usually used in all cases except those in which
it would be inconvenient to supply the SPACE argument explicitly.
The only case which comes to mind is MAPF/MAPR (i.e. one can say
<MAPF ,ALtype ....>).  With the implicit call, the ATOM CURSPACE
must be bound to the SPACE which is to be used.  Remember that in
compiled code, CURSPACE must be DECLed SPECIAL!

    The primitives for object creation are
	
	ALIST, AVECTOR, ASTRING, ABYTES (explicit SPACE argument)
	ALLIST, ALVECTOR, ALSTRING, ALBYTES (implicit SPACE argument).

    Primitives also exist which parallel the MUDDLE Itype SUBRs.
These are used exactly as the MUDDLE SUBRs are, except that the
second argument is EVALed only once, and not on every loop.
The primitives are

	AILIST, AIVECTOR, AISTRING, AIBYTES (explicit SPACE argument)
	ALILIST, ALIVECTOR, ALISTRING, ALIBYTES (implicit SPACE argument).
    
V. Copying MUDDLE Objects into SPACEs

    It often becomes desirable to copy a MUDDLE object either from
one SPACE to another or from MUDDLE's garbage-collected storage
into a SPACE.  These two functions are handled by the routines
AGC, for the former, and ACOPY, for the latter.  These routines
are called as follows:

        <AGC/ACOPY space:space object:any>

    The difference between AGC and ACOPY is that the former alters
object so that sharing and circularity may be preserved.  This
alteration, when observed by the MUDDLE Garbage Collector, causes
it to become violently ill, and in so doing, to give your MUDDLE a
fatal error.  ACOPY, on the other hand, copies all substructures
in object, and will, therefore, iterate ad infinitum on circular
objects.  It becomes obvious to the unconfused that copying a 
circular structure from garbage-collected storage to a SPACE is not
possible without a good sense of humor.

VI. Recycling MADMAN Storage

    It is possible to 'throw away' structures within SPACEs, so that
the storage they utilize will be recycled.  This scheme is similar
to that built into the MUDDLE interpreter.  To recycle a structure
(it is useless to recycle MONADs), use

    	<ARELEASE space:space object:any OPTIONAL depth:fix>

    where space had better be the space in which object resides.
The depth argument the number of levels of structure to 'throw away'.
It is optional and defaults to 1 (i.e. the top level structure).
A depth argument of -1 requests the object and all substructure to
be released.  Do not use the -1 argument with a circular or self-
referencing structure or infinite recursion will result.

VII. MADMAN Input/Output Routines

    The MADMAN I/O routines are compatible with either I/O to
standard ITS disk channels or to ASYLUMs (see documentation on the
ASYLUM package).  The primitives are AREAD and APRINT, as described
below.

	<APRINT space:space object:any device:channel-or-asylum>

    where space is the SPACE in which object resides, object is
the object to be APRINTed (i.e. the object to be returned when an
AREAD is performed subsequently), and device is either a MUDDLE
CHANNEL open in PRINTB mode or an ASYLUM. 

	<AREAD space:space device:channel-or-asylum>

    where space is the SPACE into which to read the object, and
device is either a MUDDLE CHANNEL open in READB mode or an ASYLUM.
AREAD returns the object previously APRINTed.

    Both APRINT and AREAD have additional optional arguments which
are described below.  These arguments are truly optional - not using
them will never result in an error.

VIII. Maintenance of SPACEs

 a. Resetting SPACEs

    It often is necessary to 'reset' a SPACE, which in the simplest
sense means zeroing the pages in the SPACE, making it appear the
way it was when created.  Everything is the SPACE is thrown away,
and anyone left holding a pointer to structure therein is alikened
to one holding a deed to the Brooklyn Bridge.  SPACEs which have
for one reason or another become 'full' (i.e. the storage has
been used up) are prime candidates for 'reset'ing.  The routine
to 'reset' a SPACE is ARESET, which returns the 'reset' SPACE.

 	<ARESET space:space OPTIONAL flush:boolean clear:boolean>

    where space is the space to be reset.  The optional arguments
are flags which default to T.  The flush flag, if non-false, causes
'fragments' of SPACEs (see Page Management of SPACEs, below if
truly interested) to be thrown away, and the clear flag, if 
non-false, causes the SPACE to be filled with zeros.  This is
obviously slower than not filling the SPACE with zeros.

b. Throwing away SPACEs

    When a SPACE is no longer needed, the core pages may be given
back to MUDDLE with a call to AGIVE.

	<AGIVE space:space>

 c. Checking the Internal Consistency of SPACEs

    A routine exists, BOUNDS-CHECK, which will search the entire SPACE
for references to garbage collected space.  If one is found, it is
returned as the second element of an object of TYPE FALSE,

	#FALSE ("OBJECT-POINTS-OUTSIDE-SPACE" object:any).

    If the SPACE is consistent, a non-false is returned.

	<BOUNDS-CHECK space:space>

 d. Checking the Legality of Objects within SPACEs

    A simple check may be applied to any MUDDLE object to determine
whether that object was created within the SPACE.  It does not vouch
for any elements of structured objects, but rather the external
structure itself.  All MONADs are legal within SPACEs.

	<ALEGAL? space:space object:any>


MADMAN for the Hopelessly Insane

I. Page Management for SPACEs 

    Although SPACEs, when generated, contain one chunk of contiguous
storage, a SPACE will grow dynamically when a request for storage
allocation within it exceeds the remaining storage available for
it.  This process is invisible to the user, but it has implications
for MADMAN I/O routines.  When a SPACE is 'grown', a number of new
core pages, necessary for the request, is obtained from MUDDLE.  These
pages may or may not be contiguous with the initial storage of the
SPACE.  If not, the SPACE is 'fragmented', and I/O routines which
read and print the contents of the SPACE must do these operations
for each 'fragment' of the SPACE in turn.  The result is slower I/O
in both directions.

    When a SPACE is created of any given size, internal routines
are used to request the use of core pages from MUDDLE.  MADMAN then
uses the pages which MUDDLE supplies.  One can, however, reserve
a number of pages from MUDDLE at the start, and use only those pages
for creating SPACEs.  The advantage is that the total number of pages
are from the outset contiguous, and a SPACE, if grown, can use the
remaining contiquous storage which is available.  

    To reserve pages, use

	<ARESERVE #pages:fix OPTIONAL table:uvector share?:boolean>

    where #pages is the number of pages to reserve, table is a
UVECTOR or 8 WORDs, with one bit representing each of the 256 pages
in a core image.  This argument defaults to the GVAL of the ATOM
ALLOC-TABLE.  The share? argument should be non-false if the pages
are to be shared between processes (see sharing, below).
  
X. MADMAN I/O Optimization (advanced)

    As has been noted above, SPACEs can become 'fragmented' in the
process of dynamic expansion caused by a request for storage allocation
exceeding that storage remaining in the SPACE.  The resulting problems
with MADMAN I/O operations was vaguely alluded to and will here be
expanded.

    A major advantage of MADMAN is that disk I/O is very fast (about
200 times that of READ/PRINT and 10 times that of GC-READ/GC-DUMP).
This enormous advantage obtains in the ideal case of being able to
'AREAD' into those core locations from which the original data was
'APRINT'ed.  Thus, there need be no 'fixup' of pointers within the
object AREAD into the SPACE.  The most efficient I/O, therefore,
is APRINT'ing from/AREAD'ing into the same SPACE (i.e. the same core
locations).  The cost of 'fixup' is not great, amounting to about
.01 CPU-second/1024 words read.  However, this quadruples the time
required in the absence of 'fixup'.

    When a 'fragmented' SPACE is written, in the standard way, MADMAN
must write each 'fragment' onto the disk separately, resulting in
some loss of speed.  This can be helped by the use of the long form
of APRINT, as follows:

    	<APRINT space object device 0 flag:boolean>
   
    where 0 is an unfortunate throwback to the old days and flag
is the 'pre-fixup' flag, which causes the SPACE to be written as if
it was in core in one piece, that is doing the 'fixup' before it
is written.  AREAD'ing this object, if the SPACE is large enough,
will be done in one operation (see below).  APRINT'ing with the
'pre-fixup' flag will 'fixup' the object in your core image;
therefore, one had best not refer to the object after it is written.

    AREAD can also be caused to 'read' in different ways in the
case of SPACEs which are 'fragmented'.  The long form of AREAD is
	
	<AREAD space device 0 speed:fix keep-chains:boolean>

    where the speed argument is a fix, from 1 to 3 with the following
meanings:

	1 (slowest) - Always read into contiguous pages.
	2 (faster) -  Always read into contiguous pages but try to
		      read the largest 'fragment' into the pages
		      from which it was written.
	3 (fastest) - Try to read each 'fragment' into the page
		      from which it was written. 
    
    The default is 3 (fastest), which means that the amount of
'fixup'ing done will be minimal.  Note that all of this fuss with
optional I/O arguments is only applicable with 'fragmented' SPACEs.
If one's SPACEs are known to be large enough at all times for the
MUDDLE objects within it, then the SPACEs will never grow and the
issues described here are unimportant.

    The last argument is a flag which determines whether or not
the LIST and VECTOR free chains (see below, ARELEASE) should be
kept.  The default is to keep them around (T). 


VIII. Sharing SPACEs between Processes (ITS only)

    A facility exists for the sharing of SPACEs between ITS processes.
The description of this facility is in the complete documentation.
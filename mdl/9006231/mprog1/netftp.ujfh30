
<PACKAGE "NETFTP">

<ENTRY CONNECT ACC ICP WAITRESP LAST-RESP SOAK UNSOAK>

<ENTRY TIMEOUT WAIT-ACT CLOCK-COUNTER START-COUNTER>

<GDECL (SOAK?) <OR 'T FALSE>>

"SOAK AND UNSOAK -- ENABLE AND DISABLE SCRIPTING OF FTP TRANSACTIONS"

<DEFINE SOAK () <SETG SOAK? T>>

<DEFINE UNSOAK () <SETG SOAK? <>>>

<SETG SOAK? T>

"CONNECT -- CONNECT TO FTP SERVER AT A SPECIFIED HOST
  ARG1 -- HOST (FIX)
  ARG2 -- ACCESS INSTRUCTIONS, OR FALSE.  IF TRUE, MUST BE LIST
   OF ITEMS, AS FOLLOWS:
	1/ STRING, ARG FOR USER COMMAND
	2/ STRING, TO BE USED AS ARG TO PASSWORD COMMAND, IF EMPTY
		OR FALSE, NONE WILL BE ISSUED
	3/ STRING, TO BE USED AS ARG TO ACCOUNT COMMAND
  ARG3 -- TYPE OF TRANSFER (STRING) FALSE--NONE
  ARG4 -- BYTE SIZE (FIX) FALSE--NONE
  ARG5 -- MODE OF TRANSFER (STRING) FALSE--NONE

 -- RETURNS LIST OF INPUT AND OUTPUT CHANNELS, OR #FALSE(REASON.STRING)"

<DEFINE CONNECT (HOST ACC TYP BYT MODE
		 "AUX" CHS OCH ICH (CR <STRING <ASCII 13> <ASCII 10>>))
	#DECL ((INCHAN) CHANNEL (VALUE) <OR FALSE <LIST CHANNEL CHANNEL>>
	       (HOST) FIX (CR) STRING (BYT) <OR FIX FALSE>
	       (TYP MODE) <OR STRING FALSE> (CHS) <OR LIST <FALSE STRING>>
	       (ACC) <LIST [3 STRING]> (OCH ICH) CHANNEL)
	<COND (<SET CHS <ICP .HOST 3>>
	       <SET ICH <1 .CHS>>
	       <SET OCH <2 .CHS>>
	       <WAITRESP <1 .CHS> '(300)>
	       <COND (.ACC
		      <PRINC "USER " .OCH>
		      <PRINC <1 .ACC> .OCH>
		      <PRINC .CR .OCH>
		      <WAITRESP <1 .CHS> '(230 200 330)>
		      <COND (<AND <2 .ACC> <NOT <EMPTY? <2 .ACC>>>>  ;"PASSWORD"
			     <PRINC "PASS " <2 .CHS>>
			     <PRINC <2 .ACC> <2 .CHS>>
			     <PRINC .CR <2 .CHS>>
			     <WAITRESP .ICH '(230 200 331)>)>
		      <COND (<NOT <EMPTY? <3 .ACC>>>		      ;"ACCOUNT"
			     <PRINC "ACCT " .OCH>
			     <PRINC <3 .ACC> .OCH>
			     <PRINC .CR .OCH>
			     <WAITRESP .ICH '(230 200)>)>)>
	       <COND (.TYP				        ;"TRANSFER TYPE"
		      <PRINC "TYPE " .OCH>
		      <PRINC .TYP .OCH>
		      <PRINC .CR .OCH>
		      <WAITRESP .ICH '(200)>)>
	       <COND (.BYT					    ;"BYTE SIZE"
		      <PRINC "BYTE " .OCH>
		      <PRINC <UNPARSE .BYT> .OCH>
		      <PRINC .CR .OCH>
		      <WAITRESP .ICH '(200)>)>
	       <COND (.MODE						 ;"MODE"
		      <PRINC "MODE " .OCH>
		      <PRINC .MODE .OCH>
		      <WAITRESP .ICH '(200)>)>
	       .CHS)>>

"GETLINE -- GET A RESPONSE FROM FTP CONNECTION, INCLUDING CONTINUATION LINES"

<DEFINE GETLINE (CH "AUX" COD)  
   #DECL ((CH) CHANNEL (COD) STRING (VALUE) STRING)
   <PROG ()
	 <SET COD
	      <MAPF ,STRING
		    <FUNCTION ("AUX" (CHAR <NETCHR .CH>))
			 #DECL ((CHAR) <OR CHARACTER FALSE>)
			 <COND (<N==? .CHAR <ASCII 13>>
				<COND (<N==? .CHAR <ASCII 0>>
				       <MAPRET .CHAR>)
				      (ELSE <MAPRET>)>)
			       (ELSE <MAPSTOP>)>>>>
	 <OR <NETCHR .CH><ERROR CHANNEL-CLOSED GETLINE>>
	 <COND (<LENGTH? .COD 3> <AGAIN>)>
	 <COND (<NOT ,SOAK?>
		<PROG ((OUTCHAN .OUTCHAN))
		      #DECL ((OUTCHAN) CHANNEL)
		      <OR <0? <14 .OUTCHAN>> <CRLF>>
		      <PRINC "FTP: ">
		      <PRINC .COD>
		      <TERPRI>>)>
	 <COND (<==? <4 .COD> !\->			    ;"CONTINUATION LINE"
		<REPEAT (L)
			#DECL ((L) STRING)
			<SET L
			     <MAPF ,STRING
				   <FUNCTION ("AUX" (CHAR <NETCHR .CH>))
					#DECL ((CHAR) <OR CHARACTER FALSE>)
					<COND (<N==? .CHAR <ASCII 13>> <MAPRET .CHAR>)
					      (ELSE <MAPSTOP>)>>>>
			<OR <NETCHR .CH> <ERROR CHANNEL-CLOSED GETLINE>>
			<COND (<NOT ,SOAK?>
			       <PROG ((OUTCHAN .OUTCHAN))
				     #DECL ((OUTCHAN) CHANNEL)
				     <OR <0? <14 .OUTCHAN>> <CRLF>>
				     <PRINC "FTP: ">
				     <PRINC .L>
				     <TERPRI>>)>
			<COND (<AND <NOT <LENGTH? .L 2>>
				    <==? <1 .L> <1 .COD>>
				    <==? <2 .L> <2 .COD>>
				    <==? <3 .L> <3 .COD>>>
			       <RETURN>)>>
		<RETURN .COD>)
	       (ELSE <RETURN .COD>)>>>

"NETCHR -- KLUDGE TO HANDLE NEW TELNET PROTOCOL WITHOUT
LOSSAGE WAITING FOR RESPONSE... RETURNS A CHARACTER, LIKE
READCHR, BUT IF SEES RUBOUT OR 377, READS NEXT CHAR AND THROWS
IT AWAY."

<DEFINE NETCHR (CH "AUX" C)
#DECL ((CH) CHANNEL 
       (VALUE) <OR CHARACTER FALSE> (C) CHARACTER)
 <PROG ()
	<SET C <READCHR .CH '<RETURN <>>>>
	<COND (<OR <==? <ASCII .C> *377*>
		   <==? <ASCII .C> *177*>>
	       <READCHR .CH '<RETURN <>>> ;"THROW AWAY"
	       <AGAIN>)>
	<RETURN .C>>>

"WAITRESP -- GIVEN A CHANNEL, READ UNTIL ONE OF A SUPPLIED SET OF RESPONSE
  CODES IS RECEIVED
  --RETURNS CODE RECEIVED (FIX), OR #FALSE(REASON)
  -- ARG1/ CHANNEL
  -- ARG2/ LIST OF FIXES, CODES TO WATCH FOR.  IN ALL CASES,
     RESPONSES BEGINNING WITH 0 AS A CODE ARE IGNORED"

<DEFINE WAITRESP (CHNL RESPONSES 
		  "AUX" ARESP MRESP (NUMS '"0123456789") RES) 
	#DECL ((CHNL) CHANNEL (RESPONSES) LIST (ARESP) STRING
	       (NUMS) STRING (RES VALUE) <OR FALSE FIX>
	       (MRESP) <OR LIST FALSE>)
	<TIMEOUT 60>
	<SET RES
	<REPEAT WAIT-ACT ((START-COUNTER ,CLOCK-COUNTER))
		#DECL ((WAIT-ACT) <SPECIAL ACTIVATION>
		       (START-COUNTER) <SPECIAL FIX>)
		<SETG LAST-RESP <SET ARESP <GETLINE .CHNL>>>
		<COND (<OR <NOT <MEMQ <1 .ARESP> .NUMS>>
			   <NOT <MEMQ <2 .ARESP> .NUMS>>
			   <NOT <MEMQ <3 .ARESP> .NUMS>>>
		       <AGAIN>)>
		<COND (<SET MRESP
			    <MEMQ <PARSE <STRING <1 .ARESP>
						 <2 .ARESP>
						 <3 .ARESP>>>
				  .RESPONSES>>
		       <RETURN <1 .MRESP>>)
		      (<==? <1 .ARESP> !\0>)
		      (<OR <==? <1 .ARESP> !\4> <==? <1 .ARESP> !\5>>
		       <RETURN <CHTYPE (.ARESP) FALSE>>)>>>
	<OFF ,THAN>
	.RES>

<DEFINE TIMEOUT (N)
	#DECL ((N) FIX)
	<SETG CLOCK-COUNTER 0>
	<SETUP-INT THAN "REALT" ,TIMED-OUT? 3>
	<REALTIMER .N>>

<DEFINE SETUP-INT (ATM NM FN PR "AUX" HDR)
	#DECL ((ATM) ATOM (NM) STRING (FN) APPLICABLE (PR) FIX
	       (HDR) <OR FALSE IHEADER>)
	<COND (<GASSIGNED? .ATM> <ON .NM ,.ATM .PR>)
	      (<SET HDR
		    <GET <LOOKUP .NM
				 <GET INTERRUPTS OBLIST>>
			 INTERRUPT>>
	       <SETG .ATM <HANDLER .HDR .FN>>)
	      (ELSE <SETG .ATM <ON .NM .FN .PR>>)>>

<SETG CLOCK-COUNTER 0>

<GDECL (CLOCK-COUNTER) FIX>

<DEFINE TIMED-OUT? ("AUX" W)
	#DECL ((W) ACTIVATION (START-COUNTER) FIX)
	<SETG CLOCK-COUNTER <+ ,CLOCK-COUNTER 1>>
	<COND (<AND <ASSIGNED? WAIT-ACT>
		    <LEGAL? <SET W .WAIT-ACT>>
		    <G=? <- ,CLOCK-COUNTER .START-COUNTER> 2>>
	       <OFF ,THAN>
	       <RETURN #FALSE () .W>)>>

;
"WATCH -- ERROR/INTERRUPT HANDLER FOR NET CHANNELS
  -- RETURNS FROM AN ACTIVATION (SL) IF WE ARE IN IT (SLEEPING)
"

<DEFINE WATCH (ST CH) 
	#DECL ((ST) <UVECTOR FIX FIX FIX> (CH) CHANNEL (SL) ACTIVATION)
	<COND (<OR <==? <1 .ST> 2> <==? <1 .ST> 11>>
	       <NETACC .CH>
	       <OFF "CHAR" .CH>
	       <INT-LEVEL 0>
	       <RETURN .CH .SL>)
	      (ELSE <DISMISS T>)>>

;
"ACC -- FUNCTION TO ISSUE A FTP COMMAND TO TRANSFER DATA
 -- OPENS ANOTHER SOCKET IN DIRECTION INDICATED, AND ISSUES A 'SOCK XXX'
    COMMAND OVER FTP TELNET CHANNELS.  WAITS FOR CHANNEL CONNECTION TO
    BE ESTABLISHED, AND RETURNS THE CHANNEL.  IF TROUBLE, RETURNS
    #FALSE(REASON)
 -- ARG1/ TELNET CHANNEL PAIR
    ARG2/ COMMAND LINE TO ISSUE AFTER 'SOCK' COMMAND
    ARG3/ DIRECTION -- USUALLY READ OR PRINT
    ARG4/ BYTE SIZE FOR CHANNEL OPENING

"

<DEFINE ACC (CHS COMM DIREC BYT
	     "AUX" (FTPCHAN <2 .CHS>) HAN (CL <STRING <ASCII 13> <ASCII 10>>)
		   CHANL)
	#DECL ((CHS) <LIST CHANNEL CHANNEL> (FTPCHAN) CHANNEL (HAN) HANDLER
	       (COMM DIREC CL) STRING (BYT) FIX
	       (CHANL) <OR FALSE CHANNEL>)
	<COND (<SET CHANL <OPEN .DIREC -1 -1 "NET" 0 .BYT>>
	       <COND (<=? .DIREC "PRINT"> <PUT .CHANL 13 120>)>
	       <PRINC <STRING "SOCK " <UNPARSE <7 .CHANL>> .CL> .FTPCHAN>
	       <PRINC .COMM .FTPCHAN>
	       <TERPRI .FTPCHAN>
	       <NETS .FTPCHAN>
	       <INT-LEVEL 3>
	       <SET HAN <ON "CHAR" ,WATCH 3 0 .CHANL>>
	       <COND (<OR <==? <1 <NETSTATE .CHANL>> 2>
			  <==? <1 <NETSTATE .CHANL>> 11>>
		      <NETACC .CHANL>
		      <OFF .HAN>
		      <INT-LEVEL 0>
		      .CHANL)
		     (ELSE
		      <PROG SL ()
			    #DECL ((SL) <SPECIAL ACTIVATION>)
			    <INT-LEVEL 0>
			    <SLEEP 30>
			    <OFF .HAN>
			    <CLOSE .CHANL>
			    <RETURN #FALSE ("Datachannel timed-out")>>)>)>>

"icp -- icp function, returns false or list of input and output channels
 -- arg1/ host number
    arg2/ socket to issue icp to
    val/ list of input and output channel"

<SETG SOC <UVECTOR 0>>

<DEFINE ICP (HOST FSOC "OPTIONAL" (WAITIME 20)
	     "AUX" CHICP CH1 CH2 (SOC ,SOC) SOCK COD ST)
   #DECL ((HOST FSOC COD WAITIME SOCK) FIX (CH1 CH2 CHICP) <OR CHANNEL FALSE>
	  (ST) <OR UVECTOR FALSE> (SOC) UVECTOR)
   <PROG ()
   	  <COND (<NOT <SET CHICP <OPEN "READB" -1 .FSOC "NET" .HOST 32>>>
		 <RETURN .CHICP>)>
	  <COND (<NOT <SET ST <WAIT-FOR-IT .CHICP .WAITIME>>> <RETURN .ST>)>
	  <COND (<NOT <OR <==? <SET COD <1 .ST>> 5> <==? .COD 9> <==? .COD 8>>>
		 <CLOSE .CHICP>
		 <RETURN #FALSE ("BAD ICP STATE")>)>
	  <COND (<1? <READB .SOC .CHICP>> <SET SOCK <1 .SOC>>)
		(<RETURN #FALSE ("Read of socket number failed")>)>
	  <COND (<NOT <SET CH1
			   <OPEN "READ" <+ <7 .CHICP> 2> <+ 1 .SOCK> "NET" .HOST 8>>>
		 <CLOSE .CHICP>
		 <RETURN #FALSE ("No Network Channels Available")>)>
	  <COND (<NOT <SET ST <WAIT-FOR-IT .CH1 .WAITIME>>>
		 <CLOSE .CHICP>
		 <RETURN .ST>)>
	  <COND (<NOT <OR <==? <SET COD <1 .ST>> 5> <==? .COD 9> <==? .COD 8>>>
		 <CLOSE .CHICP>
		 <CLOSE .CH1>
		 <RETURN #FALSE ("BAD ICP STATE")>)>
	  <COND (<NOT <SET CH2 <OPEN "PRINT" <+ <7 .CHICP> 3> .SOCK "NET" .HOST 8>>>
		 <CLOSE .CH1>
		 <CLOSE .CHICP>
		 <RETURN #FALSE ("No Network Channels Available")>)>
	  <PUT .CH2 13 9000000>
	  <COND (<NOT <SET ST <WAIT-FOR-IT .CH2 .WAITIME>>>
		 <CLOSE .CH1>
		 <CLOSE .CH2>
		 <RETURN .ST>)>
	  <COND (<NOT <OR <==? <SET COD <1 .ST>> 5> <==? .COD 9> <==? .COD 8>>>
		 <CLOSE .CHICP>
		 <CLOSE .CH1>
		 <CLOSE .CH2>
		 <RETURN #FALSE ("BAD ICP STATE")>)>
	  <CLOSE .CHICP>
	  (.CH1 .CH2)>>

"WAIT-FOR-IT -- wait for interrupt that indicates channel ready"

<DEFINE WAIT-FOR-IT (CH WAITIME "AUX" ST)
	#DECL ((VALUE) <OR UVECTOR FALSE> (CH) CHANNEL (WAITIME) FIX
	       (ST) <UVECTOR FIX FIX FIX>)
	<PROG ICP-WAIT ()
	      #DECL ((ICP-WAIT) <SPECIAL ACTIVATION>)
	      <INT-LEVEL 4>
	      <ON "CHAR" ,ICP-NETINT 3 0 .CH>
	      <INT-LEVEL 0>
	      <COND (<NOT <==? 4 <1 <SET ST <NETSTATE .CH>>>>>
		     <OFF "CHAR" .CH>
		     .ST)
		    (ELSE
		     <SLEEP .WAITIME>
		     <OFF "CHAR" .CH>
		     <CLOSE .CH>
		     #FALSE ("ICP timed out"))>>>

\

"ICP-NETINT -- interrupt handler for icp channels"

<DEFINE ICP-NETINT (STA CHAN "AUX" ACT) 
	#DECL ((STA) UVECTOR (VALUE) <OR UVECTOR FALSE> (CHAN) CHANNEL (ACT) ACTIVATION)
	<COND (<AND <ASSIGNED? ICP-WAIT>
		    <TYPE? <SET ACT .ICP-WAIT> ACTIVATION>
		    <LEGAL? .ACT>
		    <NOT <==? <1 .STA> 4>>>
	       <OFF "CHAR" .CHAN>
	       <DISMISS .STA .ACT 0>)>>

<ENDPACKAGE>

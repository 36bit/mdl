<RPACKAGE "SORTX">

<BLOCK (<ROOT>)>

INTERNAL-RSUBR

<NEWTYPE INTERNAL-RSUBR-TABLE UVECTOR>

<ENDBLOCK>

<ENTRY SORTX>

	<TITLE SORTX>

	<DECLARE ("VALUE" ANY ANY ANY "TUPLE" TUPLE)>

;" MUDDLE SORT ROUTINE"

<PSEUDO <SETG S1WORD 1>>

<PSEUDO <SETG SATOM *15*>>

<PSEUDO <SETG SCHSTR *20*>>

<PSEUDO <SETG INTSRT 0>>

<PSEUDO <SETG ATMSRT 1>>

<PSEUDO <SETG STRSRT 2>>

<PSEUDO <SETG XCHNG 0>>		;" FLAG SAYING AN EXCHANGE HAS HAPPENED"

<PSEUDO <SETG PLACE -1>>	;" WHERE WE ARE NOW"

<PSEUDO <SETG UTYP -2>>		;" TYPE OF UNIFORM VECTOR"

<PSEUDO <SETG SUBRS -4>>	;" IS THIS A SUBRIFYD RSUBR"

<PSEUDO <SETG PARGS 4>>

<PSEUDO <SETG PNWORD 3>>

<PSEUDO <SETG S2NWORD 5>>

<PSEUDO <SETG P2NWORD 2>>

<PSEUDO <SETG DELT -3>>		;" DIST BETWEEN COMPARERS"


	<HLRZ	O* AB		;" CHECK FOR ENOUGH ARGS">
	<CAILE	O* -4>
	<JRST	TFA>
	<GETYP	A* (AB)		;" 1ST MUST EITHER BE FALSE OR APPLICABLE">
	<CAIN	A* <TYPE-CODE FALSE>>
	<JRST	SORT1		;" FALSE*  OK">
	<PUSHJ	P* APLQ		;" IS IT APPLICABLE">
	<JRST	NAPT		;" NO*  LOSER">
SORT1	<MOVE	B* AB>
	<ADD	B* [<2 (2)>]	;" BUMP TO POINT TO MAIN ARRAY">
	<SETZB	D* E		;" 0 # OF STUCS AND LNTH">
SORT2	<GETYP	A* (B)		;" GET ITS TYPE">
	<PUSHJ	P* PTYPE		;" IS IT STRUCTURED?">
	<MOVEI	C* 1		;" CHECK TYPE OF STRUC">
	<CAIN	A* PNWORD	;" UVEC?">
	<MOVEI	C* 0		;" YUP">
	<CAIE	A* PARGS>
	<CAIN	A* P2NWORD	;" VECTOR">
	<MOVNI	C* 1>
	<JUMPG	C* WTYP>
	<PUSH	TP* (B)		;" PUSH IT">
	<PUSH	TP* 1(B)>
	<ADD	B* [<2 (2)>]	;" GO ON">
	<MOVEI	A* 1		;" DEFAULT REC SIZE">
	<PUSHJ	P* NXFIX		;" SIZE OF RECORD?">
	<HLRE	O* -2(TP)	;" -LNTH OF STUC">
	<HRRZ	A* (TP)		;" LENGTH OF REC">
	<IDIVI	O* (A)		;" DIV TO GET - # OF RECS">
	<SKIPN	D		;" PREV LENGTH EXIST?">
	<MOVE	D* 0		;" NO USE THIS">
	<CAME	O* D>
	<JRST	SLOSE0>
	<MOVEI	A* 0		;" DEF REC SIZE">
	<PUSHJ	P* NXFIX		;" AND OFFSET OF KEY">
	<SUBI	E* 1>
	<JUMPL	B* SORT2		;" GO ON">
	<HRRM	E* 4(TB)		;" SAVE THAT IN APPROPRIATE PLACE">
	<MOVE	O* 3(TB)>
	<CAMG	O* 5(TB)		;" CHECK FOR BAD OFFSET">
	<JRST	SLOSE3>

;" NOW CHECK WHATEVER STUCTURE THIS IS IS UNIFORM AND HAS GOOD ELEMENTS"

	<HLRE	B* 1(TB)		;" COMP LENGTH">
	<MOVNS	B>
	<HRRZ	C* 2(TB)		;" GET VEC/UVEC FLAG">
	<MOVEI	D* (B)>
	<ASH	B* (C)		;" FUDGE">
	<JUMPE	C* DOT3		;" SKIP FOR UVEC">
	<MOVE	O* [<1 (1)>]	;" ELSE FUDGE KEY OFFSET">
	<ADDM	O* 5(TB)>
DOT3	<HRRZ	O* 3(TB)		;" GET REC LENGTH">
	<IDIV	D* 0		;" # OF RECS">
	<JUMPN	E* SLOSE4>
	<CAIG	D* 1		;" MORE THAN 1?">
	<JRST	SORTD		;" NO*  DONE ALREADY">
	<GETYP	O* (AB)		;" TYPE OF COMPARER">
	<CAIE	O* <TYPE-CODE FALSE>	;" IF FALSE*  STRUCT MUST CONTAIN FIX* FLOAT* ATOM OR STRING">
	<JRST	SORT3		;" USER SUPPLIED COMPARER*  LET HIM WORRY">

;" NOW CHECK OUT ELEMENT TYPES"

	<JUMPN	C* SORT5		;" JUMP IF GENERAL">
	<MOVEI	D* 1(B)		;" FIND END OF VECTOR">
	<ADD	D* 1(TB)		;" D POINTS TO END">
	<PUSHJ	P* TYPCH1	;" GET TYPE AND CHECK IT">
	<JRST	SORT6>
SORT5	<MOVE	D* 1(TB)		;" POINT TO VEC">
	<ADD	D* 5(TB)		;" INTO REC TO KEY">
	<PUSHJ	P* TYPCH1>
SAMELP	<GETYP	C* -1(D)		;" GET TYPE">
	<CAIE	O* (C)		;" COMPARE TYPE">
	<JRST	SLOSE2>
	<ADD	D* 3(TB)		;" TO NEXT RECORD">
	<JUMPL	D* SAMELP>
SORT6	<CAIE	A* S1WORD	;" 1 WORDS?">
	<JRST	SORT7>
	<MOVEI	E* INTSRT>
	<MOVSI	A* *400000*	;" SET UP MASK">
SORT9	<PUSHJ	P* ISORT>
	<MOVE	A* 2(AB)>
	<MOVE	B* 3(AB)>
	<JRST	FINIS>
SORT7	<CAIE	A* SATOM		;" ATOMS?">
	<JRST	SORT8>
	<MOVE	E* [<(-3) ATMSRT>]	;" SET UP FOR ATOMS">
	<MOVE	A* [<(*430140*) 3(D)>]	;" BIT POINTER FOR ATOMS">
	<JRST	SORT9>
SORT8	<MOVE	E* [<(1) STRSRT>]	;" MUST BE STRING SORT">
	<MOVE	A* [<(*430140*) (D)>]	;" BYTE POINTER FOR STRINGER">
	<JRST	SORT9>

;" TABLES FOR RADIX SORT CHECKERS"

TST1	<PUSHJ	P* I.TST1>
	<PUSHJ	P* A.TST1>
	<PUSHJ	P* S.TST1>
TST2	<PUSHJ	P* I.TST2>
	<PUSHJ	P* A.TST2>
	<PUSHJ	P* S.TST2>
NXBIT	<ROT	A* -1>
	<PUSHJ	P* A.NXBI>
	<PUSHJ	P* S.NXBI>
PREBIT	<ROT	A* 1>
	<PUSHJ	P* A.PREB>
	<PUSHJ	P* S.PREB>
ENDTST	<SKIPGE	A>
	<TLOE	A* *40*>
	<TLOE	A* *40*>

;" INTEGER SORT SPECIFIC ROUTINES"

I.TST1	<JUMPL	A* I.TST3>
I.TST4	<TDNE	A* (D)>
	<AOS	(P)>
	<POPJ	P* >
I.TST2	<JUMPL	A* I.TST4>
I.TST3	<TDNN	A* (D)>
	<AOS	(P)>
	<POPJ	P* >

;" ATOM SORT SPECIFIC ROUTINES"

A.TST1	<MOVE	D* (D)		;" GET AN ATOM">
	<CAMG	E* D		;" SKIP IF NOT EXHAUSTED">
	<POPJ	P* >
	<TLZ	A* *40*		;" TELL A BIT HAS HAPPENED">
	<LDB	D* A		;" GET THE BIT">
	<SKIPE	D>
	<AOS	(P)		;" SKIP IF ON">
	<POPJ	P* >
A.TST2	<PUSHJ	P* A.TST1	;" USE OTHER ROUTINE">
	<AOS	(P)>
	<POPJ	P* >
A.NXBI	<TLNN	A* *770000*	;" CHECK FOR WORD CHANGE">
	<SUB	E* [<(1) 0>]	;" FIX WORD CHECKER">
	<IBP	A>
	<POPJ	P* >
A.PREB	<ADD	A* [<(*10000*) 0>]	;" AH FOR A DECR BYTE POINTER">
	<SKIPG	A>
	<CAMG	A* [<(*437777*) -1>]	;" SKIP IF BACKED OVER WORD">
	<POPJ	P* >
	<TLZ	A* *770000*	;" CLOBBER POSIT FIELD">
	<SUBI	A* 1		;" DECR WORD POS FIELD">
	<ADD	E* [<(1) 0>]	;" AND FIX WORD HACKER">
	<POPJ	P* >

;" STRING SPECIFIC SORT ROUTINES"

S.TST1	<HRLZ	O* -1(D)		;" LENGTH OF STRING">
	<IMULI	O* 7		;" IN BITS">
	<HRRI	O* -1		;" MAKE SURE BIGGER RH">
	<CAMG	O* E		;" SKIP IF MORE BITS LEFT">
	<POPJ	P* 		;" DON TSKIP">
	<TLZ	A* *40*		;" BIT FOUND">
	<HLRZ	O* (D)		;" CHECK FOR SIMPLE CASE">
	<HRRZ	D* (D)		;" POINT TO STRING">
	<CAIN	O* *010700*	;" SKIP IF HAIRY">
	<AOJA	D* S.TST3>
	<PUSH	P* A		;" SAVE BYTER">
	<MOVEI	A* *440700*	;" COMPUTE BITS NOT USED 1ST WORD">
	<SUBI	A* @ 0>
	<HLRZ	O* (P)		;" GET BIT POINTER">
	<SUBI	O* (A)		;" UPDATE POS FIELD">
	<JUMPGE	O* DOTO2		;" NO NEED FOR NEXT WORD">
	<ADD	O* [<(1) *440000*>]>
DOTO2	<MOVSS	0>
	<HRRZ	A* (P)	;" REBUILD BYTE POINTER">
	<ADDI	O* (A)>
	<LDB	O* 0		;" GET THE DAMN BYTE">
	<POP	P* A>
	<JRST	DOTT2>
S.TST3	<LDB	O* A		;" GET BYTE FOR EASY CASE">
DOTT2	<SKIPE	0>
	<AOS	(P)>
	<POPJ	P* >
S.TST2	<PUSHJ	P* S.TST1>
	<AOS	(P)>
	<POPJ	P* >
S.NXBI	<IBP	A		;" BUMP BYTER">
	<TLNN	A* *770000*	;" SKIP IF NOT END BIT">
	<IBP	A		;" SKIP END BIT (NOT USED IN ASCII STRINGS)">
	<ADD	E* [<(1) 0>]	;" COUNT BIT">
	<POPJ	P* >
S.PREB	<SUB	E* [<(1) 0>]	;" DECR CHAR COUNT">
	<ADD	A* [<(*10000*) 0>]	;" PLEASE GIVE ME A DECRBYTEPNTR">
	<SKIPG	A>
	<CAMG	A* [<(*437777*) -1>]>
	<POPJ	P* >
	<TLC	A* *450000*	;" POINT TO LAST USED BIT IN WORD">
	<SUBI	A* 1>
	<POPJ	P* >

;" SIMPLE RADIX EXCHANGE"

ISORT	<MOVE	B* 1(TB)		;" START OF VECTOR">
	<HLRE	D* B		;" COMPUTE POINTER TO END OF IT">
	<SUBM	B* D		;" FIND END">
	<MOVEI	C* (D)>
ISORT1	<PUSH	TP* (TB)>
	<PUSH	TP* C>
	<MOVE	O* C		;" SEE IF HAVE MET AT MIDDLE">
	<SUB	O* 3(TB)>
	<ANDI	O* -1>
	<CAIGE	O* (B)>
	<JRST	ISORT7		;" HAVE MET*  LEAVE">
	<PUSH	TP* (TB)		;" SAVE OTHER POINTER">
	<PUSH	TP* B>
	<INTGO>
	<MOVE	B* (TP)		;" IN CASE MOVED">
	<MOVE	C* -2(TP)>
ISORT3	<HRRZ	D* 5(TB)		;" OFFSET TO KEY">
	<ADDI	D* (B)		;" POINT TO KEY">
	<MOVEI	O* (E)>
	<ADDI	O* TST1>
	<XCT	@ 0		;" CHECK FOR LOSER">
	<JRST	ISORT4>
	<SUB	C* 3(TB)		;" IS THERE ONE TO EXCHANGE WITH">
	<HRRZ	D* 5(TB)>
	<ADDI	D* (C)>
	<MOVEI	O* (E)>
	<ADDI	O* TST2>
	<XCT	@ 0		;" SKIP IF A POSSIBLE EXCHANGE">
	<JRST	ISORT2		;" NO EXCH*  KEEP LOOKING">
	<PUSHJ	P* EXCHM		;" DO THE EXCHANGE">
ISORT4	<ADD	B* 3(TB)		;" HAVE EXCHANGED*  MOVE ON">
ISORT2	<CAME	B* C		;" MET?">
	<JRST	ISORT3		;" MORE TO CHECK">
	<MOVEI	O* (E)>
	<ADDI	O* NXBIT>
	<XCT	@ 0		;" NEXT BIT">
	<MOVE	B* (TP)		;" RESTORE TOP POINTER">
	<SUB	TP* [<2 (2)>]	;" FLUSH IT">
	<MOVEI	O* (E)>
	<ADDI	O* ENDTST>
	<XCT	@ 0>
	<JRST	ISORT6>
	<PUSHJ	P* ISORT1	;" SORT SUB AREA">
	<MOVE	C* (TP)		;" AND OTHER SUB AREA">
	<PUSHJ	P* ISORT1>
ISORT6	<MOVEI	O* (E)>
	<ADDI	O* PREBIT>
	<XCT	@ 0>
ISORT7	<MOVE	B* (TP)>
	<SUB	TP* [<2 (2)>]>
	<POPJ	P* >

;" SCHELL SORT FOR USER SUPPLIED COMPARER"

SORT3	<MOVE	A* 1 (AB)>
	<GETYP	O* (AB)>
	<CAIN	O* <TYPE-CODE RSUBR>>
	<JRST	SORTRS>
	<CAIE	O* <TYPE-CODE RSUBR-ENTRY>>
	<JRST	SORT31>
	<MOVE	A* 1 (A)>
SORTRS	<HLRZ	B* A>
	<CAIE	B* -8>
	<JRST	SORT31>
	<GETYP	O* 6 (A)>
	<CAIE	O* <TYPE-CODE INTERNAL-RSUBR-TABLE>>
	<JRST	SORT31>
	<PUSH	TP* <TYPE-WORD ATOM>>
	<MOVE	A* 1(AB)>
	<PUSH	TP* 3 (A)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* [2]>
	<PUSH	P* D>
	<MCALL	2 INTERNAL-RSUBR>
	<POP	P* D>
	<PUSH	P* B>
	<SKIPA>
SORT31	<PUSH	P* [0]>
	<ADDI	D* 1>
	<ASH	D* -1		;" COMPUTE INITIAL D">
	<PUSH	P* D		;" AND SAVE IT">
	<PUSH	P* [0]		;" MAY HOLD UTYPE OF VECTOR">
	<HRRZ	O* (TB)		;" 0 NON ZERO MEANS GEN VECT">
	<JUMPN	O* SSORT1	;" DONT COMPUTE UTYPE">
	<HLRE	C* 1(TB)>
	<HRRZ	D* 1(TB)		;" FIND TYPE">
	<SUBI	D* (C)>
	<GETYP	D* (D)>
	<MOVSM	D* (P)		;" AND SAVE">
SSORT1	<PUSH	P* [0]		;" CURRENT PLACE IN VECTOR">
	<PUSH	P* [0]		;" EXCHANGE FLAG">
	<PUSH	TP* [0]>
	<PUSH	TP* [0]>

;" OUTER LOOP STARTS HERE"

	<SKIPE	SUBRS (P)>
	<JRST	OUTRL1>		; "IF SUBRFIED RSUBR GO TO SPECIAL LOOP"

OUTRLP	<SETZM	XCHNG(P)	;" NO EXHCANGE YET">
	<SETZM	PLACE(P)>
INRLP	<PUSH	TP* (AB)		;" PUSH USER COMPARE FCN">
	<PUSH	TP* 1(AB)>
	<MOVE	C* PLACE(P)	;" GET CURRENT PLACE">
	<ADD	C* 1(TB)		;" ADD POINTER TO VEC IN">
	<ADD	C* 5(TB)		;" OFFSET TO KEY">
	<PUSHJ	P* GETELM>
	<MOVE	D* 3(TB)>
	<IMUL	D* DELT(P)	;" TIMES WORDS PER REC">
	<ADD	C* D>
	<PUSHJ	P* GETELM>
	<MCALL	3 APPLY		;" APPLY IT">
	<GETYP	O* A		;" TYPE OF RETURN">
	<CAIN	O* <TYPE-CODE FALSE>	;" SKIP IF MUST CHANGE">
	<JRST	INRLP1>
	<MOVE	C* 1(TB)		;" POINT TO START">
	<ADD	C* PLACE(P)>
	<MOVE	B* 3(TB)>
	<IMUL	B* DELT(P)>
	<ADD	B* C>
	<PUSHJ	P* EXCHM		;" EXCHANGE THEM">
	<SETOM	XCHNG(P)	;" SAY AN EXCHANGE TOOK PLACE">
INRLP1	<MOVE	C* 3(TB)		;" GET OFFSET">
	<ADDB	C* PLACE(P)>
	<MOVE	D* 3(TB)>
	<IMUL	D* DELT(P)>
	<ADD	C* D		;" CHECK FOR OVERFLOW">
	<ADD	C* 1(TB)>
	<JUMPL	C* INRLP>
	<SKIPE	XCHNG(P)	;" ANY EXCHANGES?">
	<JRST	OUTRLP		;" YES*  RESET PLACE AND GO">
	<SOSG	D* DELT(P)	;" SKIP IF DIST WAS 1">
	<JRST	SORTD>
	<ADDI	D* 2		;" COMPUTE NEW DIST">
	<ASH	D* -1>
	<MOVEM	D* DELT(P)>
	<JRST	OUTRLP>
SORTD	<MOVE	A* 2(AB)		;" DONE*  RET 1ST STRUC">
	<MOVE	B* 3(AB)>
	<JRST	FINIS>


OUTRL1	<SETZM	XCHNG(P)	;" NO EXHCANGE YET">
	<SETZM	PLACE(P)>
IINRLP	<MOVE	C* PLACE(P)	;" GET CURRENT PLACE">
	<ADD	C* 1(TB)		;" ADD POINTER TO VEC IN">
	<ADD	C* 5(TB)		;" OFFSET TO KEY">
	<PUSHJ	P* GETELM>
	<MOVE	D* 3(TB)>
	<IMUL	D* DELT(P)	;" TIMES WORDS PER REC">
	<ADD	C* D>
	<PUSHJ	P* GETELM>
	<PUSHJ	P* @ SUBRS (P)>
	<GETYP	O* A		;" TYPE OF RETURN">
	<CAIN	O* <TYPE-CODE FALSE>	;" SKIP IF MUST CHANGE">
	<JRST	IINRLP1>
	<MOVE	C* 1(TB)		;" POINT TO START">
	<ADD	C* PLACE(P)>
	<MOVE	B* 3(TB)>
	<IMUL	B* DELT(P)>
	<ADD	B* C>
	<PUSHJ	P* EXCHM		;" EXCHANGE THEM">
	<SETOM	XCHNG(P)	;" SAY AN EXCHANGE TOOK PLACE">
IINRLP1	<MOVE	C* 3(TB)		;" GET OFFSET">
	<ADDB	C* PLACE(P)>
	<MOVE	D* 3(TB)>
	<IMUL	D* DELT(P)>
	<ADD	C* D		;" CHECK FOR OVERFLOW">
	<ADD	C* 1(TB)>
	<JUMPL	C* IINRLP>
	<SKIPE	XCHNG(P)	;" ANY EXCHANGES?">
	<JRST	OUTRL1		;" YES*  RESET PLACE AND GO">
	<SOSG	D* DELT(P)	;" SKIP IF DIST WAS 1">
	<JRST	SORTD>
	<ADDI	D* 2		;" COMPUTE NEW DIST">
	<ASH	D* -1>
	<MOVEM	D* DELT(P)>
	<JRST	OUTRL1>
	<JRST	SORTD>

;" ROUTINE TO GET NEXT ARG IF ITS FIX"

NXFIX	<JUMPGE	B* NXFIX1	;" NONE LEFT*  USE DEFAULT">
	<GETYP	O* (B)		;" TYPE">
	<CAIE	O* <TYPE-CODE FIX>		;" FIXED?">
	<JRST	NXFIX1		;" NO*  USE DEFAULT">
	<MOVE	A* 1(B)		;" GET THE NUMBER">
	<ADD	B* [<2 (2)>]	;" BUMP TO NEXT ARG">
NXFIX1	<HRLI	C* <TYPE-CODE FIX>>
	<TRNE	C* -1		;" SKIP IF UV">
	<ASH	A* 1		;" FUDGE FOR VEC/UVEC">
	<HRLI	A* (A)>
	<PUSH	TP* C>
	<PUSH	TP* A>
	<POPJ	P* >

GETELM	<SKIPN	A* UTYP -1 (P)	;" SKIP IF UVECT">
	<MOVE	A* -1(C)		;" GGET GEN TYPE">
	<PUSH	TP* A>
	<PUSH	TP* (C)>
	<POPJ	P* >
TYPCH1	<GETYP	A* -1(D)		;" GET TYPE">
	<MOVEI	O* (A)		;" SAVE IN 0">
	<PUSHJ	P* SAT		;" AND SAT">
	<CAIE	A* SCHSTR	;" STRING">
	<CAIN	A* SATOM>
	<POPJ	P* >
	<CAIN	A* S1WORD	;" 1-WORD GOODIE">
	<POPJ	P* >
	<JRST	SLOSE1>

;" HERE TO DO EXCHANGE"

EXCHM	<PUSH	P* E>
	<PUSH	P* A		;" SAVE VITAL ACS">
	<PUSH	P* B>
	<PUSH	P* C>
	<SUB	B* 1(TB)		;" COMPUTE RECORD #">
	<HLRZS	B		;" TO RH">
	<HRRZ	O* 3(TB)		;" GET REC LENGTH">
	<IDIV	B* 0		;" DIV BY REC LENGTH">
	<MOVE	C* (P)>
	<SUB	C* 1(TB)		;" SAME FOR C">
	<HLRZS	C>
	<IDIV	C* 0		;" NOW HAVE OTHER RECORD">
	<HRRE	D* 4(TB)		;" - # OF STUCS">
	<MOVSI	D* (D)		;" MAKE AN AOBJN POINTER">
	<HRRI	D* (TB)		;" TO TEMPPS">
RECLP	<HRRZ	O* 3(D)		;" GET REC LENGTH">
	<MOVN	E* 3(D)		;" NOW AOBJN TO REC">
	<MOVSI	E* (E)>
	<HRR	E* 1(D)>
	<MOVEI	A* (C)		;" COMP START OF REC">
	<IMUL	A* 0		;" TIMES REC LENGTH">
	<ADDI	E* (A)>
	<MOVEI	A* (B)>
	<IMUL	A* 0>
	<ADD	A* 1(D)		;" POINT TO OTHER RECORD">
EXCHLP	<EXCH	O* (A)>
	<EXCH	O* (E)>
	<EXCH	O* (A)>
	<ADDI	A* 1>
	<AOBJN	E* EXCHLP>
	<ADD	D* [<(1) 6>]	;" TO NEXT STRUC">
	<JUMPL	D* RECLP		;" IF MORE">
	<POP	P* C>
	<POP	P* B>
	<POP	P* A>
	<POP	P* E>
	<POPJ	P* >


;"ERROR COMMENTS FOR SOME PRIMITIVES"

OUTRNG	<ERRUUO* <MQUOTE OUT-OF-BOUNDS!-ERRORS>>

WRNGUT	<ERRUUO* <MQUOTE UNIFORM-VECTORS-TYPE-DIFFERS!-ERRORS>>

SLOSE0	<ERRUUO* <MQUOTE VECTOR-LENGTHS-DIFFER!-ERRORS>>

SLOSE1	<ERRUUO* <MQUOTE KEYS-WRONG-TYPE!-ERRORS>>

SLOSE2	<ERRUUO* <MQUOTE KEY-TYPES-DIFFER!-ERRORS>>

SLOSE3	<ERRUUO* <MQUOTE KEY-OFFSET-OUTSIDE-RECORD!-ERRORS>>

SLOSE4	<ERRUUO* <MQUOTE NON-INTEGER-NO.-OF-RECORDS!-ERRORS>>

	<END>

<ENDPACKAGE>

'<PCODE "1NETFTP">

<PACKAGE "NETFTP"> 

<ENTRY CONNECT ACC ICP WAITRESP LAST-RESP SOAK UNSOAK> 

<ENTRY TIMEOUT WAIT-ACT CLOCK-COUNTER START-COUNTER> 

<GDECL (SOAK?) <OR 'T FALSE>> 

"SOAK AND UNSOAK -- ENABLE AND DISABLE SCRIPTING OF FTP TRANSACTIONS" 

<SETG SOAK  %<RSUBR!- '[ %<PCODE!- "1NETFTP" 0> SOAK #DECL ("VALUE" <OR ATOM 
FALSE>) T %<RGLOC SOAK? T> (300) "USER " (230 200 330) "PASS " (230 200 331) 
"ACCT " (230 200) "TYPE " (200) "BYTE " "MODE " CHANNEL-CLOSED GETLINE OUTCHAN 
"FTP: " "0123456789" START-COUNTER %<RGLOC CLOCK-COUNTER T> (FIX) WAIT-ACT (
ACTIVATION) %<RGLOC LAST-RESP T> %<RGLOC THAN T> THAN "REALT" %<RGLOC TIMED-OUT?
T> INTERRUPTS OBLIST INTERRUPT "CHAR" SL "NET" "PRINT" "SOCK " %<RGLOC WATCH T> 
#FALSE ("Datachannel timed-out") %<RGLOC SOC T> "READB" #FALSE ("BAD ICP STATE")
 #FALSE ("Read of socket number failed") "READ" #FALSE (
"No Network Channels Available") ICP-WAIT %<RGLOC ICP-NETINT T> #FALSE (
"ICP timed out")]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,SOAK PGLUE ![1073741823 -1 -256 0!]>> 


<SETG UNSOAK %<RSUBR-ENTRY '[SOAK UNSOAK #DECL ("VALUE" <OR ATOM FALSE>)] 12>> 

<SETG SOAK? T> 

"CONNECT -- CONNECT TO FTP SERVER AT A SPECIFIED HOST
  ARG1 -- HOST (FIX)
  ARG2 -- ACCESS INSTRUCTIONS, OR FALSE.  IF TRUE, MUST BE LIST
   OF ITEMS, AS FOLLOWS:
	1/ STRING, ARG FOR USER COMMAND
	2/ STRING, TO BE USED AS ARG TO PASSWORD COMMAND, IF EMPTY
		OR FALSE, NONE WILL BE ISSUED
	3/ STRING, TO BE USED AS ARG TO ACCOUNT COMMAND
  ARG3 -- TYPE OF TRANSFER (STRING) FALSE--NONE
  ARG4 -- BYTE SIZE (FIX) FALSE--NONE
  ARG5 -- MODE OF TRANSFER (STRING) FALSE--NONE

 -- RETURNS LIST OF INPUT AND OUTPUT CHANNELS, OR #FALSE(REASON.STRING)" 

<SETG CONNECT %<RSUBR-ENTRY '[SOAK CONNECT #DECL ("VALUE" <OR FALSE <LIST 
CHANNEL CHANNEL>> FIX <LIST [3 STRING]> <OR STRING FALSE> <OR FIX FALSE> <OR 
STRING FALSE>)] 24>> 

"GETLINE -- GET A RESPONSE FROM FTP CONNECTION, INCLUDING CONTINUATION LINES" 

"NETCHR -- KLUDGE TO HANDLE NEW TELNET PROTOCOL WITHOUT
LOSSAGE WAITING FOR RESPONSE... RETURNS A CHARACTER, LIKE
READCHR, BUT IF SEES RUBOUT OR 377, READS NEXT CHAR AND THROWS
IT AWAY." 

"WAITRESP -- GIVEN A CHANNEL, READ UNTIL ONE OF A SUPPLIED SET OF RESPONSE
  CODES IS RECEIVED
  --RETURNS CODE RECEIVED (FIX), OR #FALSE(REASON)
  -- ARG1/ CHANNEL
  -- ARG2/ LIST OF FIXES, CODES TO WATCH FOR.  IN ALL CASES,
     RESPONSES BEGINNING WITH 0 AS A CODE ARE IGNORED" 

<SETG WAITRESP %<RSUBR-ENTRY '[SOAK WAITRESP #DECL ("VALUE" <OR FALSE FIX> 
CHANNEL LIST)] 476>> 

<SETG TIMEOUT %<RSUBR-ENTRY '[SOAK TIMEOUT #DECL ("VALUE" ANY FIX)] 654>> 

<SETG CLOCK-COUNTER 0> 

<GDECL (CLOCK-COUNTER) FIX> 

<SETG TIMED-OUT? %<RSUBR-ENTRY '[SOAK TIMED-OUT? #DECL ("VALUE" ANY)] 756>> 

<SETG WATCH %<RSUBR-ENTRY '[SOAK WATCH #DECL ("VALUE" ANY <UVECTOR FIX FIX FIX> 
CHANNEL)] 810>> 

<SETG ACC %<RSUBR-ENTRY '[SOAK ACC #DECL ("VALUE" ANY <LIST CHANNEL CHANNEL> 
STRING STRING FIX)] 851>> 

"icp -- icp function, returns false or list of input and output channels
 -- arg1/ host number
    arg2/ socket to issue icp to
    val/ list of input and output channel" 

<SETG SOC <UVECTOR 0>> 

<SETG ICP %<RSUBR-ENTRY '[SOAK ICP #DECL ("VALUE" <OR FALSE <LIST CHANNEL 
CHANNEL>> FIX FIX "OPTIONAL" FIX)] 1018>> 

"WAIT-FOR-IT -- wait for interrupt that indicates channel ready" 

\ 

"ICP-NETINT -- interrupt handler for icp channels" 

<SETG ICP-NETINT %<RSUBR-ENTRY '[SOAK ICP-NETINT #DECL ("VALUE" <OR FALSE 
UVECTOR> UVECTOR CHANNEL)] 1322>> 

<ENDPACKAGE> 

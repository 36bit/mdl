TITLE MAIN LOOP AND GLOBALLY REFERENCED SUBROUTINES
RELOCA
MAIN==1	;THIS INCLUDES ONCE ONLY CODE

.GLOBAL PATCH,IVCELL,IPLIST,ISPLIST,IPNAME,LERR,LPROG,PIDSTO,PROCID,SPTIME,GCPDL,INTFLG,


.INSRT MUDDLE >

ITSMSK==200001

VECTGO
TVBASE":	BLOCK TVLNT
	TVLNT+1,,0
TVLOC=TVBASE



;INITIAL TYPE TABLE

TYPVLC":	BLOCK 2*NUMPRI+2
	2*NUMPRI+1+2,,0

ADDTV TVEC,[-2*NUMPRI-2,,TYPVLC]
TYPVEC==TVOFF-1
;ENTRY FOR ROOT,TTICHN,TTOCHN

ADDTV TCHAN,0
TTICHN==TVOFF-1

ADDTV TCHAN,0
TTOCHN==TVOFF-1

ADDTV TOBLS,0
ROOT==TVOFF-1
;PROCESS VECTOR FOR GARBAGE COLLECTOR PROCESS

GCPVP:	BLOCK PVLNT*2
	PVLNT*2+1,,0

VECRET

;INITIAL PROCESS VECTOR

PVBASE":	BLOCK PVLNT*2
	PVLNT*2+1,,0
PVLOC==PVBASE


;ENTRY FOR PROCESS I.D.

	ADDPV TFIX,1,PROCID
;THE FOLLOWING IRP MAKES SPACE FO9 SAVED ACS

IRP A,,[0,A,B,C,D,E,PVP,TVP,PP,AB,AP,TB,TP,SP,P]B,,[0
0,0,0,0,0,TPVP,TTVP,0,TAB,TAP,TTB,TTP,TSP,TPDL]
ADDPV B,0,A!STO
TERMIN

;ADD LAST ERROR AND PROG GOODIE

ADDPV TTB,0,LERR

ADDPV TTB,0,LPROG



ADDPV TPDL,0,PINIT
ADDPV TTP,0,TPINIT
ADDPV TAP,0,APINIT
ADDPV TSP,0,SPINIT




;MAIN LOOP AND STARTUP

;SECONDARY STARTUP

START:
	.SUSET [.SMASK,,[ITSMSK]]
	XCT INIT
	PUSHJ P,ICLOS"
	PUSHJ P,OCLOS"
MIO:	MOVEI B,[ASCIZ /MUDDLE IN OPERATION./]
	PUSHJ P,MSGTYP	;TYPE OUT TO USER

RESTART:		;RESTART A PROCESS
STP:
	MOVE P,PINIT+1(PVP)	;SET UP ML PDL
	MOVE TP,TPINIT+1(PVP)	;POINTERS FROM
	MOVE AP,APINIT+1(PVP)	;THE PROCESS VECTOR
	MOVE E,SPINIT+1(PVP)
	PUSHJ P,SPECSTORE	;RESTORE THE SP
	MOVEI AB,1(AP)	;INITIAL AB
	MOVE TB,TP	;AND TB
	ADD TB,[3,,3]
	HLLZS LERR (PVP)	;CLEAR THE ERROR SYSTEM
	SETZM LERR+1(PVP)	
	SETZM LPROG+1(PVP)	;AND THE PROG SYSTEM
	PUSH TP,[TENTRY,,LISTEN]
	PUSH TP,[TOPLEVEL]
	JRST LISTEN	;FALL INTO LISTENING LOOP

MFUNCTION LISTEN,SUBR

	ENTRY

	MOVEI A,0	;DON'T PRINT ERROR MESSAGE
	JRST ER1

MFUNCTION ERROR,SUBR

	ENTRY
	MOVNI A,1	;PRINT ERROR FLAG

ER1:	PUSH TP,$TATOM	;BIND CHANNELS,OBLIST AND EOF
	PUSH TP,MQUOTE INCHAN
	PUSH AP,TTICHN(TVP)	;TYPE OF TTY CHAN
	PUSH AP,TTICHN+1(TVP)	;AND ITS VALUE

	PUSH TP,$TATOM
	PUSH TP,MQUOTE OUTCHN
	PUSH AP,TTOCHN(TVP)	;TYPE OF OUT CHNA
	PUSH AP,TTOCHN+1(TVP)	;AND IT S VAL

	PUSH TP,$TATOM
	PUSH TP,MQUOTE OBLIST
	PUSH AP,ROOT(TVP)	;DEFAULT OBLIST TYPE
	PUSH AP,ROOT+1(TVP)	;AND VALUE

	PUSH TP,$TATOM
	PUSH TP,MQUOTE EOF
	PUSH AP,$TLIST	;DEFAULT EOF- NIL
	PUSH AP,[0]

	PUSH P,A	;SAVE FLAG ABOUT ERROR PRINT
	PUSH P,[4]	;FOR SPECBIND
	PUSHJ P,SPECBIND	;BIND THE CRETANS
	SUB P,[1,,1]	;REMOVE THE COUNTER
	POP P,A	;RESTORE SWITHC
	JUMPE A,NOERR	;IF 0, DONT PRINT ERROR MESS
	PUSH AP,$TATOM
	PUSH AP,MQUOTE *ERROR*
	MCALL 1,PRINT	;PRINT THE MESSAGE
NOERR:	MOVE C,AB	;GET A COPY OF AB

ERRLP:	JUMPGE C,LEVPRT	;IF NONE, RE-ENTER READ-EVAL-PRINT LOOP
	PUSH AP,(C)	;GET AN ARGS TYPE
	PUSH AP,1(C)	;AND VALUE
	PUSH TP,$TAB
	PUSH TP,C
	MCALL 1,PRINT
	POP TP,C
	SUB TP,[1,,1]
	ADD C,[2,,2]	;BUMP SAVED AB
	JRST ERRLP	;AND CONTINUE

LEVPRT:	PUSH AP,$TATOM
	PUSH AP,MQUOTE LISTENING-AT-LEVEL
	MCALL 1,PRINT	;PRINT LEVEL
	PUSH AP,$TFIX	;READY TO PRINT LEVEL
	HRRZ A,LERR(PVP)	;GOBBLE LEVEL
	PUSH AP,A
	MCALL 1,PRIN1	;PRINT WITHOUT SPACES ETC.
	PUSH AP,$TATOM	;NOW PROCESS
	PUSH AP,MQUOTE [ PROCESS ]
	MCALL 1,PRINC	;DONT SLASHIFY SPACES
	PUSH AP,PROCID(PVP)	;NOW ID
	PUSH AP,PROCID+1(PVP)
	MCALL 1,PRIN1
	PUSH TP,LERR(PVP)	;PUSH ERROR STATE
	PUSH TP,LERR+1(PVP)
	MOVEM TB,LERR+1(PVP)	;NOW CLOBBER
	AOS LERR(PVP)	;AND LEVEL INCREASE
	
MAINLP:	PUSHJ	P,CRLF	;TYPE OUT A CARRIAGE RETURN, LINEFEED
	MCALL	0,READ
	PUSH	AP,A
	PUSH	AP,B
	MCALL	1,EVAL
	PUSH	AP,A
	PUSH	AP,B
	MCALL	1,PRINT
	JRST	MAINLP


TOPLEVEL:
	PUSH TP,[TOPLEVEL]
	JRST LEVPRT

;FUNCTION TO DO ERROR RETURN

MFUNCTION ERRET,SUBR

	ENTRY
	CAML AB,[-1,,0]	;CHECK FOR AN ARG
	JRST STP	;NO ARGS, RESTART PROCESS
	CAML AB,[-3,,0]	;FRAME SUPPLIED
	JRST ERRET1	;NO
	PUSHJ P,FRCHECK	;CHECK IT OUT
ERRET1:
	MOVE C,LERR+1(PVP)	;GET OLD TB
	SKIPN 1(C)	;TOP LEVEL?
	JRST ENDRET	;YES -- NO MESSAGE
	HRRZ B,(C)	;NO -- GET LEVEL NUMBER
	PUSH AP,$TFIX
	PUSH AP,B
	MCALL 1,PRINT
	PUSH AP,$TATOM
	PUSH AP,MQUOTE *PROCEEDED*
	MCALL 1,PRIN1
ENDRET:
	MOVE TB,LERR+1(PVP)	;RESET TB
	MOVE A,(TB)	;GET LAST LEVEL
	MOVEM A,LERR(PVP)	;AND CLOBBER IT AWAY
	MOVE B,1(TB)
	MOVEM B,LERR+1(PVP)
	CAMGE AB,[-3,,0]	;FRAME SUPPLIED?
	JRST ERRET2
RTA:	MOVE A,(AB)
	MOVE B,1(AB)	;AND GET RETURNED VALUE
	JRST FINIS
ERRET2:
	MOVE A,3(AB)
	MOVE TB,TBSAVE+1(A)
	JRST RTA

MFUNCTION FRAME,SUBR
	ENTRY
	JUMPL AB,FRARG	;FRAME ARGUMENT SUPPLIED?
	MOVE B,LERR+1(PVP)	;NO -- GET ERROR LEVEL
	MOVE A,LERR(PVP)	
	JRST FINIS
FRARG:
	PUSHJ P,FRCHECK	;CHECK OUT ARGUMENT
	MOVE A,TBSAVE(C)	;GET PREVIOUS FRAME
	MOVE B,TBSAVE+1(C)	;POINTER
	JRST FINIS	;RETURN IT

TBSAVE==-12


MFUNCTION ARGS,SUBR
	ENTRY 1
	PUSHJ P,FRCHECK	;CHECK OUT ARGUMENT
	MOVE A,ABSAVE (C)	;GET POINTER TO
	MOVE B,ABSAVE +1(C)	;TUPLE OF ARGUMENTS
	JRST FINIS	;AND RETURN IT

ABSAVE==-6


MFUNCTION ENV,SUBR
	ENTRY 1
	PUSHJ P,FRCHECK	;CHECK OUT ARGUMENT
	MOVE C,TBSAVE+1(C)
	MOVE A,SPSAVE(C)	;GET ENVIRONMENT
	MOVE B,SPSAVE +1(C)	;POINTER AND
	JRST FINIS	;RETURN IT

SPSAVE==-14


MFUNCTION FUNCT,SUBR
	ENTRY 1
	PUSHJ P,FRCHECK
	MOVE B,TBSAVE+1(C)
	HRRZ C,-2(B)	;GET POINTER TO FUNCTION
	MOVSI A,TATOM	;AND RETURN A POINTER TO 
	MOVE B,@-1(C)	;ITS NAME
	JRST FINIS

FRCHECK:
	HLRZ A,-1(AP)	;CHECK TYPE OF ARGUMENT
	CAIE A,TTB	;TO MAKE SURE IT IS A FRAME
	JRST BADFRAME	;LOSER
	MOVE C,(AP)	;GET POINTER TO FRAME
	MOVE D,-1(C)	;CHECK POPJ WORD
	CAIN D,TOPLEVEL	;TO SEE IF AT TOP LEVEL
	JRST TOPLOSE	;IF SO -- LOSE
	POPJ P,	;IF NOT -- WIN


BADFRAME:
	PUSH AP,$TATOM
	PUSH AP,MQUOTE BAD-FRAME
	MOVEI A,1
	JRST CALER"

TOPLOSE:
	PUSH AP,$TATOM
	PUSH AP,MQUOTE TOP-LEVEL
	MOVEI A,1
	JRST CALER


;CREATES CROCKED GC PROCESS

SETUP:	MOVSI A,(JFCL)	;RESET INIT
	MOVEM A,INIT
	MOVE P,GCPDL	;SETUP GC PDL
	MOVE TP,[-ITPLNT-1,,TPBASE]
	MOVE TB,TP
	MOVE AP,[-IAPLNT-1,,APBASE-1]
	MOVE TVP,[-TVLNT,,TVBASE]	;SETUP TRANSFER VECTOR
	MOVE PVP,[-PVLNT*2,,GCPVP]	;AND PROCESS VECTOR
	MOVEI A,(PVP)	;SETUP BLT
	HRLI A,PVBASE	;WHERE TO BLT FROM
	BLT A,PVLNT*2-1(PVP)	;PRESET THE VECTOR
	PUSHJ P,ICR	;CREATE INITIAL PROCESS
	JSP A,SWAP	;SWAP IN THIS NEW PROCESS
	PUSHJ P,OBLMAK"	;MAKE THE INITIAL OBLIST

;SETUP A CALL TO OPEN THE TTY CHANNEL

	IRP A,,[[READ,TCHRS],[INPUT,TCHRS],[MUDDLE,TCHSTR],[TTY,TCHRS]]
	IRP B,C,[A]
	PUSH AP,$!C
	PUSH AP,CHQUOTE B
	.ISTOP
	TERMIN
	TERMIN

	MCALL 4,FOPEN	;OPEN INPUTCHANNEL
	MOVEM B,TTICHN+1(TVP)	;SAVE IT

;SETUP CALL TO OPEN OUTPUT TTY CHANNNEL

	IRP A,,[[PRINT,TCHRS],[OUTPUT,TCHSTR],[MUDDLE,TCHSTR],[TTY,TCHRS]]
	IRP B,C,[A]
	PUSH AP,$!C
	PUSH AP,CHQUOTE B
	.ISTOP
	TERMIN
	TERMIN

	MCALL 4,FOPEN	;OPEN THE OUT PUT CHANNEL
	MOVEM B,TTOCHN+1(TVP)	;SAVE IT
	JRST MIO	;AND GO START IT UP

;THIS SUBROUTINE ALLOCATES A NEW PROCESS TAKES NO ARGS AND
;IS CALLED BY PUSHJ P,. RETURNS IN A AND B A NEW PROCESS.

ICR:	MOVEI A,PVLNT	;SETUP CALL TO VECTOR FOR PVP
	PUSHJ P,IVECT	;GOBBLE A VECTOR
	HRLI C,PVBASE	;SETUP A BLT POINTER
	HRRI C,(B)	;GET INTO ADDRESS
	BLT C,PVLNT*2-1(B)	;COPY A PROTOTYPE INTO NEW PVP
	PUSH TP,A	;SAVE THE RESULTS OF VECTOR
	PUSH TP,B

	MOVEI A,SPLNT	;NOW ALLOCATE A SPECIAL PDL
	PUSHJ P,IVECT
	ADD B,[6*PROLOC-1,,6*PROLOC-1]	;ALLOCATE LOCAL SPACE
	PUSH B,$TSKIP	;MARK WITH A SKIP
	PUSH B,[0]

	MOVE C,(TP)	;RE-GOBBLE NEW PVP
	MOVEM B,SPINIT+1(C)	;STORE SP INTO ITS HOME
	MOVEM B,SPSTO+1(C)	;AND MAKE SPECSTORE WIN ON START UP

	MOVE B,P1PDL	;WILL GET A HOMOGENOUS VECTOR LATER
	MOVEM B,PINIT+1(C)	;SAVE IT ALSO
	MOVEM B,PSTO+1(C)	;STORE IN ALL HOMES

	MOVEI A,TPLNT	;PREPARE TO CREATE A TEMPORARY PDL
	PUSHJ P,IVECT	;GET THE TEMP PDL
	MOVE C,(TP)	;RE-GOBBLE NEW PVP
	MOVEM B,TBSTO+1(C)	;SETUP BASE
	SUB B,[1,,1]	;FIX FOR STACK
	MOVEM B,TPINIT+1(C)

	MOVEM B,TPSTO+1(C)
	MOVEI A,APLNT	;NOW FOR THE AP
	PUSHJ P,IVECT
	MOVE C,(TP)	;RE-GOBBLE NEW PVP
	HRRZM B,ABSTO+1(C)	;MAKE A UESFUL AB
	SUB B,[1,,1]	;FIX FOR STACK
	MOVEM B,APINIT+1(C)
	MOVEM B,APSTO+1(C)
	ADDI B,APLNT*2+1	;POINTER TO THE END OF THE AP
	HRRM B,ABSTO(C)	;SO AB'S WIN IN THE GC

	MOVEM C,PVPSTO+1(C)	;SAVE THE NEW PVP ITSELF
	MOVEM TVP,TVPSTO+1(C)	;AND THE GOOD OLD TRANSFER VECTOR
	AOS A,SPTIME	;GOBBLE A UNIQUE PROCESS I.D.
	MOVEM A,PROCID+1(C)	;SAVE THAT ALSO

	MOVSI A,TPVP	;CLOBBER THE TYPE
	MOVE B,(TP)	;AND POINTER TO PROCESS
	SUB TP,[2,,2]
	POPJ P,

;MINI ROUTINE TO CALL VECTOR WITH COUNT IN A

IVECT:	PUSH AP,$TFIX
	PUSH AP,A
	MCALL 1,VECTOR	;GOBBLE THE VECTOR
	POPJ P,


;SUBROUTINE TO SWAP A PROCESS IN
;CALLED WITH JSP A,SWAP AND NEW PVP IN B

SWAP:			;FIRST STORE ALL THE ACS

	IRP A,,[0,A,B,C,D,E,PVP,TVP,PP,AB,AP,TB,TP,SP,P]
	MOVEM A,A!STO+1(PVP)
	TERMIN

	EXCH B,PVP	;GET NEW PVP AND RETURN OLD

	;NOW RESTORE NEW PROCESSES AC'S

	IRP A,,[0,C,D,E,PVP,TVP,PP,AB,AP,TB,TP,SP,P]
	MOVE A,A!STO+1(PVP)
	TERMIN

	JRST (A)	;AND RETURN

SAVCAL":	0
	PUSH TP,$TSP
	PUSH TP,SP
	PUSH TP,$TTB
	PUSH TP,TB
	PUSH TP,$TAP
	PUSH TP,AP
	PUSH TP,ABSTO(PVP)
	PUSH TP,AB
	PUSH TP,$TPDL
	PUSH TP,P
	MOVE TB,TP
	ADD TB,[3,,3]
	JRST @SAVCAL

;RESTORE PROGRAM


RESCAL":	0
	SUB TP,[1,,1]
	MOVE P,(TP)
	MOVE AB,-2(TP)
	MOVE AP,-4(TP)
	MOVE TB,-6(TP)
	MOVE E,-10(TP)
	SUB TP,[12,,12]
	PUSHJ P,SPECSTORE"
	JRST @RESCAL


;SUBROUTINE FINISHER

FINIS:	MOVE TP,TB	;RESTORE TEMP STACK POINTER
	SUB TP,[1,,1]
	POPJ TP,

;ATOM PRIMITIVES

MFUNCTION PNAME,SUBR
	ENTRY 1	;ONE ARG
	MOVE A,(AB)	;GET THE TYPE FO THE ARG
	CAME A,$TATOM	;IS IT ATOM
	JRST NOTATOM	;NO, LOSE
	MOVE B,(AB)1	;NOW GET REAL ATOM
	PUSHJ P,IPNAME	;CALL THE PRIMITIVE
	JRST FINIS

IPNAME:	MOVE A,4(B)	;GET PNAME TYPE
	MOVE B,5(B)	;AND VALUE
	POPJ P,

MFUNCTION PLIST,SUBR
	ENTRY 1	;CHECK NUM ARGS
	MOVE A,(AB)	;NOW TYPE OF SAME
	CAME A,$TATOM	;IS IT ATOM?
	JRST NOTATOM	;LOSE
	MOVE B,1(AB)	;GET REAL ATOM POINTER
	PUSHJ P,IPLIST	;GOTO PRIMITIVE
	JRST FINIS

IPLIST:	MOVE A,2(B)	;GET TYPE OF PLIST
	MOVE B,3(B)	;AND ITS VALUE
	POPJ P,

ISPLIST:
	MOVEM B, 3(A)	;MOVE B INTO PLIST OF A
	POPJ P,

MFUNCTION VCELL,SUBR
	ENTRY 1
	MOVE A,(AB)
	CAME A,$TATOM	;IS IT ATOM
	JRST NOTATOM
	MOVE B,1(AB)	;GET REAL ATOM
	PUSHJ P,IVCELL
	JRST FINIS

IVCELL:	MOVE A,(B)	;TYPE OF VALUE
	MOVE B,1(B)	;AND VALUE
CPOPJ:	POPJ P,

;INTERNAL FUNCTION TO GET STRAGE ALLOCATION TYPE
;GETS THE TYPE CODE IN A AND RETURNS SAT IN A.

SAT:	LSH A,1	;TIMES 2 TO REF VECTOR
	HRLS A  	;TO BOTH HALVES TO HACK AOBJN POINTER
	ADD A,TYPVEC+1(TVP)	;ACCESS THE VECTOR
	HRR A,(A)	;GET PROBABLE SAT
	JUMPL A,.+2	;DID WE REALLY HAVE A VALID TYPE
	MOVEI A,0	;NO RETURN 0
	MOVEI A,(A)	;CLOBBER LEFT HALF
	POPJ P,  	;AND RETURN

;TYPE (ITYPE) ARE FUNCTIONS TO RETURN THE ATOMIC NAME OF THE
;TYPE OF A GOODIE.  TYPE TAKES ITS ARGS ON AP AND RETURNS IN A AND B.
;ITYPE TAKES ITS ARGS IN A AND B AND RETURNS IN SAME (B=0) FOR INVALID
;TYPECODE.
MFUNCTION TYPE,SUBR

	ENTRY 1
	HLLZ A,(AB)	;TYPE INTO A
	PUSHJ P,ITYPE	;GO TO INTERNAL
	JUMPN B,FINIS	;GOOD RETURN
	PUSH AP,$TATOM	;SETUP ERROR CALL
TYPERR:	PUSH AP,MQUOTE TYPE-UNDEFINED
	JRST CALER1"	;STANDARD ERROR HACKER

ITYPE:	LSH A,1	;TIMES 2
	HLRS A  	;TO BOTH SIDES
	ADD A,TYPVEC+1(TVP)	;GET ACTUAL LOCATION
	JUMPGE A,TYPLOS	;LOST, TYPE OUT OF BOUNDS
	MOVE B,1(A)	;PICKUP TYPE
	HLLZ A,(A)
	POPJ P,

TYPLOS:	MOVSI A,TLIST
	MOVEI B,NIL
	POPJ P,

;CHTYPE TAKES TWO ARGUMENTS.  ANY GOODIE AND A AN ATOMIC TYPE NAME
;IT CHECKS THE STORAGE ALLOCATION TYPES OF THE TWO ARE THE SAME AND
;IF THEY ARE CHANGES THE TYPE OF THE FIRST TO THAT NAME D IN THE SECOND

MFUNCTION CHTYPE,SUBR

	ENTRY 2
	HLRZ A,2(AB)	;FIRST CHECK THAT ARG 2 IS AN ATOM
	CAIE A,TATOM	
	JRST NOTATOM
	MOVE A,TYPVEC+1(TVP)	;GOBBLE DOWN TYPE VECTOR
	MOVE B,3(AB)	;AND TYPE NAME
	MOVEI D,0	;INITIALIZE TYPE COUNTER
TLOOK:	CAMN B,1(A)	;CHECK THIS ONE
	JRST TFOUND	;WIN, GO TRY TO CLOBBER
	ADDI D,1	;BUMP COUNTER
	AOBJP A,.+2	;COUTN DOWN ON VECTOR
	AOBJN A,TLOOK

	PUSH AP,$TATOM	;LOST, GENERATE ERROR
	PUSH AP,MQUOTE BAD-TYPE-NAME
	JRST CALER1

TFOUND:	HRRZ B,(A)	;GOBBLE THE SAT
	HLRZ A,(AB)	;NOW GET TYPE TO HACK
	PUSHJ P,SAT	;FIND OUT ITS SAT
	JUMPE A,TYPERR	;COMPLAIN
	CAIE A,(B)	;DO THEY AGREE?
	JRST TYPDIF	;NO, COMPLAIN
	MOVSI A,(D)	;GET NEW TYPE
	MOVE B,1(AB)	;AND VALUE
	JRST FINIS

TYPDIF:	PUSH AP,$TATOM	;MAKE ERROR MESSAGE
	PUSH AP,MQUOTE STORAGE-TYPES-DIFFER
	JRST CALER1




WNA:
	PUSH AP,$TATOM
	PUSH AP,MQUOTE WRONG-NUMBER-OF-ARGUMENTS
	MOVEI A,1
	JRST CALER"

NOTATOM:
	PUSH AP,$TATOM
	PUSH AP,MQUOTE NON-ATOMIC-ARGUMENT
	PUSH AP,(AB)
	PUSH AP,1(AB)
	MOVEI A,2
	JRST CALER

MFUNCTION TERPRI,SUBR
	ENTRY 0
	PUSHJ P,CRLF
	JRST FALSE"

CRLF:	MOVEI	A,15
	JRST	TYO"
MSGTYP":	HRLI	B,440700	;MAKE BYTE POINTER
MSGTY1:	ILDB	A,B	;GET NEXT CHARACTER
	JUMPE	A,CPOPJ	;NULL ENDS STRING
	PUSHJ	P,TYO"
	JRST	MSGTY1		;AND GET NEXT CHARACTER


;INTRPT HANDLER FOR MUDDLE

TTYIN==2

INTHND:
LOC 42
	JSR INTHND
LOC INTHND
	0
	0
	MOVEM A, SAVEA
	MOVE A, INTHND
	TRZE A,1
	JRST TTYINT
INTLP:
			;A MUST BE RESTORED TO CURRENT INTERRUPT WORD BEFRE COMMING HERE!
	TRZE A, 200000
	JRST PDLINT

INTOUT:
	MOVE A, SAVEA
	.DISMISS INTHND+1

TTYINT:
	MOVEM A, INTSV
	MOVEI A, TTYIN
	.ITYIC A,
	JRST INTEX
	CAIE A,^G
	JRST INTEX
		SKIPE CNTRLG
		JRST INTEX
			SETOM INTFLG
			SETOM CNTRLG
INTEX:
	SKIPE A,INTSV
	JRST INTEX1
		MOVE A, SAVEA
		.DISMISS INTHND+1
INTEX1:
	JRST INTLP

PDLINT:
	MOVE A, SAVEA
	.DISMISS [PDLOV]
PDLOV:
	.VALUE
SAVEA:	0
INTSV:	0

CNTRLG:	0
INTFLG":	0
LCKINT":	0
	PUSH P, LCKINT
	AOS INTFLG
	SKIPN CNTRLG
	JRST INTLOS
		SETZM CNTRLG
		IRP A,,[0,A,B,C,D,E]
			PUSH TP,A!STO(PVP)
			PUSH TP,A
		TERMIN
		PUSH AP,$TATOM
		PUSH AP,MQUOTE CONTROL-G?
		MCALL 1,ERROR
		IRP A,,[E,D,C,B,A,0]
			POP TP,A
			POP TP,A!STO(PVP)
		TERMIN
LCKIN1:
	POP P, LCKINT
	JRST	@LCKINT
INTLOS:
	.VALUE
	JRST LCKIN1



CRADIX":	10.
INIT:	JRST SETUP
SPTIME:	0	;UNIQUE NUMBER FOR PROCID AND ENVIRONMENTS
OBLNT":	151.	;LENGTH OF INITIAL OBLISTS
VECTOP:	VECLOC
VECBOT":	VECBASE
CODBOT:	0	;ABSOLUTE BOTTOM OF CODE
CODTOP":	PARBASE
PARTOP:	PARLOC
PARBOT":	PARBASE
PVLNTH:	0
TVLNTH:	0
TVBOT:	TVBASE
VECNEW":	0	;LOCATION FOR OFFSET BETWWEN OLD VECTOP AND NEW VECTOP
PARNEW":	0		;LOCATION FOR OFFSET BETTWEEN OLD PARBOT AND NEW PARBOT
			;DURING GRBAGE COLLECTION

PATCH:
PAT:	BLOCK 100
PATEND:	0

;GARBAGE COLLECTORS PDLS


GCPDL:	-GCPLNT,,GCPDL

	BLOCK GCPLNT


;PROCESS PDL

P1PDL:	-P1PLNT,,P1PDL
	BLOCK P1PLNT

;MARKED PDLS FOR GC PROCESS

VECTGO

TPBASE:	BLOCK ITPLNT
	ITPLNT+1,,0

APBASE:	BLOCK IAPLNT
	IAPLNT+1,,0

VECRET




;FUDGE FOR UNKNOWN UUOS
;NOTE THAT WE HAVE A UUO HANDLER
;IN THE FILE UUOH >
;SO WHAT IS THE FOLLOWING DOING HERE?

ZZZ==.
LOC 41
	JSR 60

LOC 61
	.VALUE

LOC ZZZ


END START

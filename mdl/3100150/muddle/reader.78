
TITLE READER FOR MUDDLE

;C. REEVE DEC. 1970

RELOCA

READER==1	;TELL MUDDLE > TO USE SOME SPECIAL HACKS
FRMSIN==1	;FLAG SAYING WHETHER OR "." AND "'" HACKS EXIST

.INSRT MUDDLE >

.GLOBAL CONS,VECTOR,NXTCHR,LOOKUP,CRADIX,SPTIME,QUOTE,TENTAB,CHMAK,FLUSCH,ITENTB
.GLOBAL SETDEV,OPNCHN

;MACRO TO FLOAT AN AC

DEFINE MFLOAT AC
	TLC AC,232000
	FADR AC,AC
	TERMIN




FF=0	;FALG REGISTER DURING NUMBER CONVERSION

;FLAGS USED (RIGHT HALF)

NOTNUM==1	;NOT A NUMBER
NFIRST==2	;NOT FIRST CHARACTER BEING READ
DECFRC==4	;FORCE DECIMAL CONVERSION
NEGF==10	;NEGATE THIS THING
NUMWIN==20	;DIGIT(S) SEEN
INSTRN==40	;IN QUOTED CHARACTER STRING
FLONUM==100	;NUMBER IS FLOOATING POINT
DOTSEN==200	;. SEEN IN IMPUT STREAM
EFLG==400	;E SEEN FOR EXPONENT
IFN FRMSIN,[
	FRSDOT==1000	;. CAME FIRST
	USEAGN==2000	;SPECIAL DOT HACK
]

;TEMPORARY OFFSETS

VCNT==0	;NUMBER OF ELEMENTS IN CURRENT VECTOR
ONUM==1	;CURRENT NUMBER IN OCTAL
DNUM==3	;CURRENT NUMBER IN DECIMAL
FNUM==5	;CURRENT NO. IN FLOATING POINT
CNUM==7	;IN CURRENT RADIX
NDIGS==11	;NUMBER OF DIGITS
ENUM==13	;NUMBER BEFORE "E"


; TEXT FILE LOADING PROGRAM

MFUNCTION LOAD,SUBR

	ENTRY

	HLRZ A,AB	;GET NO. OF ARGS
	CAIE A,-4	;IS IT 2
	JRST TRY2	;NO, TRY ANOTHER
	HLRZ A,2(AB)	;GET TYPE
	CAIE A,TOBLS	;IS IT OBLIST
	JRST WRONGT
	JRST CHECK1

TRY2:	CAIE A,-2	;IS ONE SUPPLIED
	JRST WNA"
CHECK1:	HLRZ A,(AB)	;GET TYPE
	CAIE A,TCHAN	;IS IT A CHANNEL
	JRST WRONGT

	HLRZ A,(AB)	;GET TYPE OF FIRST
	CAIE A,TCHAN	;IS IT A CHANNEL
	JRST WRONGT	;NO, COMPLAIN

LOAD1:	AOS A,SPTIME	;GET A UNIQUE TIME NUMBER
	PUSH TP,$TTIME	;AND SAVE IT
	PUSH TP,A

LOAD2:	PUSH AP,(TB)	;USE TIME AS EOF ARG
	PUSH AP,1(TB)
	PUSH AP,(AB)	;USE SUPPLIED CHANNEL
	PUSH AP,1(AB)

	CAML AB,[-2,,0]	;CHECK FOR 2ND ARG
	JRST LOAD3	;NONE

	PUSH AP,2(AB)	;PUSH ON 2ND ARG
	PUSH AP,3(AB)
	MCALL 3,READ
	JRST CHKRET	;CHECK FOR EOF RET

LOAD3:	MCALL 2,READ
CHKRET:	CAMN A,(TB)	;IS TYPE EOF HACK
	CAME B,1(TB)	;AND IS VALUE
	JRST EVALIT	;NO, GO EVAL RESULT
	PUSH AP,(AB)
	PUSH AP,1(AB)
	MCALL 1,FCLOSE
	MOVSI A,TCHRS	;RETURN DONE MESSAGE
	MOVE B,[ASCIZ /DONE/]
	JRST FINIS

EVALIT:	PUSH AP,A
	PUSH AP,B
	MCALL 1,EVAL
	JRST LOAD2


MFUNCTION READC,SUBR,READCHR

	ENTRY
	PUSH P,[IREADC]	;WHERE TO GO AFTER BINDING
	JRST READ0	;GO BIND VARIABLES

MFUNCTION NXTRDC,SUBR,NEXTCHR

	ENTRY

	PUSH P,[INXTRD]
	JRST READ0

MFUNCTION READ,SUBR

	ENTRY

	PUSH P,[IREAD]	;WHERE TO GO AFTER BINDING
READ0:	HLRE A,AB	;-NUM OF ARGS TO A
	MOVNS A  	;+ NUM OF ARGS
	LSH A,-1	;FOR SPECBIND
	JUMPE A,READ1	;NO ARGS, NO BINDING
	PUSH P,A	;FOR SPECBIND
	MOVE B,AB	;GET A COPY OF THE ARG BLOCK
	MOVEI D,0	;ACCESS ARG TABLE
ARGLP:	HLRZ C,(B)	;ISOLATE TYPE
	XCT ARGS(D)	;DO THE APROPRIATE COMPARE
	JRST WRONGT
	PUSH TP,$TATOM	;PUSH THE ATOMS
	PUSH TP,@ARGS+1(D)
	ADDI D,2	;BUMP ARG TBL POINTER
	ADD B,[2,,2]	;AND ARG POINTER
	JUMPL B,ARGLP	;MORE?

	PUSHJ P,SPECBIND	;NO, GO BIND
	SUB P,[1,,1]	;POP THE WORLD

READ1:	MOVE B,MQUOTE INCHAN,,	;GET INPUT CHANNEL
	MOVSI A,TATOM
	PUSHJ P,IVAL	;NOW GOBBLE THE REAL CHANNEL
	CAME A,$TCHAN	;IS IT A CHANNEL
	JRST CHNLOS
	MOVE A,DIRECT(B)	;GET DIRECTION
	CAME A,CHQUOTE READ,	;IS IT OPEN FOR READING
	JRST WRNGDI	;LOSE AGAIN
GETIO:	MOVE A,IOINS(B)	;GOBBLE THE I/O INSTRUCTION
	JUMPE A,OPNFIL	;GO REALLY OPEN THE CROCK
	PUSHJ P,SETDEV	;CLOBBER IT INTO NXTCHR

REREAD:	PUSHJ P,@(P)	;CALL INTERNAL READER
	JRST RFINIS	;SUCCESSFUL, RETURN
	CAIE B,3	;READ 'FAILED' IS LOSER EOF
	JRST REREAD	;NO, MUST BE UNMATCHED PARENS
	MOVE B,MQUOTE EOF,,	;GET EOF
	MOVSI A,TATOM
	PUSHJ P,IVAL	;GET LOCAL VALUE
	CAMN A,$TUNBOU	;UNBOUND IS ONLY LOSER
	JRST NEOF
	PUSH AP,A	;SETUP CALL TO EVAL
	PUSH AP,B
	MCALL 1,EVAL	;AND EVAL IT
RFINIS:	SUB P,[1,,1]	;POP OFF LOSER
	JRST FINIS


;HERE TO ATTEMPT TO OPEN A CLOSED CHANNEL

OPNFIL:	PUSHJ P,OPNCHN	;GO DO THE OPEN
	JUMPE B,OPNERR	;LOSE IC B IS 0
	JRST GETIO

		;MAIN ENTRY TO READER
IREAD:
SPACE:	CLEARM LSTCHR	;DON'T REREAD LAST CHARACTER
IREAD1:
BDLP:	PUSHJ P,NXTCH	;GOBBLE CHAR IN A AND TYPE IN D
	CAIG B,NTYPES
	JUMPN B,@.+1(B)	;ERROR ON ZERO TYPE OR FUNNY TYPE
	JRST BADCHR
DTBL:	NUMLET	;HERE IF NUMBER OR LETTER
NONSPC==.-DTBL	;NUMBER OF NON-SPECIAL CHARACTERS
	SPACE	;SPACING CHAR CR,LF,SP,TAB ETC.
SPATYP==.-DTBL	;TYPE FOR SPACE CHARS


;THE FOLLOWING ENTRIES ARE VARIOUS PUNCTUATION CROCKS

	LPAREN	;( - BEGIN LIST
	RPAREN	;) - END CURRENT LEVEL OF INPUT
	LBRACK	;[ -BEGIN ARRAY
	RBRACK	;] - END OF ARRAY
	QUOTIT	;' - QUOTE THE FOLLOWING GOODIE

MACTYP==.-DTBL

	MACCAL	;% - INVOKE A READ TIME MACRO
	CSTRING	;" - CHARACTER STRING
	NUMLET	;\ - ESCAPE,BEGIN ATOM

ESCTYP==.-DTBL	;TYPE OF ESCAPE CHARACTER

	SPECTY	;# - SPECIAL TYPE TO BE READ
	OPNANG	;< - BEGIN ELEMENT CALL

SLMNT==.-DTBL	;TYPE OF START OF SEGMENT

	CLSANG	;> - END ELEMENT CALL


	EOFCHR	;^C - END OF FILE

NTYPES==.-DTBL


;HERE ON NUMBER OR LETTER, START ATOM

NUMLET:	PUSHJ P,GOBBLE	;READ IN THE ATOM AND PUT PNTR ON ARG PDL
	JRST RET	;NO SKIP RETURN I.E. NON NIL

;HERE TO START BUILDING A CHARACTER STRING GOODIE

CSTRING:	PUSHJ P,GOBBL1	;READ IN STRING
	JRST RET



;HERE ON QUOTE

QUOTIT:	PUSH AP,$TATOM	;PUT IN (QUOTE ...
	PUSH AP,MQUOTE QUOTE,
	CLEARM LSTCHR	;MAKE SURE DONT REREAD '
	PUSHJ P,IREAD	;READ IN QUOTED STRUCUTE
	SKIPA	;GOOD RETURN
	JRST ERRPAR	;BAD RARENS
	PUSH AP,A	;SAVE TYPE AND VALUE
	PUSH AP,B
	MCALL 2,LIST	;CONS IT
IFN FRMSIN,MOVSI A,TLMNT
	JRST RET


;ARRIVE HERE TO INVOKE A READ TIME MACRO FUNCTION

MACCAL:	PUSHJ P,NXTCH1	;READ ONE MORE CHARACTER
	CAIE B,MACTYP	;IS IT ANOTHER MACRO CHAR

	JRST MACAL1	;NO, CALL MACRO AND USE VALUE
	CLEARM LSTCHR	;DONT REREAD %
	PUSHJ P,MACAL1	;OTHERWISE, USE SIDE EFFECCT, BUT NOT VALUE
	JRST IREAD1

MACAL1:	PUSHJ P,IREAD1	;READ FUNCTION NAME
	SKIPA	;GOOD RETURN
	JRST ERRPAR	;BAD PARENS
	PUSH AP,A	;SAVE THE RESULT
	PUSH AP,B	;AND USE IT AS AN ARGUMENT
	MCALL 1,EVAL
	JRST RET

;CALL GOBBLE TO FIND THE TYPE AND THEN IREAD TO READ IT

SPECTY:	PUSHJ P,IREAD	;READ THE TYPES NAME (SHOULD BE AN ATOM)
	PUSH AP,A	;BEGIN SETTING UP CHTYPE CALL
	PUSH AP,B
	PUSHJ P,IREAD1	;NOW READ STRUCTURE
	EXCH A,-1(AP)	;USE AS FIRST ARG
	EXCH B,(AP)
	PUSH AP,A	;USE OTHER AS 2D ARG
	PUSH AP,B
	MCALL 2,CHTYPE	;ATTEMPT TO MUNG
	JRST RET

	JRST RET

;THIS CODE CALLS IREAD RECURSIVELY TO READ THAT WHICH IS
;BETWEEN (),  ARRIVED AT WHEN ( IS READ

SEGIN:	MOVE TP,(TP)	;RESTORE OLDER TP
	SUB TP,[1,,1]	;FUDGE TP
	SUB P,[1,,1]	;MUST POP OF POINT BYTER
	PUSH TP,$TSEG
	JRST OPNAN1

OPNANG:	PUSH TP,$TLMNT	;SAVE TYPE
OPNAN1:	PUSH P,[">]
	JRST LPARN1

LPAREN:	PUSH P,[")]
	PUSH TP,$TLIST	;START BY ASSUMING NIL
LPARN1:	PUSH TP,NILSXP
	CLEARM LSTCHR	;DON'T REREAD PARENS
LLPLOP:	PUSHJ P,IREAD1	;READ IT
	JRST GENCAR	;SOMETHING READ, GO CONS IT
	CAME B,(P)	;CHECK VALIDITY OF CHARACTER
	JRST ERRPAR
	SUB P, [1,,1]
	POP TP,B	;GET VALUE OF PARTIAL RESULT
	POP TP,A	;AND TYPE OF SAME
	JUMPE B,RET	;VALUE IS NIL, DON'T POP AGAIN
	POP TP,B	;POP FIRST LIST ELEMENT
	POP TP,A	;AND TYPE
	CLEARM LSTCHR	;DON'T REREAD )
	JRST RET

;HERE WHEN MUST ADD CAR TO CURRENT WINNER

GENCAR:	PUSH AP,A	;SAVE TYPE OF VALUE
	PUSH AP,B	;AND VALUE
	MCALL 1,NCONS	;GOBBLE NIL LISTE
	POP TP,C	;GET CDR
	JUMPN C,CDRIN	;IF STACKED GOODIE NOT NIL SKIP
	PUSH TP,B	;AND USE AS TOTAL VALUE
	PUSH TP,A	;SAVE THIS AS FIRSST THING ON LIST
	JRST .+2	;SKIP CDR SETTING
CDRIN:	HRRM B,(C)
	PUSH TP,B	;CLOBBER IN NEW PARTIAL GOODIE
	JRST LLPLOP	;AND CONTINUE

;THIS CODE IS SIMILAR TO LIST GENERATING CODE BUT IS FOR VECTORS

LBRACK:	SETZM LSTCHR	;FORCE READING NEW CHAR
	PUSH P,LSTCHR	;INITIALIZE TO (WILL COUNT VECTOR ELEMENTS)
	PUSH TP,$TAP	;SAVE OLD AP
	PUSH TP,AP

LBRAK1:	PUSHJ P,IREAD1	;RECURSIVELY READ  ELEMENTS OF ARRAY
	JRST STAKIT	;ELEMENT READ, PUT IT ON THE STACK
	CAIE B,"]	;FINISHED RETURN (WAS THE RIGHT STOP USED?)
	JRST ERRPAR	;NO COMPLAIN
	MOVN A,VCNT(P)	;GET NO. OF ELEMENTS
	HRLZI AB,(A)	;SETUP AB
	LSH AB,1	;TIMES 2
	HRR AB,(TP)	;POINTER TO BASE OF CROCK
	ADDI AB,1
	JSR SAVCAL	;SAVE THE WORLD
	PUSH TP,[TENTRY,,EVECTOR]	;START UP CALL
	PUSHJ TP,EVECTOR
	JSR RESCAL
	MOVE AP,(TP)	;RESET AP
	SUB TP,[2,,2]	;RESET TP
	SUB P,[1,,1]	
		CLEARM LSTCHR	;FORCE NEW READ
	JRST RET

STAKIT:	PUSH AP,A	;SAVE RESULT TYPE
	PUSH AP,B	;AND VALUE
	AOS VCNT(P)	;AND COUNT
	JRST LBRAK1

;HERE ON RPAREN, POP UP ONE LEVEL

CLSANG:		;CLOSE ANGLE BRACKETS
RBRACK:		;COMMON RETURN FOR END OF ARRAY ALSO
RPAREN:	SETZM LSTCHR	;DON'T REREAD 
EOFCHR:	MOVE B,A	;GETCHAR IN B
	MOVSI A,TCHRS	;AND TYPE IN A

RET1:	AOS (P)	;GOT SOMETHING RET
RET:	POPJ P,	;NIL RETURN

;RANDOM MINI-SUBROUTINES USED BY THE READER

;READ A CHAR INTO A AND TYPE CODE INTO D

NXTCH:	SKIPN A,LSTCHR	;CHAR IN A IF REUSE
NXTCH1:	PUSHJ P,NXTCHR	;GET CHARACTER FROM INPUT
	ANDI A,177	;INCASE IT IS EOF
	MOVEM A,LSTCHR	;SAVE THE CHARACTER
	IDIVI A,CHRWRD	;YIELDS WORD AND CHAR NUMBER
	LDB B,BYTPNT(B)	;GOBBLE TYPE CODE
	MOVE A,LSTCHR	;SAVE CHARACTER
	POPJ P,

;TABLE OF BYTE POINTERS FOR GETTING CHARS

BYTPNT":	350700,,CHTBL(A)
	260700,,CHTBL(A)
	170700,,CHTBL(A)
	100700,,CHTBL(A)
	010700,,CHTBL(A)

;HERE ARE THE TABLES OF CHXRACTERS (NOTE EVERYTHING NOT SPECIFIED IS
;IN THE NUMBER LETTER CATAGORY)

SETCOD 2,[15,12,11,14,40]	;ALL ARE TYPE 2 (SPACING - FF,TAB,SPACE)

INCRCH 3,[()[]'%"\#<>]	;GIVE THESE INCREASRNG CODES FROM 3

SETCOD 16,[3]	;^C - EOF CHARACTER

CHTBL:
	OUTTBL	;OUTPUT THE TABLE RIGHT HERE


;SUBROUTINE TO READ CHARS ONTO STACK

GOBBL1:	MOVEI FF,0	;KILL ALL FLAGS
	CLEARM LSTCHR	;DON'T REREAD "
	TROA FF,NOTNUM+INSTRN	;SURPRESS NUMBER CONVERSION
GOBBLE:	MOVEI FF,0	;FLAGS CONCERRNING CURRENT GOODIE IN HERE
	MOVE A,TP	;GOBBLE CURRENT TP TO BE PUSHED
	MOVEI C,6	;NOW PUSH 6 0'S ON TO STACK
	PUSH TP,$TFIX	;TYPE IS FIXED
	PUSH TP,FF	;AND VALUE IS 0
	SOJG C,.-2	;FOUR OF THEM
	PUSH TP,$TTB	;NOW SAVE OLD TP
	ADD A,[1,,1]	;MAKE IT LOOK LIKE A TB
	PUSH TP,A
	MOVEI D,0	;ZERO OUT CHARACTER COUNT
GOB1:	MOVEI C,0 	;SET UP FIRST WORD OF CHARS
	PUSH P,[440700,,C]	;BYTE POINTER
GOB2:	PUSH P,FF	;SAVE FLAG REGISTER
	PUSHJ P,NXTCH	;READ A CHAACTER
	POP P,FF	;AND RESTORE FLAG REGISTER
	CAIN B,ESCTYP	;IS IT A CHARACTER TO BE ESCAPED
	JRST ESCHK	;GOBBLE THE ESCAPED CHARACTER
	TRNE FF,INSTRN	;ARE WE BUILDING A CHAR STRING
	JRST ADSTRN	;YES, GO READ IN
	CAILE B,NONSPC	;IS IT SPECIAL
	JRST DONEG	;YES, RAP THIS UP

;ARRIVE HERE WITH CHARACTER FOR FURTHER HACKING
;HERE TO INSERT IT

INCHR:	TRNE FF,NOTNUM	;IS  NUMERIC STILL WINNING
	JRST SYMB2	;NO, ONLY DO CHARACTER HACKING
	CAIL A,60	;CHECK FOR DIGIT
	CAILE A,71
	JRST SYMB1

;ARRIVE HERE IFF STILL BUILDING A NUMBER

	MOVE B,(TP)	;GOBBLE POINTER TO TEMPS
	AOS NDIGS(B)	;COUNT DIGITS
	TRO FF,NUMWIN	;SAY DIGITS SEEN
	SUBI A,60	;CONVERT TO A NUMBER
	TRNE FF,DOTSEN	;HAS A . BEEN SEEN
	TROA FF,FLONUM	;YES, THIS IS AFLOATING NUMBER
	SKIPA E,ONUM(B)	;NO, PICK UP OCTAL
	JRST DECCNV	;CONVERT ONLY IN DECIMAL FOR FLOATING
	LSH E,3	;IMULI E,10
	ADD E,A	;ADD IT IN
	MOVEM E,ONUM(B)	;STORE IT
	MOVE E,CNUM(B)	;ALSO CURRENT RADIX VERSION
	IMUL E,CRADIX	;MULTIPLY
	ADD E,A
	MOVEM E,CNUM(B)
DECCNV:	MOVE E,DNUM(B)	;GET CURRENT DNUMBER
	IMULI E,10.	;MULTIPLY
	ADD E,A	;ADD
	MOVEM E,DNUM(B)	;AND SAVE IT
	MOVE A,LSTCHR	;RESTORE CHARACTER
	JRST SYMB2	;ALSO DEPOSIT INTO SYMBOL BEING MADE

;HERE TO PUT INTO IDENTIFIER BEING BUILT

ESCHK:	PUSHJ P,NXTCH1	;GOBBLE NEXT CHAR
SYMB:	TRO FF,NOTNUM	;SET NOT NUMBER FLAG
SYMB2:	TRO FF,NFIRST	;NOT FIRST IN WORLD
SYMB3:	IDPB A,(P)	;INSERT IT
	CLEARM LSTCHR	;READ NEW CHARACTER
	TRNN C,377	;WORD FULL?
	JRST GOB2	;NO, KEEP TRYING
	MOVEM C,(P)	;YES,STORE IT
	AOJA D,GOB1	;COUNT WORD AND GO

;HERE TO CHECK FOR +,-,. IN NUMBER

SYMB1:	TRNE FF,NFIRST	;IS THIS THE FIRST CHARACTER
	JRST CHECK.	;NO, ONLY LOOK AT DOT
	CAIE A,"-	;IS IT MINUS
	JRST .+3	;NO CHECK PLUS
	TRO FF,NEGF	;YES, NEGATE AT THE END
	JRST SYMB2
	CAIN A,"+	;IS IT +
	JRST SYMB2	;ESSENTIALLY IGNORE IT

;COULD BE .

CHECK.:	CLEARB E,LSTCHR	;FLUSH LAST CHARACTER
	TRNN FF,DOTSEN+EFLG	;IF ONE ALREADY SEEN
	CAIE A,".
	JRST CHECKE	;GO LOOK FOR E

IFN FRMSIN,[
	TRNN FF,NFIRST	;IS IT THE FIRST
	JRST DOT1	;YES, COULD MEAN EVALUATE A VARIABLE
]

CHCK.1:	TRO FF,DECFRC+DOTSEN	;FORCE DECIMAL 
	MOVE B,(TP)	;RE GOBBLE TEMP POINTER
	EXCH E,DNUM(B)	;GET PART OF NUMBER AND CLEAR
	MOVEM E,FNUM(B)	;SAVE NUMBER
	SETZM NDIGS(B)	;RESET DIGIT COUNT
IFN FRMSIN,	TRNN FF,FRSDOT	;IF NOT FIRST ., PUT IN CHAR STRING
	JRST SYMB2	;ENTER INTO SYMBOL
IFN FRMSIN,	JRST GOB2	;IGNORE THE "."

IFN FRMSIN,[

;HERE TO SET UP FOR .FOO ..FOO OR.<ABC>

DOT1:	PUSH P,FF	;SAVE FLAGS
	PUSHJ P,NXTCH1	;GOBBLE A NEW CHARACTER
	POP P,FF	;RESTORE FLAGS
	CAIN A,".	;CHECK FOR ANOTHER .
	JRST ..SET
	CAIN B,SLMNT	;OR START OF SEGMENT
	JRST SEGIN
	MOVEI E,0	;SET FOR FURTHER HACKS
	TRO FF,FRSDOT	;SET FLAG
SKIPSP:	CAIE B,SPATYP	;IS IT A SPACER
	JRST CHCK.1
	PUSH P,FF	;SAVE FLAGS
	PUSHJ P,NXTCH1
	POP P,FF
	JRST SKIPSP


;HERE AFTER READING ATOM TO CALL VALUE

.SET:	PUSH P,$TLMNT	;GET WINNING TYPE
	JRST .SET1

;HERE FOR .., CALL IREAD AND CONS UP VALUE CALL

..SET:	MOVE TP,(TP)	;RESTORE OLD TP
	SUB TP,[1,,1]	;FUDGE
	MOVSI A,TSEG	;GET TYPE
	MOVEM A,(P)	;CLOBBER POINT BYTER
	PUSHJ P,IREAD
	CAME A,$TATOM	;RESULT MUST BE ATOM
	JRST BAD.

.SET1:	PUSH AP,$TATOM
	PUSH AP,MQUOTE VALUE
	PUSH AP,A
	PUSH AP,B
	MCALL 2,LIST	;CONS UP "<VALUE FOO> OR .<VALUE FOO>"
	POP P,A	;GET WINNING TYYPE
	JRST RET

]

;HERE TO CHECK FOR "E" FLAVOR OF EXPONENT

CHECKE:	TRNN FF,EFLG	;HAS ONE BEEN SEEN
	CAIE A,"E	;IF NOT, IS THIS ONE
	JRST SYMB	;NO, ENTER AS SYMBOL KILL NUMERIC WIN

	MOVE B,(TP)	;GET POINTER TO TEMPS
	EXCH E,DNUM(B)	;GET PARTIAL NUMBER AND CLEAR IT
	MOVEM E,ENUM(B)	;SAVE OLD
	HRLM FF,NDIGS(B)	;SAVE OLD FLAGS IN LH OF NDIGS
	HRLZ FF,NDIGS(B)	;AND OLD NDIGS IN FLAG REG
	HRRI FF,DECFRC+DOTSEN+EFLG	;SET NEW FLAGS
	JRST SYMB3	;ENTER SYMBOL


;HERE ON READING CHARACTER STRING

ADSTRN:	CAIE A,""	;QUOTE CHAR?
	JRST SYMB2	;NO JUST INSERT IT
	CLEARM LSTCHR	;DON'T REREAD "."

;HERE TO FINISH THIS CROCK

DONEG:	TRNN FF,NUMWIN	;HAVE DIGITS BEEN SEEN?
	TRO FF,NOTNUM	;NO,SET NOT NUMBER FLAG
	POP P,A	;FLUSH POINT BYTER
	JUMPE C,.+3	;LAST WORD USED?
	PUSH P,C	;YES, STORE IT
	AOS D	;AND BUMP COUNT
	PUSH P,D	;SAVE IT
	TRNN FF,NOTNUM	;NUMERIC?
	JRST NUMHAK	;IS NUMERIC, GO TO IT
	MOVE C,P	;NOW COMPUTE AOBJN POINTER

IFN FRMSIN,[
	MOVE A,(TP)	;GET POINTER TO TEMPS
	MOVEM FF,NDIGS(A)	;USE TO HOLD FLAGS
]
	SUB C,D	;C POINTS TO START OF CHARS
	HRLZS D	;LH IS COUNT
	MOVNS D	;NOW NEG COUNT
	HRRI D,(C)	;NOW HAVE AOBJN POINTER
	TRNE FF,INSTRN	;ARE WE BUILDING A STRING
	JRST MAKSTR	;YES, GO COMPLETE SAME
	MOVE C,D	;FOR ILOOKUP
	PUSHJ P,ILOOKU

IFN FRMSIN,[
	MOVE C,(TP)	;SET TO REGOBBLE FLAGS
	MOVE FF,NDIGS(C)
]
	JRST FINID

;HERE TO RAP UP CHAR STRING ITEM

MAKSTR:	MOVE C,D	;SETUP TO CALL CHMAK
	PUSHJ P,CHMAK	;GO MAKE SAME
	JRST FINID


NUMHAK:	MOVE C,(TP)	;REGOBBLETEMP POINTER
	TRNE FF,FLONUM+EFLG	;IS IT A FLOATING POINT NUMBER
	JRST FLOATIT	;YES, GO MAKE IT WIN
	MOVE B,CNUM(C)	;GET CURRENT NUMBER
	TRNE FF,DECFRC	;DECIMAL FORCED?
	MOVE B,FNUM(C)	;YES, USE IT
FINID2:	MOVSI A,TFIX	;SAY FIXED POINT
FINID1:	TRNE FF,NEGF	;NEGATE
	MOVNS B	;YES
FINID:	POP P,C	;CROCK TO REMOVE CHAR STRING
	HRLS C	;IN BOTH SIDES NOW
	SUB P,C	;DECREMENT STACK
	POP TP,TP	;RESTORE OLD TP
	SUB TP,[1,,1]	;FINISH HACK
IFN FRMSIN,[
	TRNE FF,FRSDOT	;DID . START IT
	JRST .SET	;YES, GO HACK
]
	POPJ P,	;AND RETURN


;HERE TO DO FLOATING POINT CONVERSION

FLOATIT:	TRNE FF,EFLG	;"E" SEEN?
	JRST EXPDO	;YES, DO EXPONENT
	HRRZ A,NDIGS(C)	;GET NUMBER OF DIGITS
	MOVE B,DNUM(C)	;GETNUMBER PAST .
	MFLOAT B	;FLOAT IT
	FDVR B,TENTAB(A)	;DIV BY POWER OF 10
	MOVE A,FNUM(C)	;GET NUMBER BEFORE .
	MFLOAT A	;FLOAT IT ALSO
	FADR B,A
SETFLO:	MOVSI A,TFLOT
IFN FRMSIN,	TRZ FF,FRSDOT	;NUMBER , CAN'T BE "VALUE"
	JRST FINID1

;HERE TO COMPUTE EXPONENT

EXPDO:	MOVE A,DNUM(C)	;GET NUMBER PAST DECIMAL
	TRNE FF,NEGF	; SEE IF EXPONENT NEGATIVE
	MOVNS A	;YES, NEGATE IT
	HLR FF,NDIGS(C)	;GET SAVED FLAGS
	JUMPL A,FLOATE	;FLOATING IF NEG
	TRNE FF,FLONUM	;OR FLAG ON
	JRST FLOATE

	MOVE B,ENUM(C)	;OTHERWISE USE INTEGER
	TRNE FF,DECFRC	;IF DECIMAL FORCED
	MOVE B,FNUM(C)	;USE OTHER NUMBER
	IMUL B,ITENTB(A)
	JRST FINID2

FLOATE:	MOVEI B,0	;SET RIGHT OF . TO 0
	MOVE D,ENUM(C)	;AND NUMBER PRIOR TO E IN D
	TRNN FF,FLONUM	;WAS A . IN THE NUMBER
	JRST FLOATD	;NO, SKIP

	MOVE B,ENUM(C)	;GET NUMBER PAT .
	MFLOAT B
	HLRZ D,FF	;GET SAVED NUMBER OF DIGITS
	FDVR B,TENTAB(D)	;DIVIDE IT BY POWER OF TEN
	MOVE D,FNUM(C)	;GET NUMBER PRIOR TO .

FLOATD:	MFLOAT D
	FADR B,D
	JUMPGE A,FLOAT1
	MOVNS A
	FDVR B,TENTAB(A)
	JRST SETFLO

FLOAT1:	FMPR B,TENTAB(A)
	JRST SETFLO

	


; HERE TO READ ONE CHARACTER FOR USER.

INXTRD:	SKIPA E,[JFCL]	;NULL CLEAR INS
IREADC:	MOVE E,[CLEARM LSTCHR]	;AVOID RE-READ
	PUSHJ P,NXTCH	;GOBBLE THE CHAR
	XCT E	;CLEAR LSTCHR IF NECESSARY
	CAIN B,NTYPES	;IS IT EOF?
	JRST EOFCHR	;DO EOF RETURN
	MOVE B,A	;CHAR TO B
	LSH B,29.	;LEFT JUSTIFY
	MOVSI A,TCHRS	;AND TYPE
	POPJ P, 	;RETURN

; READER ERRORS COME HERE

ERRPAR:	PUSH AP,$TATOM
	PUSH AP,MQUOTE BAD-()-[]-MATCHING
INFLS:	PUSHJ P,FLUSCH	;RESET AWAITING INPUT
	JRST CALER1	;ERROR HANDLER

;HERE ON BAD . USAGE

IFN FRMSIN,[

BAD.:	PUSH AP,$TATOM
	PUSH AP,MQUOTE BAD-.-USAGE
	JRST INFLS
]


; HERE ON BAD INPUT CHARACTER

BADCHR:	PUSH AP,$TATOM
	PUSH AP,MQUOTE BAD CHARACTER IGNORED
	MCALL 1,PRINT
	JRST IREAD


;EOF ERROR

NEOF:	PUSH AP,$TATOM	;GENERATE ERROR MESSAGE
	PUSH AP,MQUOTE EOF-REACHED
	JRST CALER1

;LOSING CHANNEL FOR INPUT

CHNLOS:	PUSH AP,$TATOM
	PUSH AP,MQUOTE BAD-CHANNEL
	JRST CALER1


;OPEN ERROR

OPNERR:	PUSH AP,$TATOM	;SETUP MESSAGE
	PUSH AP,MQUOTE OPEN-FAILED
	JRST CALER1

;HERE FOR DIRECTION ERROR

WRNGDI:	PUSH AP,$TATOM	;SET UP ERROR
	PUSH AP,MQUOTE NOT-OPEN-FOR-READING
	JRST CALER1

;WRONG ARG TYPE

WRONGT:	PUSH AP,$TATOM
	PUSH AP,MQUOTE WRONG-TYPE
	JRST CALER1


NILSXP:	0,,0

;IMPURE WORD, HOLDS LAST CHRACTER

LSTCHR:	0


;TABLE OF NAMES OF ARGS AND ALLOWED TYPES

ARGS:
	IRP A,,[[[CAIN C,TUNBOU],EOF],[[CAIE C,TCHAN],INCHAN],[[CAIE C,TOBLS],OBLIST]]
		IRP B,C,[A]
			B
			MQUOTE C
			.ISTOP
		TERMIN
	TERMIN

END

	MOVE A,DIRECT(B)	;GET DIRECTION
	CAME A,CHQUOTE READ,	;IS IT OPEN FOR READING
	JRST WRNGDI	;LOSE AGAIN
GETIO:	MOVE A,IOINS(B)	;GOBBLE THE I/O INSTRUCTION
	JUMPE A,OPNFIL	;GO REALLY OPEN THE CROCK
	PUSHJ P,SETDEV	;CLOBBER IT INTO NXTCHR

REREAD:	PUSHJ P,@(P)	;CALL INTERNAL READER
	JRST RFINIS	;SUCCESSFUL, RETURN
	CAIE B,3	;READ 'FAILED' IS LOSER EOF
	JRST REREAD	;NO, MUST BE UNMATCHED PARENS
	MOVE B,MQUOTE EOF,,	;GET EOF
	MOVSI A,TATOM
	PUSHJ P,IVAL	;GET LOCAL VALUE
	CAMN A,$TUNBOU	;UNBOUND IS ONLY LOSER
	JRST NEOF
	PUSH AP,A	;SETUP CALL TO EVAL
	PUSH AP,B
	MCALL 1,EVAL	;AND EVAL IT
RFINIS:	SUB P,[1,,1]	;POP OFF LOSER
	JRST FINIS


;HERE TO ATTEMPT TO OPEN A CLOSED CHANNEL

OPNFIL:	PUSHJ P,OPNCHN	;GO DO THE OPEN
	JUMPE B,OPNERR	;LOSE IC B IS 0
	JRST GETIO

		;MAIN ENTRY TO READER
IREAD:
SPACE:	CLEARM LSTCHR	;DON'T REREAD LAST CHARACTER
IREAD1:
BDLP:	PUSHJ P,NXTCH	;GOBBLE CHAR IN A AND TYPE IN D
	CAIG B,NTYPES
	JUMPN B,@.+1(B)	;ERROR ON ZERO TYPE OR FUNNY TYPE
	JRST BADCHR
DTBL:	NUMLET	;HERE IF NUMBER OR LETTER
NONSPC==.-DTBL	;NUMBER OF NON-SPECIAL CHARACTERS
	SPACE	;SPACING CHAR CR,LF,SP,TAB ETC.
SPATYP==.-DTBL	;TYPE FOR SPACE CHARS


;THE FOLLOWING ENTRIES ARE VARIOUS PUNCTUATION CROCKS

	LPAREN	;( - BEGIN LIST
	RPAREN	;) - END CURRENT LEVEL OF INPUT
	LBRACK	;[ -BEGIN ARRAY
	RBRACK	;] - END OF ARRAY
	QUOTIT	;' - QUOTE THE FOLLOWING GOODIE

MACTYP==.-DTBL

	MACCAL	;% - INVOKE A READ TIME MACRO
	CSTRING	;" - CHARACTER STRING
	NUMLET	;\ - ESCAPE,BEGIN ATOM

ESCTYP==.-DTBL	;TYPE OF ESCAPE CHARACTER

	SPECTY	;# - SPECIAL TYPE TO BE READ
	OPNANG	;< - BEGIN ELEMENT CALL

SLMNT==.-DTBL	;TYPE OF START OF SEGMENT

	CLSANG	;> - END ELEMENT CALL


	EOFCHR	;^C - END OF FILE

NTYPES==.-DTBL


;HERE ON NUMBER OR LETTER, START ATOM

NUMLET:	PUSHJ P,GOBBLE	;READ IN THE ATOM AND PUT PNTR ON ARG PDL
	JRST RET	;NO SKIP RETURN I.E. NON NIL


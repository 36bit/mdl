
TITLE INTERRUPT HANDLER FOR MUDDLE

RELOCATABLE

;C. REEVE  APRIL 1971

.INSRT MUDDLE >

; DEFINE THE INTERRUPT TABLE AND ADD IT TO TRANSFER VECTOR

VECTGO

NINT==72.	;MAXIMUM NUMBER OF INTERRUPTS POSSIBLE

ITSNT1:	BLOCK 2*NINT
	2*NINT+1,,0

ADDTV TVEC,[-2*NINT,,ITSNT1]
ITSINT==TVOFF	;SET UP POINTER OFFSET INTO TRANS VECTOR

VECRET


;SET UP LOCATION 42 TO POINT TO TSINT

ZZZ==.	;SAVE CURRENT LOCATION

LOC 42
î	JSR TSINT	;GO TO HANDLER

LOC ZZZ

; GLOBALS NEEDED BY INTERRUPT HANDLER

.GLOBA GCFLG	;TELLS WHETHER OR NOT GARBAGE COLLECTOR IS RUNNING
.GLOBA GCINT	;TELLS GARBAGE COLLECTOR TO SIMULATE AN INTERRUPT
.GLOBAL GCPDL	;GARBAGE COLLECTORS PDL
.GLOBAL VECTOP,VECBOT	;DELIMIT VECTOR SPACE
.GLOBAL PDLBUF	;AMOUNT OF  PDL GROWTH
.GLOBAL PDLEXP	;POINTS TO DOPE WORD OF NEXT PDL TO GROW

.GLOBAL PCHACK	;CALLED BY INITIALIZER TO TAKE CARE OF INT PCS

.GLOBAL MSGTYP,READCH,IFLUSH,OCLOS,ERRET	;SUBROUTINES USED
;BEGINNING OF ACTUAL INTERRUPT HANDLER (MUST BE IMPURE)

TSINT:	0	;INTERRUPT BITS GET STORED HERE
TSINTR:	0	;INTERRUPT PC WORD STORED HERE
	JRST TSINTP	;GO TO PURE CODE

;THE REST OF THIS CODE IS PURE

TSINTP:	SOSE INTFLG	; SKIP IF ENABLED
	SETOM INTFLG	;DONT GET LESS THAN -1

	MOVEM A,TSAVA	;SAVE TWO ACS
	MOVEM A,TSAVB
	MOVE A,TSINT	;PICK UP INT BIT PATTERN
	JUMPL A,2NDWORD	;DONT CHECK FOR PDL OVERFLOW ETC. IF SIGN BIT ON

	TRZE A,200000	;IS THIS A PDL OVERFLOW?
	JRST IPDLOV	;YES, GO HANDLE IT FIRST

IMPCH:	TRZE A,20000	;IS IT A MEMORY PROTECTION VIOLATION?
	JRST IMPV	;YES, GO HANDLE IT

	TRZ A,40	;ILLEGAL OP CODE?
	JRST ILOPR	;YES, GO HANDLE

;DECODE THE REST OF THE INTERRUPTS USING A TABLE

2NDWORD:	SKIPN GCFLG	;IS GARBAGE COLLECTION HAPPENING?
	JRST GETTBL	;NO, GO LOOK UP TABLE

	JUMPL A,GC2	;2ND WORD?
	IORM A,PIRQ	;NO, INTO WORD 1
	JRST GCQUIT	;AND DISMISS INT

GC2:	TLZ A,400000	;TURN OFF SIGN BIT
	IORM A,PIRQ2

GCQUIT:	SETOM GCINT	;WARN THE GC
INTDON:	MOVE A,TSAVA	;RESTORE ACS
	MOVE B,TSAVB
	.DISMISS TSINTR	;AND DISMISS THE INTERRUPT

; HERE IF INTERRUPTED IN OTHER THAN GC

GETTBL:	EXCH P,GCPDL	;USE GC PDL
	JUMPL A,ST2	;2ND WORD?
	IORM A,PIRQ	;NO, STORE
	JRST DIRQ

ST2:	TLZ A,400000	;KILL SIGN
	IORM A,PIRQ2	;AND STORE

DIRQ:	MOVE A,PIRQ	;NOW, START PROCESSING
	JFFO A,FIRQ	;COUNT BITS AND GO
	MOVE A,PIRQ2	;1ST DONE, LOOK AT 2ND
	JFFO A,FIRQ2

INTDN1:	EXCH P,GCPDL	;RESTORE STACK POINTER
	JRST INTDON	;AND DISMISS

FIRQ:	PUSHJ P,GETBIT	;SET UP THE BIT TO CLOBBER IN PIRQ
	ANDCAM A,PIRQ	;CLOBBER IT
	ADDI B,36.	;OFSET INTO TABLE
	JRST XIRQ	;GO EXECUTE

FIRQ2:	PUSHJ P,GETBIT	;PREPARE TO CLOBBER BIT
	ANDCAM A,PIRQ2	;CLOBBER IT
	ADDI A,71.	;AGAIN OFFSET INTO TABLE

XIRQ:	PUSH P,B	;SAVE OFFSET
	LSH B,1	;BECAUSET TO WRDS PER ENTRY
	ADD B,ITSINT+1(TVP)	;POINT INTO TABLE
	HRRZ B,(B)	;POINT TO IMMEDIATE ACTION ROUTINE
	JUMPE B,UAI	;UNASSIGNED, BAD ERROR

	EXCH B,(P)	;RESTORE ORIGINAL OFFSET AND PUT LOC ON STACK
	PUSHJ P,@(P)	;GO TO ROUTINE

	SUB P,[1,,1]	;POP OFF RANDOMNESS
	JRST DIRQ	;LOOK FOR ANOTHER INTERRUPT

;SUBROUTINE TO GET BIT FOR CLOBBERAGE

GETBIT:	MOVNS B	;NEGATE
	MOVSI A,400000	;GET THE BIT
	LSH A,(B)	;SHIFT TO POSITION
	POPJ P,	;AND RETURN

;HERE TO HANDLE PDL OVERFLOW.  ASK FOR A GC

IPDLOV:	MOVEI A,200000	;GET BIT TO CLOBBER
	ANDCAM A,PIRQ
	IORM A,SPIRQ	;LEAVE A MESSAGE FOR HIGHER LEVEL

	SKIPE GCFLG	;IS GC RUNNING?
	JRST GCPLOV	;YES, COMPLAIN GROSSLY

	EXCH P,GCPDL	;GET A WINNING PDL
	HRRZ B,TSINTR	;GET POINTER TO LOSING INSTRUCTION
	SUB B,PCOFF	;FUDGE IF NEEDED
	HRRM B,TSINTR	;CAUSE RETURN TO LOCATION OF LOSS
	LDB B,[270400,,(B)]	;GET AC FIELD
	CAIN B,P	;IS IT P
	MOVEI B,GCPDL	;POINT TO SAVED P

	CAIN B,B	;OR IS IT B ITSELF
	MOVEI B,TSAVB
	CAIN B,A	;OR A
	MOVEI B,TSAVA

	CAIN B,C	;OR C
	MOVEI C,2(P)	;C WILL BE ON THE STACK

	PUSH P,A	;SAVE MORE ACS
	PUSH P,C

	MOVE A,(B)	;GET THE LOSING POINTER
	MOVEI C,(A)	;AND ISOLATE RH

	CAMG C,VECTOP	;CHECK IF IN GC SPACE
	CAMG C,VECBOT
	JRST NOGROW	;NO, COMPLAIN

	HLRZ C,A	;GET -LENGTH
	SUBI A,(C)	;POINT TO A DOPE WORD
	HRRZ C,(A)	;CHECK IF GROWN BEFORE

	CAIN C,-1	;IF RH OF DOPE WORD IS -1, LOSE
	JRST PDLOSS

	ADDI A,PDLBUF	;POINT TO REAL DOPE WORD
	HRRM A,PDLEXP	;SAVE FOR NEXT GC

	MOVE C,(B)	;RESTORE PDL POINTER
	SUB C,[PDLBUF+1,,1]	;FUDGE THE POINTER
	MOVEM C,(B)	;AND STORE IT

	POP P,C	;RESTORE THE WORLD
	POP P,A

	EXCH P,GCPDL	;GET BACK ORIG PDL
	JRST IMPCH	;LOOK FOR MORE INTERRUPTS


;HERE IF PDL OVERFLOW DURING GARBAGE COLLECTION

GCPLOV:	MOVEI A,[ASCIZ /PDL OVERFLOW DURING GARBAGE COLLECTION/]
GFATER:	MOVE P,GCPDL	;GET ORIGINAL PDL FOR TYPE OUT
	JRST FATERR	;GO TO FATAL ERROR ROUTINE

NOGROW:	MOVEI A,[ASCIZ /PDL OVERFLOW ON NON-EXPANDABLE PDL/]
	JRST FATERR

PDLOSS:	MOVEI A,[ASCIZ /PDL OVERFLOW BUFFER EXHAUSTED/]

FATERR:	PUSHJ P,MSGTYP	;TYPE THE MESSAGE
	MOVEI A,[ASCIZ /FATAL ERROR, PLEASE DUMP SO THAT MUDDLE SYSTEM PROGRAMMERS
MAY DEBUG./]
	PUSHJ P,MSGTYP	;TYPE THE LOSER MESSAGE
	PUSHJ P,OCLOS	;CLOSE THE TTY
	.VALUE
	JRST .-1


;MEMORY PROTECTION INTERRUPT

IMPV:	MOVEI A,[ASCIZ /MPV -- /]

IMPV1:	PUSHJ P,MSGTYP	;TYPE
	SKIPE GCFLG	;THESE ERRORS FATAL IN GARBAGE COLLECTOR
	JRST GCERR

	MOVE P,GCPDL	;MAKE SURE OF A WINNING PDL
ERLP:	MOVEI A,[ASCIZ /TYPE "S" TO GO TO SUPERIOR, "R" TO RESTART PROCESS./]
	PUSHJ P,IFLUSH	;FLUSH AWAITING INPUT
	PUSHJ P,MSGTYP

	PUSHJ P,READCH	;READ THE CHARACTER

	PUSHJ P,UPLO	;CONVERT TO UPPER CASE
	CAIN A,"S
	.VALUE

	CAIE A,"R	;DOES HE WANT TO RESTART
	JRST ERLP	;NO, TELL HIM AGAIN

	MCALL 0,INTABR	;ABORT THE PROCESS

INTABR:	MOVEI A,ERRET	;REAALY GO TO ERRET
	HRRM A,TSINTR
	.DISMISS TSINTR


GCERR:	MOVEI A,[ASCIZ /IN GARBAGE COLLECTOR/]
	JRST FATERR

ILOPR:	MOVEI A.[ASCIZ /ILLEGAL OPERATION./]
	JRST IMPV1

; SUBROUTINE TO CONVERT LOWER CASE LETTERS TO UPPER

UPLO:	CAIG A,172	;GEATER THAN Z?
	CAIG A,140	;NO, LESS THAN A
	POPJ P,	;YES, LOSE
	SUBI A,40	;MAKE UPPER CASE
	POPJ P,

;SUBROUTINE TO BE CALLED AT INITIALIZE TIME TO FUDGE INT PC

PCHACK:	.SUSET [.SMASK,,[200000]]	;SET FOR ONLY PDL OVERFLOW
	MOVE D,TSINT+2	;SAVE CONTENTS OF ITERRUPT HANDLER
	MOVEI A,FUNINT	;POINT TO DUMMY THEREOF
	HRRM A,TSINT+2	;AND STORE IT
	HRROI A,0	;MAKE A VERY SHORT PDL
CHPUSH:	PUSH A,0	;PUSH SOMETHING AND OVERFLOW
	.VALUE [ASCIZ /?/]	;SHOULD NEVER GET HERE

FUNINT:	HRRM D,TSINT+2	;RESTORE STANDARD HANDLER
	HRRZ D,TSINTR	;GET THE LOCATION STORED
	SUBII D,CHPUSH	;FIND THE DIFFERENCE
	MOVEM D,PCOFF	;AND SAVE
	POP P,TSINTR	; POP INTO DISMISS WORD
	.DISMISS TSINTR	;AND DISMISS


;RANDOM IMPURE CRUFT NEEDED

TSAVA:	0
TSAVB:	0
PIRQ:	0	;HOLDS REQUEST BITS FOR 1ST WORD
PIRQ2:	0	;SAME FOR WORD 2

SPIRQ:	0	;COPY TO BE USED BY LCKIN
SPIRQ2:	0

END
2NDWORD:	SKIPN GCFLG	;IS GARBAGE COLLECTION HAPPENING?
	JRST GETTBL	;NO, GO LOOK UP TABLE

	JUMPL A,GC2	;2ND WORD?
	IORM A,PIRQ	;NO, INTO WORD 1
	JRST GCQUIT	;AND DISMISS INT

GC2:	TLZ A,400000	;TURN OFF SIGN BIT
	IORM A,PIRQ2

GCQUIT:	SETOM GCINT	;WARN THE GC
INTDON:	MOVE A,TSAVA	;RESTORE ACS
	MOVE B,TSAVB
	.DISMISS TSINTR	;AND DISMISS THE INTERRUPT

; HERE IF INTERRUPTED IN OTHER THAN GC

GETTBL:	EXCH P,GCPDL	;USE GC PDL
	JUMPL A,ST2	;2ND WORD?
	IORM A,PIRQ	;NO, STORE
	JRST DIRQ

ST2:	TLZ A,400000	;KILL SIGN
	IORM A,PIRQ2	;AND STORE

DIRQ:	MOVE A,PIRQ	;NOW, START PROCESSING
	JFFO A,FIRQ	;COUNT BITS AND GO
	MOVE A,PIRQ2	;1ST DONE, LOOK AT 2ND
	JFFO A,FIRQ2

INTDN1:	EXCH P,GCPDL	;RESTORE STACK POINTER
	JRST INTDON	;AND DISMISS

FIRQ:	PUSHJ P,GETBIT	;SET UP THE BIT TO CLOBBER IN PIRQ
	ANDCAM A,PIRQ	;CLOBBER IT
	ADDI B,36.	;OFSET INTO TABLE
	JRST XIRQ	;GO EXECUTE

FIRQ2:	PUSHJ P,GETBIT	;PREPARE TO CLOBBER BIT
	ANDCAM A,PIRQ2	;CLOBBER IT
	ADDI A,71.	;AGAIN OFFSET INTO TABLE

XIRQ:	PUSH P,B	;SAVE OFFSET
	LSH B,1	;BECAUSET TO WRDS PER ENTRY
	ADD B,ITSINT+1(TVP)	;POINT INTO TABLE
	HRRZ B,(B)	;POINT TO IMMEDIATE ACTION ROUTINE
	JUMPE B,UAI	;UNASSIGNED, BAD ERROR

	EXCH B,(P)	;RESTORE ORIGINAL OFFSET AND PUT LOC ON STACK
	PUSHJ P,@(P)	;GO TO ROUTINE

	SUB P,[1,,1]	;POP OFF RANDOMNESS
	JRST DIRQ	;LOOK FOR ANOTHER INTERRUPT

;SUBROUTINE TO GET BIT FOR CLOBBERAGE

GETBIT:	MOVNS B	;NEGATE
	MOVSI A,400000	;GET THE BIT
	LSH A,(B)	;SHIFT TO POSITION
	POPJ P,	;AND RETURN

;HERE TO HANDLE PDL OVERFLOW.  ASK FOR A GC

IPDLOV:	MOVEI A,200000	;GET BIT TO CLOBBER
	ANDCAM A,PIRQ
	IORM A,SPIRQ	;LEAVE A MESSAGE FOR HIGHER LEVEL

	SKIPE GCFLG	;IS GC RUNNING?
	JRST GCPLOV	;YES, COMPLAIN GROSSLY

	EXCH P,GCPDL	;GET A WINNING PDL
	HRRZ B,TSINTR	;GET POINTER TO LOSING INSTRUCTION
	SUB B,PCOFF	;FUDGE IF NEEDED
	HRRM B,TSINTR	;CAUSE RETURN TO LOCATION OF LOSS
	LDB B,[270400,,(B)]	;GET AC FIELD
	CAIN B,P	;IS IT P
	MOVEI B,GCPDL	;POINT TO SAVED P

	CAIN B,B	;OR IS IT B ITSELF
	MOVEI B,TSAVB
	CAIN B,A	;OR A
	MOVEI B,TSAVA

	CAIN B,C	;OR C
	MOVEI C,2(P)	;C WILL BE ON THE STACK

	PUSH P,A	;SAVE MORE ACS
	PUSH P,C

	MOVE A,(B)	;GET THE LOSING POINTER
	MOVEI C,(A)	;AND ISOLATE RH

	CAMG C,VECTOP	;CHECK IF IN GC SPACE
	CAMG C,VECBOT
	JRST NOGROW	;NO, COMPLAIN

	HLRZ C,A	;GET -LENGTH
	SUBI A,(C)	;POINT TO A DOPE WORD
	HRRZ C,(A)	;CHECK IF GROWN BEFORE

	CAIN C,-1	;IF RH OF DOPE WORD IS -1, LOSE
	JRST PDLOSS

	ADDI A,PDLBUF	;POINT TO REAL DOPE WORD
	HRRM A,PDLEXP	;SAVE FOR NEXT GC

	MOVE C,(B)	;RESTORE PDL POINTER
	SUB C,[PDLBUF+1,,1]	;FUDGE THE POINTER
	MOVEM C,(B)	;AND STORE IT

	POP P,C	;RESTORE THE WORLD
	POP P,A

	EXCH P,GCPDL	;GET BACK ORIG PDL
	JRST IMPCH	;LOOK FOR MORE INTERRUPTS


;HERE IF PDL OVERFLOW DURING GARBAGE COLLECTION

GCPLOV:	MOVEI A,[ASCIZ /PDL OVERFLOW DURING GARBAGE COLLECTION/]
GFATER:	MOVE P,GCPDL	;GET ORIGINAL PDL FOR TYPE OUT
	JRST FATERR	;GO TO FATAL ERROR ROUTINE

NOGROW:	MOVEI A,[ASCIZ /PDL OVERFLOW ON NON-EXPANDABLE PDL/]
	JRST FATERR

PDLOSS:	MOVEI A,[ASCIZ /PDL OVERFLOW BUFFER EXHAUSTED/]

FATERR:	PUSHJ P,MSGTYP	;TYPE THE MESSAGE
	MOVEI A,[ASCIZ /FATAL ERROR, PLEASE DUMP SO THAT MUDDLE SYSTEM PROGRAMMERS
MAY DEBUG./]
	PUSHJ P,MSGTYP	;TYPE THE LOSER MESSAGE
	PUSHJ P,OCLOS	;CLOSE THE TTY
	.VALUE
	JRST .-1


;MEMORY PROTECTION INTERRUPT

IMP
TITLE	PRINTER ROUTINE FOR MUDDLE
RELOCATABLE
.INSRT DSK:MUDDLE >
.GLOBAL	IPNAME,TYO,FIXB,FLOATB
.GLOBAL BYTPNT,OPNCHN

FLAGS==0	;REGISTER USED TO STORE FLAGS
CARRET==15	;CARRIAGE RETURN CHARACTER
ESCHAR=="\	;ESCAPE CHARACTER
SPACE==40	;SPACE CHARACTER
ATMBIT=200000	;BIT SWITCH FOR ATOM-NAME PRINT
CSTBIT=100000	;SWITCH FOR CHARACTER STRING PRINT
VECBIT=040000	;SWITCH FOR VECTOR PRINT
NOQBIT=020000	;SWITCH FOR NO ESCAPING OF OUTPUT (PRINC)
SEGBIT=010000	;SWITCH TO INDICATE PRINTING A SEGMENT
SPCBIT=004000	;SWITCH TO INDICATE "PRINT" CALL (PUT A SPACE AFTER)
FLTBIT=002000	;SWITH TO INDICATE "FLATSIZE" CALL


P.STUF:	0

PSYM:
	EXCH A,P.STUFF
	.VALUE [ASCIZ .=P.STUF!QîP.STUF/Q!:VP ]
	PUSH AP, (A)
	PUSH AP, 1(A)
	MCALL 1,PRINT
	EXCH A,P.STUFF
	POPJ P,

P.=PUSHJ P, PSYM

MFUNCTION	FLATSIZE,SUBR
	DEFINE FLTMAX
		2(AB)TERMIN
	DEFINE FLTSIZ
		4(AB)TERMIN
	;FLATSIZE TAKES TWO ARGUMENTS: THE FIRST IS AN OBJECT THE SECOND
	;IS THE MAXIMUM SIZE BEFORE IT GIVES UP AN RETURNS FALSE
	ENTRY 2
	HLRZ A,2(AB)
	CAIN A,TFIX
	JRST FLAT1
	;IF THE SECOND ARGUMENT IS NOT FIXED POINT LOSE
	PUSH AP,$TATOM
	PUSH AP,MQUOTE WRONG-TYPE
	PUSH AP,2(AB)
	PUSH AP,3(AB)
	MCALL 2,ERROR
	JRST FINIS

FLAT1:	PUSH AP,$TFIX
	PUSH AP,[0]	;THE VALUE IS ACCUMULATED IN FLTSIZ
	PUSH P,FLAGS	;SAVE THE BAG CHOMPING FLAGS
	MOVSI FLAGS,FLTBIT
	MOVE A,(AB)	;SILLY IPRINT TAKES ITS ARGUMENT A AND B
	MOVE B,1(AB)
	PUSHJ P,IPRINT
	MOVE A,FLTSIZ
	MOVE B,FLTSIZ+1
	JRST FINIS

MFUNCTION	PRINT,SUBR
	ENTRY	
	PUSH	P,FLAGS	;SAVE THE FLAGS REGISTER
	MOVSI	FLAGS,SPCBIT	;INDICATE PRINTING OF SPACE WHEN DONE
	JRST	PRIN01	;CALL IPRINT AFTER SAVING STUFF

MFUNCTION	PRINC,SUBR
	ENTRY	
	PUSH	P,FLAGS	;SAVE THE FLAGS REGISTER
	MOVSI	FLAGS,NOQBIT	;INDICATE PRINC (NO QUOTES OR ESCAPES)
	JRST	PRIN01	;CALL IPRINT AFTER SAVING STUFF

MFUNCTION	PRIN1,SUBR
	ENTRY	
	PUSH	P,FLAGS	;SAVE FLAGS REGISTER
	MOVEI	FLAGS,0	;ZERO (TURN OFF) ALL FLAGS

PRIN01:	PUSH	P,C	;SAVE REGISTERS C,D, AND E
	PUSH	P,D
	PUSH	P,E
	PUSH	TP,$TFIX	;PUT DUMMY ITEM @ TB FOR TEMPORARIES
	PUSH	TP,[0]	;USED FOR CHANNEL POINTER

	HLRZ	C,AB	;GET THE AOBJN COUNT FROM AB
	CAIN	C,-2	;SKIP IF NOT JUST ONE ARGUMENT GIVEN
	JRST	DEFCHN	;ELSE USE EXISTING BINDING OF "OUTCHAN"
	CAIE	C,-4	;ELSE, THERE MUST BE ONLY TWO ARGUMENTS
	JRST	ARGERR	;MORE ARGUMENTS IS AN ERROR

	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE OUTCHAN
	PUSH	P,[1]
	PUSHJ	P,SPECBIND
	SUB	P,[1,,1]

DEFCHN:	MOVE	B,MQUOTE OUTCHAN
	MOVSI	A,TATOM
	PUSHJ	P,IVAL	;GET VALUE OF CHANNEL
	CAME	A,$TCHAN	;SKIP IF IT IS A VALID SINGLE CHANNEL
	JRST	CHNERR	;CAN'T HANDLE ANYTHING ELSE (FOR NOW)

	MOVEM	A,(TB)	;SAVE CHANNEL POINTER ON STACK
	MOVEM	B,1(TB)
	SKIPN	IOINS(B)	;SKIP IF I/O INSTRUCTION IS NON-ZERO
	PUSHJ	P,OPNCHN	;ELSE TRY TO OPEN THE CHANNEL
	JUMPE	B,CHNERR	;ERROR IF IT CANNOT BE OPENED
	MOVE	C,[ASCII /PRINT/]
	CAME	C,DIRECT(B)	;SKIP IF CHANNEL IS OPEN FOR OUTPUT
	JRST	CHNERR	;ELSE IT IS AN ERROR
	MOVEI	A,CARRET	;GET A CARRIAGE RETURN
	TLNE	FLAGS,SPCBIT	;TYPE IT ONLY IF BIT IS ONE (PRINT)
	PUSHJ	P,PITYO

	MOVE	A,(AB)	;FIRST WORD OF ARGUMENT GOES INTO REG A
	MOVE	B,1(AB)	;SECOND WORD INTO REG B
	PUSHJ	P,IPRINT	;CALL INTERNAL ROUTINE TO PRINT IT

	MOVEI	A,SPACE
	TLNE	FLAGS,SPCBIT	;SKIP (PRINT A TRAILING SPACE) IF SPCBIT IS ON
	PUSHJ	P,PITYO

	SUB	TP,[2,,2]	;REMOVE TEMPORARY FROM STACK
	MOVE	A,(AB)	;GET FIRST ARGUMENT TO RETURN AS PRINT'S VALUE
	MOVE	B,1(AB)

	POP	P,E	;RESTORE REGISTERS C,D, AND E
	POP	P,D
	POP	P,C
	POP	P,FLAGS	;RESTORE THE FLAGS REGISTER
	JRST	FINIS

IPRINT:	PUSH	P,C	;SAVE REGISTER C ON THE P-STACK
	PUSH	P,FLAGS	;SAVE PREVIOUS FLAGS
	PUSH	TP,A	;SAVE ARGUMENT ON TP-STACK
	PUSH	TP,B

	INTGO		;ALLOW INTERRUPTS HERE
 
	HLRZ	A,-1(TP)	;GET THE TYPE CODE OF THE ITEM

	CAILE	A,NUMPRI	;SKIP IF TYPE NOT OUTSIDE OF VALID RANGE
	JRST	PRERR	;JUMP TO ERROR ROUTINE IF CODE TOO GREAT
	JRST	@PTBL(A)	;USE IT AS INDEX TO TRANSFER TABLE TO PRINT ITEM

DISTBL	PTBL,PUNK,[[TATOM,PATOM],[TLMNT,PLMNT],[TSEG,PSEG],[TFIX,PFIX]
[TFLOT,PFLOAT],[TLIST,PLIST],[TVEC,PVEC],[TCHRS,PCHRS],[TCHSTR,PCHSTR]
[TAB,PVEC]]

PUNK:	MOVE	C,TYPVEC+1(TVP)	;GET AOBJN-POINTER TO VECTOR OF TYPE ATOMS
	HLRZ	B,-1(TP)	;GET THE TYPE CODE INTO REG B
	LSH	B,1	;MULTIPLY BY TWO
	HRL	B,B	;DUPLICATE IT IN THE LEFT HALF
	ADD	C,B	;INCREMENT THE AOBJN-POINTER
	JUMPGE	C,PRERR	;IF POSITIVE, INDEX > VECTOR SIZE

	PUSHJ	P,RETIF1	;START NEW LINE IF NO ROOM
	MOVEI	A,"#	;INDICATE TYPE-NAME FOLLOWS
	PUSHJ	P,PITYO
	MOVE	A,(C)	;GET TYPE-ATOM
	MOVE	B,1(C)
	PUSHJ	P,IPRINT	;PRINT ATOM-NAME
	MOVEI	A,SPACE	;PRINT A SEPARATING SPACE
	PUSHJ	P,PITYO

	HRRZ	A,(C)	;GET THE STORAGE-TYPE
	JRST	@UKTBL(A)	;USE DISPATCH TABLE ON STORAGE TYPE

DISTBS	UKTBL,PRERR,[[1WORD,POCTAL],[2WORD,PLIST],[2NWORD,PVEC]
[STACK,PVEC],[BASE,PVEC]]

POCTAL:	MOVEI	A,14.	;RETURN TO NEW LINE IF 14. SPACES NOT LEFT
	PUSHJ	P,RETIF
	JRST	PRE01	;PRINT VALUE AS "*XXXXXXXXXXXX"

;INTERNAL SUBROUTINE TO HANDLE CHARACTER OUTPUT
;
PITYO:	;PRINTER ITYO USED FOR FLATSIZE FAKE OUT
	TLNN FLAGS,FLTBIT
	JRST ITYO
	AOS FLTSIZE+1	;FLATSIZE DOESN'T PRINT
		;INSTEAD IT COUNTS THE CHARACTERS THAT WOULD BE OUTPUT
	SOSL FLTMAX+1	;UNLESS THE MAXIMUM IS EXCEEDED
	POPJ P,
	MOVSI A,TFALSE	;IN WHICH CASE IT IMMEDIATELY GIVES UP AND RETURNS FALSE
	MOVEI B,0
	JRST FINIS

;THE REAL THING
;NOTE THAT THE FOLLOWING CODE HAS BUGS IF IT IS PRINTING OUT LONG
;CHARACTER STRINGS
ITYO:	PUSH	P,FLAGS	;SAVE STUFF
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C

	MOVE	B,1(TB)	;GET THE CHANNEL POINTER

	CAIE	A,^L	;SKIP IF THIS IS A FORM-FEED
	JRST	NOTFF
	SETZM	LINPOS(B)	;ZERO THE LINE NUMBER
	SETZM	CHRPOS(B)	;	AND CHARACTER NUMBER.
	MOVEI	A,^M
	PUSHJ	P,ITYO	;FIRST DO A CARRIAGE RETURN-LINE FEED
	MOVEI	A,^L
	JRST	ITYXT

NOTFF:	CAIE	A,^M	;SKIP IF IT IS A CARRIAGE RETURN
	JRST	NOTCR
	SETZM	CHRPOS(B)	;ZERO THE CHARACTER POSITION
	XCT	IOINS(B)	;OUTPUT THE C-R
	MOVEI	A,^J	;FOLLOW WITTH A LINE-FEED
	AOS	C,LINPOS(B)	;ADD ONE TO THE LINE NUMBER
	CAMG	C,PAGLN(B)	;SKIP IF THIS TAKES US PAST PAGE END
	JRST	ITYXT

	XCT	IOINS(B)	;OUTPUT THE LINE FEED
	MOVEI	A,^L	;GET A FORM FEED
	JRST	ITYXT

NOTCR:	CAIN	A,^J	;SKIP IF NOT LINE FEED
	JRST	ITYXT	;ELSE, DON'T COUNT (JUST OUTPUT IT)
	AOS	C,CHRPOS(B)	;ADD TO CHARACTER NUMBER
	CAMG	C,LINLN(B)	;SKIP IF GREATER THAN LINE LENGTH
	JRST	ITYXT

	PUSH	P,A	;SAVE CHARACTER
	MOVEI	A,^M
	PUSHJ	P,ITYO	;TYPE A CARRIAGE RETURN
	POP	P,A

ITYXT:	XCT	IOINS(B)	;OUTPUT THE CHARACTER

	POP	P,C	;RESTORE REGS & RETURN
	POP	P,B
	POP	P,A
	POP	P,FLAGS
	POPJ	P,

RETIF1:	MOVEI	A,1

RETIF:	PUSH	P,B
	PUSH	P,A

	TLNE FLAGS,FLTBIT
	JRST RETXT	;IF WE ARE IN FLATSIZE THEN ESCAPE
	MOVE	B,1(TB)	;GET THE CHANNEL POINTER
	ADD	A,CHRPOS(B)	;ADD THE CHARACTER POSITION
	CAMG	A,LINLN(B)	;SKIP IF GREATER THAN LINE LENGTH
	JRST	RETXT

	MOVEI	A,^M	;FORCE A CARRIAGE RETURN
	PUSHJ	P,PITYO

RETXT:	POP	P,A
	POP	P,B
	POPJ	P,	;RETURN

;THIS IS CODE TO HANDLE UNKNOWN DATA TYPES.
;IT PRINTS "*XXXXXX*XXXXXXXXXXXX*", WHERE THE FIRST NUMBER IS THE
;TYPE CODE IN OCTAL, THE SECOND IS THE VALUE FIELD IN OCTAL.
PRERR:	MOVEI	A,21.	;CHECK FOR 21. SPACES LEFT ON PRINT LINE
	PUSHJ	P,RETIF	;INSERT CARRIAGE RETURN IF NOT ENOUGH
	MOVEI	A,"*	;JUNK TO INDICATE ERROR PRINTOUT IN OCTAL
	PUSHJ	P,PITYO	;TYPE IT

	MOVE	E,[000300,,-2(TP)]	;GET POINTER INDEXED OFF TP SO THAT
				;TYPE CODE MAY BE OBTAINED FOR PRINTING.
	MOVEI	D,6	;# OF OCTAL DIGITS IN HALF WORD
OCTLP1:	ILDB	A,E	;GET NEXT 3-BIT BYTE OF TYPE CODE
	IORI	A,60	;OR-IN 60 FOR ASCII DIGIT
	PUSHJ	P,PITYO	;PRINT IT
	SOJG	D,OCTLP1	;REPEAT FOR SIX CHARACTERS

PRE01:	MOVEI	A,"*	;DELIMIT TYPE CODE FROM VALUE FIELD
	PUSHJ	P,PITYO

	HRLZI	E,(410300,,(TP))	;BYTE POINTER TO SECOND WORD
				;INDEXED OFF TP
	MOVEI	D,12.	;# OF OCTAL DIGITS IN A WORD
OCTLP2:	LDB	A,E	;GET 3 BITS
	IORI	A,60	;CONVERT TO ASCII
	PUSHJ	P,PITYO	;PRINT IT
	IBP	E	;INCREMENT POINTER TO NEXT BYTE
	SOJG	D,OCTLP2	;REPEAT FOR 12. CHARS

	MOVEI	A,"*	;DELIMIT END OF ERROR TYPEOUT
	PUSHJ	P,PITYO	;REPRINT IT

	JRST	PNEXT	;RESTORE REGS & POP UP ONE LEVEL TO CALLER
PFIX:	MOVEI	E,FIXB	;GET ADDRESS OF FIXED POINT CONVERSION ROUTINE
	MOVE	D,[4,,4]	;PUT # WORDS RESERVED ON STACK INTO REG F
	JRST	PNUMB	;PRINT THE NUMBER

PFLOAT:	MOVEI	E,FLOATB	;ADDRESS OF FLOATING POINT CONVERSION ROUTINE
	MOVE	D,[6,,6]	;# WORDS TO GET FROM STACK

PNUMB:	HRLI	A,1(P)	;LH(A) TO CONTAIN ADDRESS OF RETURN AREA ON STACK
	HRR	A,TP	;RH(A) TO CONTAIN ADDRESS OF DATA ITEM
	HLRZ	B,A	;SAVE RETURN AREA ADDRESS IN REG B
	ADD	P,D	;ADD # WORDS OF RETURN AREA TO BOTH HALVES OF SP
	JUMPGE	P,PDLERR	;PLUS OR ZERO STACK POINTER IS OVERFLOW
	PUSHJ	P,(E)	;CALL ROUTINE WHOSE ADDRESS IS IN REG E

	MOVE	C,(B)	;GET COUNT 0F # CHARS RETURNED
	MOVE	A,C	;MAKE SURE THAT # WILL FIT ON PRINT LINE
	PUSHJ	P,RETIF	;START NEW LINE IF IT WON'T

	HRLI	B,000700	;MAKE REG B INTO BYTE POINTER TO FIRST CHAR LESS ONE
PNUM01:	ILDB	A,B	;GET NEXT BYTE
	PUSHJ	P,PITYO	;PRINT IT
	SOJG	C,PNUM01	;DECREMENT CHAR COUNT: LOOP IF NON-ZERO

	SUB	P,D	;SUBTRACT # WORDS USED ON STACK FOR RETURN
	JRST	PNEXT	;STORE REGS & POP UP ONE LEVEL TO CALLER

PCHRS:	TLNE	FLAGS,NOQBIT+CSTBIT+ATMBIT	;SKIP IF THIS IS CHAR STRING IN ITSELF
	JRST	PCASIS	;OTHERWISE, DON'T DOUBLE-QUOTE IT

	MOVEI	A,7	;MAX # CHARS PLUS 2 " (LESS ESCAPES)
	PUSHJ	P,RETIF	;NEW LINE IF INSUFFICIENT SPACE
	MOVEI	A,""	;TYPE A DOUBLE QUOTE
	PUSHJ	P,PITYO

PCASIS:	MOVEI	D,5	;REG D IS # CHARS IN A WORD (MAX)
	HRLZI	C,(350700,,(TP))	;GET BYTE POINTER INDEXED BY TP
	LDB	A,C	;LOAD FIRST BYTE OF WORD
	SKIPA		;SKIP ILDB INTO LOOP

PCPLOP:	ILDB	A,C	;GET NEXT BYTE FROM WORD
	JUMPE	A,PCPOUT	;ZERO BYTE ENDS STRING
	TLNE	FLAGS,NOQBIT	;SKIP IF WE ARE NOT IN PRINC MODE (NOQBIT=0)
	JRST	PCPRNT	;IF BIT IS ON, PRINT WITHOUT ESCAPING
	CAIN	A,ESCHAR	;SKIP IF NOT THE ESCAPE CHARACTER
	JRST	ESCPRT	;ESCAPE THE ESCAPE CHARACTER
	CAIN	A,""	;SKIP IF NOT A DOUBLE QUOTE
	JRST	ESCPRT	;OTHERWISE, ESCAPE THE """
	IDIVI	A,CHRWRD	;CODE HERE FINDS CHARACTER TYPE
	LDB	B,BYTPNT(B)	; "
	CAIN	B,1	;SKIP IF NOT A NUMBER/LETTER
	JRST	PCPRNT	;OTHERWISE, PRINT IT
	TLNN	FLAGS,ATMBIT	;SKIP IF PRINTING AN ATOM-NAME (UNQUOTED)
	JRST	PCPRNT	;OTHERWISE, NO OTHER CHARS TO ESCAPE

ESCPRT:	MOVEI	A,ESCHAR	;TYPE THE ESCAPE CHARACTER
	PUSHJ	P,PITYO	

PCPRNT:	LDB	A,C	;GET THE CHARACTER AGAIN
	PUSHJ	P,PITYO	;PRINT IT
	SOJG	D,PCPLOP	;LOOP THROUGH WORD

PCPOUT:	TLNE	FLAGS,NOQBIT+CSTBIT+ATMBIT	;SKIP IF NOT PRINTING A CHARACTER STRING VECTOR,
				;OR IF AN ATOM NAME, OR IF IN PRINC MODE.
	JRST	PNEXT	;RESTORE REGS & POP UP ONE LEVEL TO CALLER

	MOVEI	A,""	;TYPE A DOUBLE QUOTE TO CLOSE STRING
	PUSHJ	P,PITYO
	JRST	PNEXT	;RESTORE REGS & POP UP ONE LEVEL TO CALLER

PATOM:	POP	TP,B	;GET SECOND WORD OF ATOM-ITEM
	POP	TP,A	;GET FIRST WORD
	HRRZ	C,A	;SAVE CDR FIELD IN REG C
	PUSHJ	P,IPNAME	;GET ATOM'S PRINT NAME
	HRR	A,C	;PUT OLD CDR INTO NEW ITEM
	MOVE	FLAGS,(P)	;RESTORE FLAGS

	TLO	FLAGS,ATMBIT	;INDICATE ATOM-NAME PRINT OUT
	PUSH	TP,A	;PUT RETURNED NAME ITEM ONTO STACK
	PUSH	TP,B	;FOR USE BY PRINT ROUTINES
	HLRZ	A,A	;PUT TYPE CODE INTO RH(A)
	CAIE	A,TCHRS	;SKIP IF ITEM IS TCHRS (5 CHARS OR LESS)
	JRST	PVECHR	;OTHERWISE, CHARACTER VECTOR RETURNED

	MOVEI	A,5	;MAX CHARS POSSIBLE IS 5
	PUSHJ	P,RETIF	;NEW LINE IF LESS THAN 5 SPACES LEFT
	JRST	PCHRS	;PRINT ONE-WORD CHARACTER ITEM

PVECHR:	HLRE	A,(TP)	;GET AOBJN-COUNT OF CHARACTER VECTOR
	MOVM	A,A	;GET ABSOLUTE VALUE
	LSH	A,-1	;DIVIDE BY 2
	IMULI	A,5	;TIMES 5 FOR MAX # CHARS IN STRING (LESS ESCAPES)
	PUSHJ	P,RETIF	;NEW LINE IF NOT ENOUGH SPACE
	PUSHJ	P,PVECTR	;CALL INTERNAL VECTOR PRINTER
	JRST	PNEXT	;RESTORE REGS & POP UP ONE LEVEL TO CALLER

PVEC:	PUSHJ	P,RETIF1	;NEW LINE IF NO ROOM FOR [
	MOVEI	A,"[	;PRINT A LEFT-BRACKET
	PUSHJ	P,PITYO
	TLO	FLAGS,VECBIT	;SET VECTOR PRINT BIT
	PUSHJ	P,PVECTR	;CALL INTERNAL VECTOR PRINTER
	PUSHJ	P,RETIF1	;NEW LINE IF NO ROOM FOR ]
	MOVEI	A,"]	;PRINT A RIGHT-BRACKET
	PUSHJ	P,PITYO
	JRST	PNEXT

PCHSTR:	HLRE	A,(TP)	;GET AOBJN-COUNT FROM ITEM
	MOVM	A,A	;GET MAGNITUDE
	LSH	A,-1	;DIVIDE BY 2
	IMULI	A,5	;TIMES 5 FOR MAX # CHARACTERS (LESS ESCAPES)
	TLNN	FLAGS,NOQBIT	;SKIP (NO QUOTES) IF IN PRINC (BIT ON)
	ADDI	A,2	;PLUS TWO FOR QUOTES
	PUSHJ	P,RETIF	;START NEW LINE IF NO SPACE
	TLNE	FLAGS,NOQBIT	;SKIP (PRINT ") IF BIT IS OFF (NOT PRINC)
	JRST	PCHS01	;OTHERWISE, DON'T QUOTE
	MOVEI	A,""	;PRINT A DOUBLE QUOTE
	PUSHJ	P,PITYO

PCHS01:	TLO	FLAGS,CSTBIT	;SET FLAG FOR CHARACTER STRING PRINTING
	PUSHJ	P,PVECTR	;CALL INTERNAL VECTOR PRINT ROUTINE

	TLNE	FLAGS,NOQBIT	;AGAIN, SKIP IF DOUBLE-QUOTING TO BE DONE
	JRST	PNEXT	;RESTORE REGS & POP UP ONE LEVEL TO CALLER
	MOVEI	A,""	;PRINT A DOUBLE QUOTE
	PUSHJ	P,PITYO
	JRST	PNEXT


PVECTR:	MOVE	C,(TP)	;GET AOBJN POINTER TO VECTOR
	TLNN	C,777777	;SKIP IF POINTER-COUNT IS NON-ZERO
	POPJ	P,	;OTHERWISE, RETURN
PVCR01:	MOVE	A,(C)	;PUT FIRST WORD OF NEXT ELEMENT INTO REG A
	MOVE	B,1(C)	;SECOND WORD OF LIST INTO REG B
	PUSHJ	P,IPRINT	;PRINT THAT ELEMENT

	MOVE	C,(TP)	;GET AOBJN POINTER FROM TP-STACK
	AOBJP	C,PDLERR	;POSITIVE HERE SERIOUS ERROR! (THOUGH NOT PDL)
	AOBJN	C,.+2	;SKIP AND CONTINUE LOOP IF COUNT NOT ZERO
	POPJ	P,	;RETURN TO CALLER
	MOVEM	C,(TP)	;PUT INCREMENTED POINTER BACK ON TP-STACK

	TLNE	FLAGS,ATMBIT+CSTBIT	;PRINT INTERMEDIATE SPACE (SKIP) ONLY IF NOT
					;IN THE PROCESS OF PRINTING NAME OR STRING.
	JRST	PVCR01	;OTHERWISE, JUST CONTINUE LOOP THROUGH VECTOR

	MOVEI	A," 	;PRINT A SPACE
	PUSHJ	P,PITYO
	JRST	PVCR01	;CONTINUE LOOPING THROUGH OBJECTS ON VECTOR

PLIST:	PUSHJ	P,RETIF1	;NEW LINE IF NO SPACE LEFT FOR "("
	MOVEI	A,"(	;TYPE AN OPEN PAREN
	PUSHJ	P,PITYO
	PUSHJ	P,LSTPRT	;PRINT THE INSIDES
	PUSHJ	P,RETIF1	;NEW LINE IF NO ROOM FOR THE CLOSE PAREN
	MOVEI	A,")	;TYPE A CLOSE PAREN
	PUSHJ	P,PITYO
	JRST	PNEXT

PSEG:	TLOA	FLAGS,SEGBIT	;PRINT A SEGMENT (& SKIP)

PLMNT:	TLZ	FLAGS,SEGBIT	;PRINT AN ELEMENT

PLMNT3:	MOVE	C,(TP)
	JUMPE	C,PLMNT1	;IF THE CALL IS EMPTY GO AWAY
	MOVE	B,1(C)
	CAME	B,MQUOTE VALUE
	JRST	PLMNT2

;ITS A VALUE
	HRRZ	C,(C)
	HLRZ	A,(C)
	CAIE	A,TATOM
	JRST	PLMNT1

;ITS VALUE OF AN ATOM
	HLLZ	A,(C)
	MOVE	B,1(C)
	HRRZ	C,(C)
	JUMPN	C,PLMNT1	;IF TERE ARE EXTRA ARGS GO AWAY

	PUSH	AP,A
	PUSH	AP,B
	TLNN	FLAGS,SEGBIT	;SKIP (CONTINUE) IF THIS IS A SEGMENT
	JRST	PLMNT4	;ELSE DON'T PRINT THE "."

;ITS A SEGMENT CALL
	PUSHJ	P,RETIF1
	MOVEI	A,".
	PUSHJ	P,PITYO

PLMNT4:	PUSHJ	P,RETIF1
	MOVEI	A,".
	PUSHJ	P,PITYO
	POP	AP,B
	POP	AP,A
	PUSHJ	P,IPRINT
	JRST	PNEXT

PLMNT2:	CAME	B,MQUOTE QUOTE
	JRST	PLMNT1

;ITS A QUOTE
	TLNE	FLAGS,SEGBIT	;SKIP (CONTINUE) ONLY IF NOT A SZEGMENT
	JRST	PLMNT1	;ELSE DON'T TRANSLATE QUOTE
	PUSHJ	P,RETIF1
	MOVEI	A,"'
	PUSHJ	P,PITYO
	MOVE	C,(TP)
	HRRZ	C,(C)
	HLLZ	A,(C)
	MOVE	B,1(C)
	PUSHJ	P,IPRINT
	JRST	PNEXT

PLMNT1:	TLNN	FLAGS,SEGBIT	;SKIP IF THIS IS A SEGMENT
	JRST	PLMNT5	;ELSE DON'T TYPE THE "."

;ITS A SEGMENT CALL
	PUSHJ	P,RETIF1
	MOVEI	A,".
	PUSHJ	P,PITYO
PLMNT5:	PUSHJ	P,RETIF1	
	MOVEI	A,"<
	PUSHJ	P,PITYO
	PUSHJ	P,LSTPRT
	PUSHJ	P,RETIF1
	MOVEI	A,">
	PUSHJ	P,PITYO
	JRST	PNEXT

LSTPRT:	INTGO	;WATCH	OUT FOR GARBAGE COLLECTION!
	SKIPN	C,(TP)
	POPJ	P,
	HLLZ	A,(C)	;GET NEXT ELEMENT
	MOVE	B,1(C)
	HRRZ	C,(C)	;CHOP THE LIST
	JUMPN	C,PLIST1
	PUSHJ	P,IPRINT	;PRINT THE LAST ELEMENT
	POPJ	P,

PLIST1:	MOVEM	C,(TP)
	PUSHJ	P, IPRINT	;PRINT THE NEXT ELEMENT
	PUSHJ	P,RETIF1
	MOVEI	A," 
	PUSHJ	P,PITYO	;PRINT THE SPACE AFTER THE NEXT ELEMENT
	JRST	LSTPRT	;REPEAT

PNEXT:	POP	P,FLAGS	;RESTORE PREVIOUS FLAG BITS
	SUB	TP,[2,,2]	;REMOVE	INPUT ELEMENT FROM TP-STACK
	POP	P,C	;RESTORE REG C
	POPJ	P,

PDLERR:	.VALUE	0	;P-STACK OVERFLOW, VERY SERIOUS, MUDDLE DIES!

CHNERR:	PUSH	AP,$TATOM
	PUSH	AP,MQUOTE BAD-CHANNEL
	JRST	CALER1

ARGERR:	PUSH	AP,$TATOM	;TYPE WRONG # ARGUMENTS
	PUSH	AP,MQUOTE WRONG-NUMBER-OF-ARGUMENTS
	JRST	CALER1

END

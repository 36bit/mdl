; Standard uuo's for TAPFTP.  Stolen from
; NCOMBAT.  Currently defined uuos and function:  (E is the effective address)
; OOCT--prints contents of E as octal
; ODEC--prints the contents of the effective address as a decimal number
; OBPTR--E contains a byte pointer to ASCIZ, which will be printed out
; OHPOS--sets the horizontal position of the cursor to E (uses H, so
;    must be used on tty channel)
; OHPOS--sets vertical position
; OCTLP--prints E in display mode, preceded by ctrl-P
; OSIX--prints contents of E as sixbit
; OASC--E is the first word of an ASCIZ string
; OASCI--print the character E
; OASCR--like OASC, but follows the string with a carriage return
; OOCTA, ODECA, OASCA, OASCIA, OSIXA take in AC and AC+1 a count and byte
; pointer, where their 'output' will be stuffed.  AC and AC+1 will be
; updated appropriately.
; In all cases, output goes to TTYO, which is assumed to be opened in
; non-display mode (OCTLP and OHPOS set %TJDIS).
; IBLOCK--takes number of words needed as E, returns pointer to them in 
; ac.
; SIXSTR--takes word of sixbit, returns in ac byte pointer to string
; All the output uuos use the ac as the channel number.
; If the symbol .U"UUOERR is defined and non-zero, the package will
; provide for an ERROR uuo, with a handler at .U"UERROR.
; The crock will be called via a jrst, with the effective address in UUOE,
; the contents of the effective address in UUOD, and the AC in E.
; It should return via a JRST UUORET.  The contents of UUOX, if non-zero,
; will be executed before the return but after all the ac's have been restored.
; Useful for putting a value into an ac or something.

.BEGIN UUOS
.AUXIL

; LOSSAGES
DEFINE FATINS NAME\
	.VALUE	[ASCIZ /: FATAL ERROR -- !NAME!
/]
TERMIN

; DECREMENT BYTE POINTER
DEFINE DBP AC
	ADD	AC,[70000,,]
	TLNE	AC,400000
	ADD	AC,[347777,,-1]
TERMIN

; TYPEOUT UUOS

; UUO HANDLER STACK OFFSETS & VARIABLES
.M"UUOD==0			; EFFECTIVE ADDRESS
.M"UUOE==-1			; CONTENTS OF EFFECTIVE ADDRESS
; B-E ARE -5 THROUGH -2
ACN==-6				; AC FIELD
AC1==-7
AC0==-10
; O AND A ARE -12 AND -11
.M"UUOX==-13
UUO40==-14
.M"UUOHS==-15

UUOSCR:	BLOCK	2
BASE:	10.

UUOCT==0
UUOTAB:	JRST ILUUO
	IRPS X,,[ODEC OOCT OBPTR OHPOS OVPOS OCTLP OSIX OASC OASCI OASCR IBLOCK SIXSTR
		 ODECA OOCTA OSIXA OASCA OASCB]
	UUOCT==UUOCT+1
	.M"!X=UUOCT_33
	JRST U!X
	TERMIN

IFDEF .U"UUOERR,[IFN .U"UUOERR,[
UUOCT==UUOCT+1
.M"ERROR=UUOCT_33
	JRST	.U"UERROR]]	; ALLOW FOR ERROR UUO

UUOMAX==.-UUOTAB

.M"UUOH:	0
	PUSH	P,UUOH
	PUSH	P,40			; SAVE CALL INFO
	PUSH	P,[0]			; UUOX
	PUSH	P,O
	PUSH	P,A
	LDB	A,[270417,,-3]		; GET AC (-3(P))
	PUSH	P,(A)			; AC0
	PUSH	P,1(A)			; AC1
	PUSH	P,A			; ACN
	MOVE	A,-3(P)
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVEI	@-12(P)			; GET EFF ADDR. OF UUO
	PUSH	P,O			; UUOE
	PUSH	P,@0			; UUOD
	MOVE	E,ACN(P)		; AC
	MOVE	B,UUOE(P)		; EFF ADR
	LDB	C,[330617,,UUO40]	; OP CODE
	CAIL	C,UUOMAX
	MOVEI	C,0	; GRT=>ILLEGAL
	JRST	@UUOTAB(C)	; GO TO PROPER ROUT

.M"UUORET: SUB	P,[2,,2]
	POP	P,E
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POP	P,1(A)		; AC1
	POP	P,(A)		; AC0
UUORT1:	POP	P,A		; RESTORE AC'S
	POP	P,O
	SKIPE	(P)		; UUOX
	 XCT	(P)		; USED TO GET POINTER TO RIGHT AC FOR IBLOCK
	SUB	P,[2,,2]
	POPJ	P,		; UUOH PUSHED FIRST

ILUUO:	FATINS	ILLEGAL UUO
; STRING COPY UUO
UOASCA:	MOVE	B,UUOE(P)
	HRLI	B,440700
UOASAL:	ILDB	D,B
	JUMPE	D,UUORET
	IDPB	D,AC1(P)
	AOS	AC0(P)
	JRST	UOASAL

; IMMEDIATE ASCII
UOASCB:	IDPB	B,AC1(P)
	AOS	AC0(P)
	JRST	UUORET

; MOVE SIXBIT->STR
UOSIXA:	SKIPN	C,UUOD(P)
	 JRST	UUORET
	MOVE	B,AC1(P)
	PUSHJ	P,ISIXST	; DO CONVERSION
	ADDM	C,AC0(P)
	MOVEM	D,AC1(P)	; UPDATE LENGTH AND POINTER
	JRST	UUORET

; DECIMAL (OR OCTAL) TO STRING
UODECA:	SKIPA	A,DECTAB
UOOCTA:	 MOVE	A,OCTTAB
	MOVE	C,UUOD(P)	; PICK UP THE NUMBER
UONUML:	IDIV	C,(A)		; DO THE DIVISION
	JUMPN	C,UONUM1
	AOBJP	A,UONUM1
	MOVE	C,D
	JRST	UONUML
UONUM1:	ADDI	C,"0
	IDPB	C,AC1(P)
	AOS	AC0(P)
	MOVE	C,D
	AOBJP	A,UUORET
	IDIV	C,(A)
	JRST	UONUM1

DECTAB:	-5,,[10000. ? 1000. ? 100. ? 10. ? 1]
OCTTAB:	-5,,[10000 ? 1000 ? 100 ? 10 ? 1]

; STRING OUTPUT
UOBPTR:	MOVEI	C,0
	MOVE	B,UUOD(P)	; PICK UP BYTE POINTER
	JRST	UOASC1		; AND JOIN CODE
UOASCR:	SKIPA	C,[-1]		; CR FOR END OF TYPE
UOASC:	MOVEI	C,0		; NO CR
	HRLI	B,440700	; MAKE ASCII POINTER
UOASC1:	MOVEI	A,0
	PUSH	P,B		; SAVE BPTR
UOASCC:	ILDB	D,B		; GET CHAR
	JUMPE	D,UOASCD	; FINISH?
	AOJA	A,UOASCC	; AOS COUNT, GO ON
UOASCD:	POP	P,B
	PUSHJ	P,SIOTA		; SPIT IT OUT
	JUMPE	C,UUORET	; CR NEEDED?
	MOVEI	A,2		; YES
	MOVE	B,[440700,,[ASCIZ /
/]]
	PUSHJ	P,SIOTA
	JRST	UUORET

UOCTLP:	MOVEI	A,^P
	PUSHJ	P,IOTAD
	MOVE	A,B
	PUSHJ	P,IOTAD		; DISPLAY-MODE IOT
	JRST	UUORET

UOASCI:	MOVE	A,B		; PRT ASCII IMMEDIATE
	PUSHJ	P,IOTA
	JRST	UUORET

UOSIX:	SKIPN	C,UUOD(P)
	 JRST	UUORET
	MOVE	B,[440700,,UUOSCR]
	PUSHJ	P,ISIXST	; ROUTINE USED BY SIXSTR UUO (RETURNS COUNT IN C)
	MOVE	A,C
	PUSHJ	P,SIOTA
	JRST	UUORET

UOVPOS:	MOVEI	A,^P
	PUSHJ	P,IOTAD
	MOVEI	A,"V
	PUSHJ	P,IOTAD
	MOVEI	A,10(B)
	PUSHJ	P,IOTAD
	JRST	UUORET

UOHPOS:	MOVEI	A,^P
	PUSHJ	P,IOTAD
	MOVEI	A,"H
	PUSHJ	P,IOTAD
	MOVEI	A,10(B)
	PUSHJ	P,IOTAD
	JRST	UUORET

UODEC:	SKIPA	C,[10.]		; GET BASE FOR DECIMAL
UOOCT:	 MOVEI	C,8.		; OCTAL BASE
	MOVE	B,UUOD(P)	; GET ACTUAL WORD TO PRT
	JRST	.+3		; JOIN CODE
UODECI:	SKIPA	C,[10.]		; DECIMAL
UOOCTI:	MOVEI	C,8.
	MOVEM	C,BASE
	MOVEI	A,0		; A=DIGIT COUNT
	MOVE	C,B		; PUT # TO PRT IN C
	MOVE	B,[010700,,UUOSCR+1]
	PUSHJ	P,UONUM		; PRINT NUMBR
	JRST	UUORET

UONUM:	IDIV	C,BASE
	ADDI	D,"0
	CAILE	D,"9
	 ADDI	D,"A-"9-1	; MAKE HEX DIGIT, IF NOT DECIMAL
	DPB	D,B		; SAVE DIGIT
	DBP	B
	ADDI	A,1
	JUMPN	C,UONUM		; IF NON-ZERO, STILL CRAP LEFT
	PUSHJ	P,SIOTA
	POPJ	P,

IOTA:	.CALL	[SETZ
		 SIXBIT	/IOT/
		 E
		 SETZ	A]
	 .LOSE	%LSSYS
	POPJ P,
IOTAD:	.CALL	[SETZ
		 SIXBIT	/IOT/
		 MOVSI	%TJDIS	; TURN ON DISPLAY MODE FOR THIS
		 E
		 SETZ	A]
	 .LOSE	%LSSYS
	POPJ	P,
SIOTA:	.CALL	[SETZ
		 SIXBIT	/SIOT/
		 E
		 B
		 SETZ	A]
	 .LOSE	%LSSYS
	POPJ	P,

SUBTTL	CORE ALLOCATOR

; TAKES # WORDS AS EFFECTIVE ADDRESS, RETURNS POINTER IN AC SUPPLIED.
; EFFECTIVE ADDRESS IS IN B, AC IS IN A
UIBLOC:	PUSHJ	P,IIBLOC
	HRLI	B,201000		; UIBLOE RETURNS ADDRESS IN B
	DPB	E,[270400,,B]		; DEPOSIT AC INTO MOVEI <ADDRESS>
	MOVEM	B,UUOX(P)		; SAVE IT AWAY
	JRST	UUORET			; RETURN

; PUSHJ HERE WITH # WORDS NEEDED IN B, GET ADDRESS IN B.
IIBLOC:	ADD	B,FREBOT		; NEW FREBOT
UIBLO1:	CAML	B,FRETOP		; HAVE WE ALREADY ALLOCATED CORE FOR THIS?
	 JRST	MORCOR			; NO, SO DO IT
	EXCH	B,FREBOT		; STUFF IT OUT.  B NOW HAS ADDRESS TO RETURN
	POPJ	P,

MORCOR:	MOVE	C,FRETOP
	LSH	C,-12
	.CALL	[SETZ
		 SIXBIT	/CORBLK/
		 MOVEI	%CBNDW+%CBPRV
		 MOVEI	%JSELF
		 C
		 SETZI	%JSNEW]
	 FATINS	NO CORE AVAILABLE TO SATISFY REQUEST
	MOVEI	C,2000
	ADDM	C,FRETOP
	JRST	UIBLO1


; CONVERT SIXBIT TO STRING:  WORD OF SIXBIT IS CONTENTS OF EFF ADDR (UUOD)
; RETURN BPTR IN AC (WHICH IS IN A)

USIXST:	MOVEI	B,2
	PUSHJ	P,IIBLOC
	HRLI	B,440700
	SKIPN	C,UUOD(P)
	 JRST	USIXEX
	PUSHJ	P,ISIXST
USIXEX:	MOVEM	B,UUO40(P)
	MOVE	B,[MOVE	-1(P)]
	DPB	E,[270400,,B]
	MOVEM	B,UUOX(P)
	JRST	UUORET

; TAKES BPTR IN B TO BLOCK TO FILL, SIXBIT IN C; RETURNS COUNT IN C, B IS
; UNTOUCHED.  D CONTAINS ADVANCED POINTER.
ISIXST:	PUSH	P,A
	PUSH	P,B
	MOVEI	A,0
ISIXLP:	LDB	D,[360600,,C]
	ADDI	D,40
	IDPB	D,B
	ADDI	A,1
	LSH	C,6
	JUMPN	C,ISIXLP
	MOVE	C,A
	MOVE	D,B
	POP	P,B
	POP	P,A
	POPJ	P,
.END

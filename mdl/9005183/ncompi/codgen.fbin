'<PCODE "3CODGEN">

"	This file contains the major general codde generators.  These include
 variable access functions (LVAL, SETG etc.), FSUBRs (COND, AND, REPEAT)
 and a few assorted others." 

"	All generators are called with a node and a destination for the 
 result.  The destinations are either DATUMs (lists of ACs or types)
 or the special atoms DONT-CARE or FLUSHED.  Generators for
 SUBRs that can be predicates may have additional arguments when they
 are being invoked for their branching effect." 

"	The atom STK always points to a list that specifies the model
 of the TP stack." 

" Main generator, dispatches to specific code generators. " 

<SETG OTBSAV <PROG (TEM) <COND (<AND <SET TEM <LOOKUP "OTBSAV" <GET MUDDLE 
OBLIST>>> <GASSIGNED? .TEM>> ,.TEM) (ELSE <SQUOTA |OTBSAV >)>>> 

<SETG GEN  %<RSUBR!- '[ %<PCODE!- "3CODGEN" 0> GEN #DECL ("VALUE" ANY NODE <OR 
ATOM DATUM>) TIME:CHECK TIME:STACK POP:LOCS SGETREG FAST:SETG FAST:GVAL FREE-ACS
 OFFPTR STFIXIT SPEC-OFFPTR SPEC:REFERENCE:STACK FIX:ADDR NUM-SYM STORE-VAR 
STORE-TVAR GET-NUM-SYM SINACS FLUSH-COMMON-SYMT KILL-LOOP-AC FLUSH-RESIDUE ARG? 
MUNG-AC FAST:SET FAST:VAL LVAL-UP TRUE-FALSE ADDR:TYPE REG? MERGE-STATE 
CHECK:VARS SAVE-STATE FIX-NUM-SYM TYPE-OK? RESTORE-STATE SAVE-NUM-SYM 
PREFER-DATUM SAVE:RES COUNTP PRED:BRANCH:GEN PCOUNTER INTERNAL-RSUBR 
DATTYP-FLUSH GEN:FALSE D:B:TAG SEGMENT:FINAL SEGMENT:STACK SEGMENT:LIST 
SUBR:CALL TUPLE:FINAL BUMP:CNTR REFERENCE:ARGPNTR TEST:ARGPNTR BUMP:ARGPNTR 
COPY:ARGPNTR EMIT-PRE GOOD-TUPLE ADDRESS:PAIR SMASH-INACS CREATE-TMP 
ISTYPE-GOOD? MAKE:ACT REFERENCE REFERENCE:STACK TEST:ARG PUSH:ATB PUSH:PAIR 
STORE:PAIR STORE:BIND REFERENCE:ARG MAKE:ENV STACK:ARGUMENT ACT:FINAL BRANCH:TAG
 REFERENCE:UNBOUND LADDR BIND:END PUSH:BIND ADDRESS:C ALLOC:SLOTS SALLOC:SLOTS 
ACT:INITIAL END-FRAME MOVE:ARG FIX-ACLINK UNBIND:LOCS ISTYPE? ACFIX EMIT 
BIND-CODE BEGIN-FRAME MAKE:TAG FUNCTION:VALUE VAR-STORE RET-TMP-AC DATUM 
LABEL:TAG UNIQUE:TAG REGSTO MESSAGE ISTAG? %<RGLOC GENERATORS T> %<TYPE-W NODE 
VECTOR> NPRUNE ATOM WARNING " TAG SEEN IN PROG/REPEAT " T %<TYPE-C DATUM LIST> 
FLUSHED BASEF (NODE) TOT-SPEC (FIX) NTSLOTS GVAL (LIST) IDT STK PRE (ANY) FRMID 
FRMS BSTB SPECD TMPS START:TAG (ATOM) AC-HACK (<PRIMTYPE LIST>) "AGAIN" "EXIT" 
SPEC-LIST NO-KILL KILL-LIST <INTGO!-OP> %<RGLOC NO-DATUM T> %<TYPE-C AC VECTOR> 
(FUNNY-STACK) %<RGLOC ALLACS T> %<TYPE-W AC VECTOR> %<TYPE-C SYMTAB VECTOR> 
NSLOTS ![(STACK) (FUNNY-STACK)!] INTERNAL-ENTRY!-OP <`SUBM  `M*  `(P) > PSTACK 
%<TYPE-W SYMTAB VECTOR> %<TYPE-W OPCODE!-OP WORD> - %<TYPE-W TOKEN VECTOR> ![0 0
0 0 1 0 0 0 0 1 0 1 1!] %<RGLOC BINDERS T> FUDGE %<RGLOC SNODES T> DONT-CARE 
DATUM %<TYPE-W DATUM LIST> %<RGLOC POTLV T> %<TYPE-C TEMPV LIST> FCN %<TYPE-W 
TEMPV LIST> ANY-AC TYPE-WORD!-OP [0] %<TYPE-C NODE VECTOR> ITUPLE TUPLE <
`PUSH  `P*  `A > <`PUSHJ  `P*  |MAKTU2 > <`POP  `TP*  `B > <`POP  `TP*  `A > <
`MOVE  `B*  `AB > <`HLRZ  `A*  |OTBSAV  `(TB) > <`HRLI  `A*  <TYPE-CODE!-OP 
TUPLE>> FIX INTH %<RGLOC NTH T> ERROR " NON APPLICABLE OBJECT " EVAL %<RGLOC 
COPIERS T> [|IILIST  |CIVEC  |CIUVEC  TUPLE] LIST %<TYPE-W MUDREF!-OP WORD> %<
RGLOC SUBRS T> %<RGLOC TEMPLATES T> (ANY ANY) STACK <`SKIPA > %<RGLOC AC-A T> %<
RGLOC AC-B T> <`POP  `P*  `A > %<RGLOC RET-TMP-AC T> ALL "BAD ARG TO " IND 
GROUP-NAME (STACK) %<TYPE-W IRSUBR LIST> ![!] <`MOVE  `A*  `AB > [<2 (2)>] <
`HLRES  `A > <`ASH  `A*  -1> <`MOVMS  `A > <`JRST  |FINIS > CAREFUL <`JRST  
|COMPER > MQUOTE!-OP APPLY %<TYPE-W SAVED-STATE LIST> "COND" FALSE 
"NON REACHABLE COND CLAUSE(S) " "PHRASE" "COND PREDICATE ALWAYS FALSE" NO-RETURN
 SNMUSYM "NON REACHABLE COND CLAUSE(S)" <NOT FALSE> NOTE "BOOL" ANY 
"NON REACHABLE AND/OR CLAUSE" GETYP!-OP <TYPE-CODE!-OP UNBOUND> %<RGLOC DEATH T>
 STORE-SET PSLOT INCONSISTENCY "BAD CALL TO ADD:STACK " (-2) FUZZ %<RGLOC OTBSAV
T> VECTOR $TTB INCONSISTANCY "BAD FRAME MODEL " "BAD VARIABLE ADDRESS " %<RGLOC 
USE-RGLOC T> GLUE LOCR TYPE-CODE!-OP %<RGLOC AC-C T> %<RGLOC AC-E T> <`PUSHJ  
`P*  |POPUNW > <`JRST  |UNWIN2 > ![READCHR NEXTCHR!] READCHR <`CAIA > %<RGLOC 
GETTERS T> %<RGLOC AC-D T> ![|CIGETP  |CIGTPR  |CIGETL  |CIGET !] <`JFCL >]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,GEN PGLUE ![715827882 -22906492246 
-22906492246 -22906492246 -22906492246 -22906491905 -1 -1 -1 -1 -1 -1 -1 -1 
-67108864 0 0!]>> 


" Generate a sequence of nodes flushing all values except the ladt." 

<SETG SEQ-GEN %<RSUBR-ENTRY '[GEN SEQ-GEN #DECL ("VALUE" <OR ATOM DATUM> <LIST [
REST NODE]> <OR ATOM DATUM> "OPTIONAL" ANY ANY ANY)] 43>> 

" The main code generation entry (called from CDRIVE).  Sets up initial
 stack model, calls to generate code for the bindings and generates code for
 the function's body." 

<SETG CODE-GEN %<RSUBR-ENTRY '[GEN CODE-GEN #DECL ("VALUE" ANY NODE)] 219>> 

" Generate code for setting up and binding agruments." 

<SETG BIND-CODE %<RSUBR-ENTRY '[GEN BIND-CODE #DECL ("VALUE" ANY NODE "OPTIONAL"
ANY)] 745>> 

<SETG OPT-CHECK %<RSUBR-ENTRY '[GEN OPT-CHECK #DECL ("VALUE" <OR ATOM FALSE> <
LIST [REST SYMTAB]> FIX <UVECTOR [REST ATOM]>)] 1473>> 

" Generate \"BIND\" binding code." 

<SETG BIND-B %<RSUBR-ENTRY '[GEN BIND-B #DECL ("VALUE" ANY SYMTAB)] 1639>> 

" Do code generation for normal  arguments." 

<SETG NORM-B %<RSUBR-ENTRY '[GEN NORM-B #DECL ("VALUE" ANY SYMTAB)] 1655>> 

" Initialized optional argument binder." 

<SETG OPT1-B %<RSUBR-ENTRY '[GEN OPT1-B #DECL ("VALUE" ANY SYMTAB)] 1719>> 

" Uninitialized optional argument binder." 

<SETG OPT2-B %<RSUBR-ENTRY '[GEN OPT2-B #DECL ("VALUE" ANY SYMTAB)] 1739>> 

" Create a binding either by pushing or moving if slots PRE created." 

<SETG BINDUP %<RSUBR-ENTRY '[GEN BINDUP #DECL ("VALUE" ANY SYMTAB DATUM 
"OPTIONAL" ANY)] 1752>> 

" Push or store a non special argument." 

<SETG CLOB:PAIR %<RSUBR-ENTRY '[GEN CLOB:PAIR #DECL ("VALUE" ANY SYMTAB ANY 
DATUM)] 1855>> 

" Create a binding for either intitialized or unitialized optional." 

<SETG OPTBIND %<RSUBR-ENTRY '[GEN OPTBIND #DECL ("VALUE" ANY SYMTAB "OPTIONAL" 
NODE)] 1898>> 

" Do a binding for a named activation." 

<SETG ACT-B %<RSUBR-ENTRY '[GEN ACT-B #DECL ("VALUE" ANY SYMTAB)] 2107>> 

" Bind an \"AUX\" variable." 

<SETG AUX1-B %<RSUBR-ENTRY '[GEN AUX1-B #DECL ("VALUE" ANY SYMTAB)] 2126>> 

" Do a binding for an uninitialized \"AUX\" " 

<SETG AUX2-B %<RSUBR-ENTRY '[GEN AUX2-B #DECL ("VALUE" ANY SYMTAB)] 2363>> 

<SETG TUPCHK %<RSUBR-ENTRY '[GEN TUPCHK #DECL ("VALUE" ANY <OR FALSE NODE> 
"OPTIONAL" ANY)] 2513>> 

" Do a \"TUPLE\" binding." 

<SETG TUPLE1-B %<RSUBR-ENTRY '[GEN TUPLE1-B #DECL ("VALUE" ANY SYMTAB)] 2621>> 

<SETG TUPL-B %<RSUBR-ENTRY '[GEN TUPL-B #DECL ("VALUE" ANY SYMTAB)] 2655>> 

" Generate the code to actually build a TUPLE." 

<SETG BUILD:TUPLE %<RSUBR-ENTRY '[GEN BUILD:TUPLE #DECL ("VALUE" ANY FIX)] 2717>
> 

" Dispatch table for binding generation code." 

<SETG BINDERS ![,ACT-B ,AUX1-B ,AUX2-B ,TUPL-B ,NORM-B ,OPT1-B ,OPT1-B ,OPT2-B ,
OPT2-B ,NORM-B ,BIND-B ,NORM-B ,NORM-B!]> 

<COND (<GASSIGNED? NOTIMP> <SETG MBINDERS [,ACT-B ,AUX1-B ,AUX2-B ,NOTIMP ,
MENTROPY ,MOPTG ,MOPTG ,MOPTG2 ,MOPTG2 ,MENTROPY ,BIND-B ,MENTROPY ,MENTROPY]>)> 

" Appliacation of a form could still be an NTH." 

<SETG FORM-F-GEN %<RSUBR-ENTRY '[GEN FORM-F-GEN #DECL ("VALUE" ANY NODE ANY)] 
2760>> 

" Generate a call to EVAL for uncompilable FORM." 

<SETG FORM-GEN %<RSUBR-ENTRY '[GEN FORM-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 2872>> 

" Generate code for LIST/VECTOR etc. evaluation." 

<SETG COPY-GEN %<RSUBR-ENTRY '[GEN COPY-GEN #DECL ("VALUE" DATUM NODE <OR ATOM 
DATUM>)] 2944>> 

<SETG COPIERS ![TUPLE UVECTOR VECTOR LIST!]> 

"Generate code for a call to a SUBR." 

<SETG SUBR-GEN %<RSUBR-ENTRY '[GEN SUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 3269>> 

" Compile call to a SUBR that doesn't compile or PUSHJ." 

<SETG COMP:SUBR:CALL %<RSUBR-ENTRY '[GEN COMP:SUBR:CALL #DECL ("VALUE" ANY ANY <
LIST [REST NODE]> FIX ANY)] 3291>> 

<SETG GET-TMPS %<RSUBR-ENTRY '[GEN GET-TMPS #DECL ("VALUE" <LIST [2 ANY]> ANY)] 
3438>> 

" Generate calls to SUBRs using the internal PUSHJ feature." 

<SETG ISUBR-GEN %<RSUBR-ENTRY '[GEN ISUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> "OPTIONAL" ANY ANY ANY)] 3481>> 

<SETG STACK-ARGS %<RSUBR-ENTRY '[GEN STACK-ARGS #DECL ("VALUE" <OR FALSE FIX> 
NODE ANY)] 3889>> 

" Get a bunch of goodies into ACs for a PUSHJ call." 

<SETG AC-ARGS %<RSUBR-ENTRY '[GEN AC-ARGS #DECL ("VALUE" <OR ATOM FALSE FIX> 
NODE LIST)] 4009>> 

<SETG SIDES %<RSUBR-ENTRY '[GEN SIDES #DECL ("VALUE" <OR ATOM FALSE> <LIST [REST
NODE]>)] 4249>> 

" Generate code for a call to an RSUBR (maybe PUSHJ)." 

<SETG RSUBR-GEN %<RSUBR-ENTRY '[GEN RSUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM>)] 4314>> 

" Generate a call to an internal compiled goodies using a PUSHJ." 

<SETG IRSUBR-GEN %<RSUBR-ENTRY '[GEN IRSUBR-GEN #DECL ("VALUE" ANY NODE <OR ATOM
DATUM>)] 4542>> 

" Get the arguemnts to a FUNCTION into the ACs." 

<SETG ARGS-TO-ACS %<RSUBR-ENTRY '[GEN ARGS-TO-ACS #DECL ("VALUE" ANY ANY)] 4631>
> 

" Push the args supplied in ACs onto the stack." 

<SETG ACS-TO-STACK %<RSUBR-ENTRY '[GEN ACS-TO-STACK #DECL ("VALUE" FIX LIST)] 
4922>> 

<SETG AC-SEG-CALL %<RSUBR-ENTRY '[GEN AC-SEG-CALL #DECL ("VALUE" ANY LIST)] 4974
>> 

" Generate PUSHJ in stack arg case (may go different places)" 

<SETG STACK-CALL %<RSUBR-ENTRY '[GEN STACK-CALL #DECL ("VALUE" ANY FIX FIX <
UVECTOR [REST ATOM]> <OR FIX FALSE> <OR ATOM FALSE>)] 5108>> 

" Generate code for a stackform." 

<SETG STACKFORM-GEN %<RSUBR-ENTRY '[GEN STACKFORM-GEN #DECL ("VALUE" ANY NODE <
OR ATOM DATUM>)] 5420>> 

" Generate code for a COND." 

<SETG COND-GEN %<RSUBR-ENTRY '[GEN COND-GEN #DECL ("VALUE" ANY NODE <OR ATOM 
DATUM> "OPTIONAL" ANY ANY ANY)] 5612>> 

<SETG PSEQ-GEN %<RSUBR-ENTRY '[GEN PSEQ-GEN #DECL ("VALUE" ANY <LIST [REST NODE]
> ANY ANY ANY ANY)] 6778>> 

<SETG COND-COMPLAIN %<RSUBR-ENTRY '[GEN COND-COMPLAIN #DECL ("VALUE" ANY ANY 
NODE)] 6837>> 

<SETG SAVE-TYP %<RSUBR-ENTRY '[GEN SAVE-TYP #DECL ("VALUE" <OR ATOM FALSE> NODE)
] 6856>> 

<SETG MERGE-STATES %<RSUBR-ENTRY '[GEN MERGE-STATES #DECL ("VALUE" ANY ANY)] 
6875>> 

" Fixup where its going better or something?" 

<SETG UPDATE-WHERE %<RSUBR-ENTRY '[GEN UPDATE-WHERE #DECL ("VALUE" <OR ATOM 
DATUM> NODE <OR ATOM DATUM>)] 6997>> 

" Generate code for OR use BOOL-GEN to do work." 

<SETG OR-GEN %<RSUBR-ENTRY '[GEN OR-GEN #DECL ("VALUE" ANY NODE ANY "OPTIONAL" 
ANY ANY ANY)] 7052>> 

" Generate code for AND use BOOL-GEN to do work." 

<SETG AND-GEN %<RSUBR-ENTRY '[GEN AND-GEN #DECL ("VALUE" ANY NODE ANY "OPTIONAL"
ANY ANY ANY)] 7114>> 

<SETG BOOL-GEN %<RSUBR-ENTRY '[GEN BOOL-GEN #DECL ("VALUE" ANY NODE <LIST [REST 
NODE]> ANY <OR DATUM ATOM> ANY <OR ATOM FALSE> ANY)] 7175>> 

" Get the best set of acs around for this guy." 

<SETG GOODACS %<RSUBR-ENTRY '[GEN GOODACS #DECL ("VALUE" <OR ATOM DATUM> NODE 
ANY)] 7843>> 

" Generate code for ASSIGNED?" 

<SETG ASSIGNED?-GEN %<RSUBR-ENTRY '[GEN ASSIGNED?-GEN #DECL ("VALUE" ANY NODE 
ANY "OPTIONAL" ANY ANY ANY)] 7928>> 

" Generate code for LVAL." 

<SETG LVAL-GEN %<RSUBR-ENTRY '[GEN LVAL-GEN #DECL ("VALUE" <OR DATUM FALSE> NODE
ANY)] 8120>> 

<SETG DELAY-KILL %<RSUBR-ENTRY '[GEN DELAY-KILL #DECL ("VALUE" ATOM LIST LIST)] 
8462>> 

<SETG RES-FLS %<RSUBR-ENTRY '[GEN RES-FLS #DECL ("VALUE" <OR FALSE <LIST <OR 
COMMON SYMTAB TEMP> [REST <OR TEMP SYMTAB COMMON>]>> <LIST [REST <OR TEMP SYMTAB
COMMON>]> SYMBOL)] 8600>> 

" Generate LVAL for free variable." 

<SETG FLVAL-GEN %<RSUBR-ENTRY '[GEN FLVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 8656
>> 

<SETG FSET-GEN %<RSUBR-ENTRY '[GEN FSET-GEN #DECL ("VALUE" ANY NODE ANY)] 8736>> 

" Generate code for an internal SET." 

<SETG SET-GEN %<RSUBR-ENTRY '[GEN SET-GEN #DECL ("VALUE" ANY NODE ANY)] 8827>> 

<SETG STOREV %<RSUBR-ENTRY '[GEN STOREV #DECL ("VALUE" ANY <OR TEMP SYMTAB 
COMMON> "OPTIONAL" ANY)] 9290>> 

" Update the stack model with a FIX or an ATOM." 

<SETG ADD:STACK %<RSUBR-ENTRY '[GEN ADD:STACK #DECL ("VALUE" ANY ANY)] 9452>> 

" Return the current distance between two stack places." 

<SETG STACK:L %<RSUBR-ENTRY '[GEN STACK:L #DECL ("VALUE" <OR FALSE <LIST FIX>> 
LIST LIST)] 9536>> 

" Compute the address of a local variable using the stack model." 

<SETG LOCAL-ADDR %<RSUBR-ENTRY '[GEN LOCAL-ADDR #DECL ("VALUE" DATUM NODE ANY)] 
9619>> 

<SETG LADDR %<RSUBR-ENTRY '[GEN LADDR #DECL ("VALUE" DATUM SYMTAB ANY ANY 
"OPTIONAL" ANY)] 9643>> 

<SETG STFIXIT %<RSUBR-ENTRY '[GEN STFIXIT #DECL ("VALUE" <LIST FIX LIST> <LIST 
FIX LIST> LIST)] 10507>> 

" Generate obscure stuff." 

<SETG DEFAULT-GEN %<RSUBR-ENTRY '[GEN DEFAULT-GEN #DECL ("VALUE" ANY NODE ANY)] 
10581>> 

" Do GVAL using direct locative reference." 

<SETG GVAL-GEN %<RSUBR-ENTRY '[GEN GVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 10602>
> 

" Do SETG using direct locative reference." 

<SETG SETG-GEN %<RSUBR-ENTRY '[GEN SETG-GEN #DECL ("VALUE" ANY NODE ANY)] 10657>
> 

<BLOCK (<ROOT>)> 

RGLOC 

<ENDBLOCK> 

<SETG GLOC? %<RSUBR-ENTRY '[GEN GLOC? #DECL ("VALUE" ANY ANY)] 10802>> 

<SETG USE-RGLOC T> 

" Generate GVAL calls." 

<SETG FGVAL-GEN %<RSUBR-ENTRY '[GEN FGVAL-GEN #DECL ("VALUE" ANY NODE ANY)] 
10892>> 

" Generate a SETG call." 

<SETG FSETG-GEN %<RSUBR-ENTRY '[GEN FSETG-GEN #DECL ("VALUE" ANY NODE ANY)] 
10934>> 

<SETG CHTYPE-GEN %<RSUBR-ENTRY '[GEN CHTYPE-GEN #DECL ("VALUE" ANY NODE ANY)] 
11020>> 

" Generate do-nothing piece of code." 

<SETG ID-GEN %<RSUBR-ENTRY '[GEN ID-GEN #DECL ("VALUE" ANY NODE ANY)] 11255>> 

<SETG UNWIND-GEN %<RSUBR-ENTRY '[GEN UNWIND-GEN #DECL ("VALUE" ANY NODE ANY)] 
11275>> 

" Generate call to READ etc. with eof condition." 

<SETG READ2-GEN %<RSUBR-ENTRY '[GEN READ2-GEN #DECL ("VALUE" ANY NODE ANY)] 
11456>> 

<SETG GET-GEN %<RSUBR-ENTRY '[GEN GET-GEN #DECL ("VALUE" ANY ANY ANY)] 11676>> 

<SETG GET2-GEN %<RSUBR-ENTRY '[GEN GET2-GEN #DECL ("VALUE" ANY ANY ANY)] 11695>> 

<SETG GETGET %<RSUBR-ENTRY '[GEN GETGET #DECL ("VALUE" ANY NODE ANY ANY)] 11715>
> 

<SETG GETTERS ![,GET ,GETL ,GETPROP ,GETPL!]> 

<SETG GENERATORS <DISPATCH ,DEFAULT-GEN (,FORM-CODE ,FORM-GEN) (,PROG-CODE ,
PROG-REP-GEN) (,SUBR-CODE ,SUBR-GEN) (,COND-CODE ,COND-GEN) (,LVAL-CODE ,
LVAL-GEN) (,SET-CODE ,SET-GEN) (,OR-CODE ,OR-GEN) (,AND-CODE ,AND-GEN) (,
RETURN-CODE ,RETURN-GEN) (,COPY-CODE ,COPY-GEN) (,AGAIN-CODE ,AGAIN-GEN) (,
GO-CODE ,GO-GEN) (,ARITH-CODE ,ARITH-GEN) (,RSUBR-CODE ,RSUBR-GEN) (,0-TST-CODE 
,0-TEST) (,NOT-CODE ,NOT-GEN) (,1?-CODE ,1?-GEN) (,TEST-CODE ,TEST-GEN) (,
EQ-CODE ,==-GEN) (,TY?-CODE ,TYPE?-GEN) (,LNTH-CODE ,LNTH-GEN) (,MT-CODE ,MT-GEN
) (,REST-CODE ,REST-GEN) (,NTH-CODE ,NTH-GEN) (,PUT-CODE ,PUT-GEN) (,PUTR-CODE ,
PUTREST-GEN) (,FLVAL-CODE ,FLVAL-GEN) (,FSET-CODE ,FSET-GEN) (,FGVAL-CODE ,
FGVAL-GEN) (,FSETG-CODE ,FSETG-GEN) (,STACKFORM-CODE ,STACKFORM-GEN) (,
MIN-MAX-CODE ,MIN-MAX) (,CHTYPE-CODE ,CHTYPE-GEN) (,FIX-CODE ,FIX-GEN) (,
FLOAT-CODE ,FLOAT-GEN) (,ABS-CODE ,ABS-GEN) (,MOD-CODE ,MOD-GEN) (,ID-CODE ,
ID-GEN) (,ASSIGNED?-CODE ,ASSIGNED?-GEN) (,ISTRUC-CODE ,ISTRUC-GEN) (,
ISTRUC2-CODE ,ISTRUC-GEN) (,BITS-CODE ,BITS-GEN) (,GETBITS-CODE ,GETBITS-GEN) (,
BITL-CODE ,BITLOG-GEN) (,PUTBITS-CODE ,PUTBITS-GEN) (,ISUBR-CODE ,ISUBR-GEN) (,
EOF-CODE ,ID-GEN) (,READ-EOF2-CODE ,READ2-GEN) (,READ-EOF-CODE ,SUBR-GEN) (,
IPUT-CODE ,IPUT-GEN) (,IREMAS-CODE ,IREMAS-GEN) (,GET-CODE ,GET-GEN) (,GET2-CODE
,GET2-GEN) (,IRSUBR-CODE ,IRSUBR-GEN) (,MAP-CODE ,MAPFR-GEN) (,MARGS-CODE ,
MPARGS-GEN) (,MAPLEAVE-CODE ,MAPLEAVE-GEN) (,MAPRET-STOP-CODE ,MAPRET-STOP-GEN) 
(,UNWIND-CODE ,UNWIND-GEN) (,GVAL-CODE ,GVAL-GEN) (,SETG-CODE ,SETG-GEN) (,
TAG-CODE ,TAG-GEN) (,PRINT-CODE ,PRINT-GEN) (,MEMQ-CODE ,MEMQ-GEN) (,
LENGTH?-CODE ,LENGTH?-GEN) (,FORM-F-CODE ,FORM-F-GEN) (,INFO-CODE ,INFO-GEN) (,
OBLIST?-CODE ,OBLIST?-GEN) (,AS-NXT-CODE ,AS-NXT-GEN) (,AS-IT-IND-VAL-CODE ,
ASSOC-FIELD-GET) (,ALL-REST-CODE ,ALL-REST-GEN)>> 

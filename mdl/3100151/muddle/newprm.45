
TITLE PRIMITIVE FUNCTIONS FOR THE MUDDLE SYSTEM

RELOCATABLE

.INSRT MUDDLE >

.GLOBAL CALER,CALER1,NWORDT,CHARGS,CHFRM,CHLOCI,TFA,TMA,IFALSE,IPUTP,IGETP,WTYP1

; BUILD DISPATCH TABLE FOR PRIMITIVE FUNCTIONS USAGE

PRMTYP:

REPEAT NUMSAT,[0]			;INITIALIZE TABLE TO ZEROES

IRP A,,[2WORD,2NWORD,NWORD,ARGS,CHSTR,BYTE]

LOC PRMTYP+S!A
P!A==.IRPCN+1
P!A

TERMIN

LOC PRMTYP+NUMSAT

PNUM==PBYTE+1

; MACRO TO BUILD PRIMITIVE DISPATCH TABLES

DEFINE PRDISP NAME,DEFAULT,LIST
	TBLDIS NAME,DEFAULT,[LIST]PNUM
	TERMIN


; SUBROUTINE TO RETURN PRIMITIVE TYPE AND PRINT ERROR IF ILLEGAL

PTYPE:	GETYP	A,(B)	;CALLE D WITH B POINTING TO PAIR
	CAIN	A,TILLEG	;LOSE IF ILLEGAL
	JRST	ILLCHOS

	PUSHJ	P,SAT		;GET STORAGE ALLOC TYPE
	CAIN	A,SARGS		;SPECIAL HAIR FOR ARGS
	PUSHJ	P,CHARGS
	CAIN	A,SFRAME
	PUSHJ	P,CHFRM
	CAIN	A,SLOCID
	PUSHJ	P,CHLOCI
PTYP1:	MOVE	A,PRMTYP(A)	;GET PRIM TYPE,
	POPJ	P,


; PROCESS TYPE ILLEGAL

ILLCHO:	HRRZ	B,1(B)	;GET CLOBBERED TYPE
	CAIN	B,TARGS	;WAS IT ARGS?
	JRST	ILLARG
	CAIN	B,TFRAME		;A FRAME?
	JRST	ILFRAM
	CAIN	B,TLOCD		;A LOCATIVE TO AN ID
	JRST	ILLOC

	LSH	B,1		;NONE OF ABOVE LOOK IN TABLE
	ADDI	B,TYPVEC+1(TVP)
	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL
	PUSH	TP,$TATOM
	PUSH	TP,(B)		;PUSH ATOMIC NAME
	MOVEI	A,2
	JRST	CALER		;GO TO ERROR REPORTER

; CHECK AN ARGS POINTER

CHARGS:	PUSH	P,A		;SAVE SOME ACS
	PUSH	P,B
	PUSH	P,C
	MOVE	C,1(B)	;GET POINTER
	HLRE	A,C		;FIND ASSOCIATED FRAME
	SUBI	C,(A)		;C POINTS TO FRAME OR FRAME POINTER
	ANDI	C,-1
	CAILE	C,(TP)		;WITHIN STACK?
	JRST	ILLARG		;NO, LOSE
	HLRZ	A,(C)		;GET TYPE OF NEXT GOODIE
	CAIE	A,TENTRY	;MUST BE EITHER ENTRY OR TTB
	CAIN	A,TTB
	JRST	CHARG1		;WINNER

ILLARG:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL-ARGUMENT-BLOCK
	JRST	CALER1

CHARG1:	CAIN	A,TTB		;POINTER TO FRAME?
	MOVE	C,1(C)		;YES, GET IT
	CAIN	A,TENTRY		;POINTS TO ENTRT?
	MOVEI	C,FRAMLN(C)	;YES POINT TO END OF FRAME
	HLRZ	C,OTBSAV(C)	;GET TIME FROM FRAME
	HRRZ	B,(B)		;AND ARGS TIME
	CAIE	B,(C)		;SAME?
	JRST	ILLARG
POPBCJ:	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,		;GO GET PRIM TYPE



; CHECK A FRAME POINTER

CHFRM:	PUSH	P,A		;SAVE SOME REGISTERS
	PUSH	P,B
	PUSH	P,C
	HRRZ	C,1(B)		;GET POINTER PART
	CAILE	C,(TP)		;STILL WITHIN STACK
	JRST	ILFRAM
	HLRZ	A,FSAV(C)	;CHECK STILL AN ENTRY BLOCK
	CAIE	A,TENTRY
	JRST	ILFRAM
	HLRZ	A,1(B)		;GET TIME FROM POINTER
	HLRZ	C,OTBSAV(C)	;AND FROM FRAME
	CAIN	A,(C)		;SAME?
	JRST	POPBCJ		;YES, WIN

ILFRAM:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL-FRAME
	JRST	CALER1

; CHECK A LOCATIVE TO AN IDENTIFIER

CHLOCI:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C

	HRRZ	A,(B)		;GET TIME FROM POINTER
	JUMPE	A,POPBCJ	;ZERO, GLOBAL VARIABLE NO TIME
	HRRZ	C,1(B)		;POINT TO STACK
	CAILE	C,(TP)		;STILL A WINNER?
	JRST	ILLOC		;NO
	MOVE	C,2(C)		;SHOULD BE TLOCI,,TIME
	HRLI	A,TLOCI		;MAKE A LOOK THE SAME
	CAMN	A,C
	JRST	POPBCJ

ILLOC:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL-LOCATIVE
	JRST	CALER1

	


; FUNCTION TO GET THE LENGTH OF LISTS,VECTORS AND CHAR STRINGS

MFUNCTION LENGTH,SUBR

	ENTRY	1

	MOVE	B,AB		;POINT TO ARGS
	PUSHJ	P,PTYPE		;GET ITS PRIM TYPE
	JUMPE	A,WTYP1		;IF 1 WORD, LOSE
	MOVEI	B,0
	SKIPE	C,1(AB)		;IF NON-ZERO, FIND LENGTH
	AOJA	B,@LENTBL(A)
	JRST	LFINIS		;OTHERWISE USE 0

PRDISP LENTBL,IWTYP1,[[P2WORD,LNLST],[P2NWORD,LNVEC],[PNWORD,LNUVEC]
[PARGS,LNVEC],[PCHSTR,LNCHAR]]

LNLST:	MOVSI	A,TLIST		;WILL BECOME INTERRUPTABLE
	HLLM	A,CSTO(PVP)	;AND C WILL BE A LIST POINTER
LNLST1:	INTGO		;IN CASE CIRCULAR LIST
	HRRZ	C,(C)		;STEP
	JUMPE	C,.+2		;DONE, RETRUN LENGTH
	AOJA	B,LNLST1	;COUNT AND GO
	SETZM	CSTO(PVP)


LFINIS:	MOVSI	A,TFIX		;LENGTH IS AN INTEGER
	JRST	FINIS

LNVEC:	ASH	C,-1		;GENERAL VECTOR DIVIDE BY 2
LNUVEC:	HLRE	B,C		;GET LENGTH
	MOVMS	B		;MAKE POS
	JRST	LFINIS

LNCHAR:	LDB	D,[360600,,C]	;GET POSITION FIELD
	LDB	E,[300600,,C]	;AND SIZE FIELD
	MOVEI	A,(E)		;COPY E
	IDIVI	D,(E)		;D=> NUMBER OF BYTES IN WORD-1
	MOVEI	B,1(D)		;EXACT # OF BYTES IN 1ST WORD
	MOVEI	D,36.
	IDIVI	D,(A)		;MAX BYTES PER WORD
	HRRZ	E,(AB)		;POINT TO DOPE WORD
	SUBI	E,2(C)		;NUMBER OF WORDS IN ENTIRE STRING
	JUMPL	E,LSTCH2	;NULL STRING
	ADDI	C,(E)		;POINT TO LAST WORD
	JUMPLE	E,LSTCH1	;IF <0, NONE IN OTHER WORDS
	IMULI	E,(D)		;NO. OF CHARS IN THIS PART OF STRING
	ADDI	B,(E)		;ADD IN NO. IN 1ST WORD

LSTCH1:	LSH	A,24.		;START TO BUILD BYTE POINTER TO LAST WORD
	TLO	A,440000+C
	HRLI	B,-5		;MAX OF 5
	ILDB	0,A		;GET A BYTE
	SKIPE	0
	AOBJN	B,.-2

	HRREI	B,-5(B)		;FUDGE FOR DOUBLE USE OF WORD 1
	JUMPGE	B,LFINIS
LSTCH2:	MOVEI	B,0
	JRST	LFINIS



MFUNCTION ATOMP,SUBR,ATOM?

	ENTRY	1

	GETYP	A,(AB)
	CAIE	A,TATOM
	JRST	IFALSE

IDNT1:	MOVE	A,(AB)		;RETURN THE ATOM
	MOVE	B,1(AB)
	JRST	FINIS

MFUNCTION QUOTE,FSUBR

	ENTRY	1

	GETYP	A,(AB)
	CAIE	A,TLIST		;ARG MUST BE A LIST
	JRST	ERRIFS
	SKIPN	B,1(AB)		;SHOULD HAVE A BODY
	JRST	ERRTFA

	GETYP	C,(B)		;GET TYPE
	MOVSI	C,(C)		;TO LH

QUOT2:	CAMN	C,$TDEFER	;DEFERRED?
	JRST	QUOT1
	PUSHJ	P,PTYPE		;CHECK FOR LOSERS
	MOVE	A,C
	MOVE	B,1(B)		;GET DATUM
	JRST	FINIS


QUOT1:	HRRZ	B,1(B)		;POINT TO DEFERRED VALUE
	GETYPF	C,(B)		;GET TYPE
	JRST	QUOT2

MFUNCTION EQ,SUBR,[==?]

	ENTRY	2

	MOVE	B,AB		;POINT TO FIRST ARG
	PUSHJ	P,PTYPE		;CHECK ON IT
	ADD	B,[2,,2]	;SAME FOR SECOND
	PUSHJ	P,PTYPE

	GETYP	A,(AB)		;GET 1ST TYPE
	GETYP	C,2(AB)		;AND 2D TYPE
	MOVE	B,1(AB)
	CAIN	A,(C)		;CHECK IT
	CAME	B,3(AB)
	JRST	IFALSE

ITRUTH:	MOVSI	A,TATOM		;RETURN TRUTH
	MOVE	B,MQUOTE T
	JRST	FINIS

IFALSE:	MOVSI	A,TFALSE		;RETURN FALSE
	MOVEI	B,0
	JRST	FINIS



MFUNCTION EMPTY,SUBR,EMPTY?

	ENTRY	1

	MOVE	B,AB
	PUSHJ	P,PTYPE		;GET PRIMITIVE TYPE

	JUMPE	A,WTYP1
	MOVE	B,1(AB)		;GET THE ARG

	CAIE	A,P2WORD		;A LIST?
	JRST	EMPT1		;NO VECTOR OR CHSTR
	JUMPE	B,ITRUTH		;0 POINTER MEANS EMPTY LIST
	JRST	IFALSE


EMPT1:	CAIE	A,PCHSTR		;CHAR STRING?
	JRST	EMPT2		;NO, VECTOR
	JUMPE	B,ITRUTH	;0 STRING WINS
	HRRZ	A,(AB)		;POINT TO DOPE WORD
	LDB	C,B		;CHECK POINTED TO CHAR
	JUMPE	C,ITRUTH
	CAILE	A,1(B)		;PAST DOPE WORD?
	JRST	IFALSE		;NO, RETURN
	JRST	ITRUTH

EMPT2:	JUMPGE	B,ITRUTH
	JRST	IFALSE


MFUNCTION EQUAL,SUBR,[=?]

	ENTRY	2

	MOVE	C,AB		;SET UP TO CALL INTERNAL
	MOVE	D,AB
	ADD	D,[2,,2]	;C POINTS TO FIRS, D TO SECOND
	PUSHJ	P,IEQUAL	;CALL INTERNAL
	JRST	IFALSE		;NO SKIP MEANS LOSE
	JRST	ITRUTH


; INTERNAL EQUAL SUBROUTINE

IEQUAL:	MOVE	B,C		;NOW CHECK THE ARGS
	PUSHJ	P,PTYPE
	MOVE	B,D
	PUSHJ	P,PTYPE
	GETYP	0,(C)		;NOW CHECK FOR EQ
	GETYP	B,(D)
	MOVE	E,1(C)
	CAIN	0,(B)		;DONT SKIP IF POSSIBLE WINNER
	CAME	E,1(D)		;DEFINITE WINNER, SKIP
	JRST	IEQ1
CPOPJ1:	AOS	(P)		;EQ, SKIP RETURN
	POPJ	P,


IEQ1:	CAIE	0,(B)		;SKIP IF POSSIBLE MATCH
CPOPJ:	POPJ	P,		;NOT POSSIBLE WINNERS
	JRST	@EQTBL(A)	;DISPATCH

PRDISP EQTBL,CPOPJ,[[P2WORD,EQLIST],[P2NWORD,EQVEC],[PNWORD,EQUVEC]
[PARGS,EQVEC],[PCHSTR,EQCHST]]


EQLIST:	PUSHJ	P,PUSHCD	;PUT ARGS ON STACK

EQLST1:	INTGO			;IN CASE OF CIRCULAR
	HRRZ	C,-2(TP)		;GET FIRST
	HRRZ	D,(TP)		;AND 2D
	CAIN	C,(D)		;EQUAL?
	JRST	EQLST2	;YES, LEAVE
	JUMPE	C,EQLST3	;NIL LOSES
	JUMPE	D,EQLST3
	HLRZ	0,(C)		;CHECK DEFERMENT
	CAIN	0,TDEFER
	HRRZ	C,1(C)		;PICK UP POINTED TO CROCK
	HLRZ	0,(D)
	CAIN	0,TDEFER
	HRRZ	D,1(D)		;POINT TO REAL GOODIE
	PUSHJ	P,IEQUAL	;CHECK THE CARS
	JRST	EQLST3	;LOSE
	HRRZ	C,@-2(TP)		;CDR THE LISTS
	HRRZ	D,@(TP
	HRRZM	C,-2(TP)		;AND STORE
	HRRZM	D,(TP)
	JRST	EQLST1

EQLST2:	AOS	(P)		;SKIP RETRUN
EQLST3:	SUB	TP,[4,,4]	;REMOVE CRUFT
	POPJ	P,



EQVEC:	HLRE	A,1(C)		;GET LENGTHS
	HLRZ	B,1(D)
	CAIE	B,(A)		;SKIP IF EQUAL LENGTHS
	POPJ	P,		;LOSE
	JUMPGE	A,CPOPJ1	;SKIP RETRUN WIN
	PUSHJ	P,PUSHCD	;SAVE ARGS

EQVEC1:	INTGO			;IN CASE LONG VECTOR
	MOVE	C,(TP)
	MOVE	D,-2(TP)	;ARGS TO C AND D
	PUSHJ	P,IEQUAL
	JRST	EQLST3
	MOVE	C,[2,,2]	;GET BUMPER
	ADDM	C,(TP)
	ADDB	C,-2(TP)	;BUMP BOTH POINTERS
	JUMPL	C,EQVEC1
	JRST	EQLST2

EQUVEC:	HLRE	A,1(C)		;GET LENGTHS
	HLRE	B,1(D)
	CAIE	A,(B)		;SKIP IF EQUAL
	POPJ	P,

	HRRZ	B,1(C)		;START COMPUTING DOPE WORD LOCN
	SUB	B,A		;B POINTS TO DOPE WORD
	HLRZ	0,(B)		;GET UNIFORM TYPE
	HRRZ	B,1(D)		;NOW FIND OTHER DOPE WORD
	SUB	B,A
	HLRZ	B,(B)	;OTHER UNIFORM TYPE
	CAIE	0,(B)		;TYPES THE SAME?
	POPJ	P,		;NO, LOSE

	JUMPGE	A,CPOPJ1	;IF ZERO LENGTH ALREADY WON

	HRLZI	B,(B)		;TYPE TO LH
	PUSH	P,B		;AND SAVED
	PUSHJ	P,PUSHCD	;SAVE ARGS

EQUV1:	MOVEI	C,1(TP)		;POINT TO WHERE WILL GO
	PUSH	TP,(P)
	PUSH	TP,-3(TP)	;PUSH ONE OF THE VECTORS
	MOVEI	D,1(TP)		;POINT TO 2D ARG
	PUSH	TP,(P)
	PUSH	TP,-3(TP)	;AND PUSH ITS POINTER
	PUSHJ	P,IEQUAL
	JRST	UNEQUV

	SUB	TP,[4,,4]		;POP TP
	MOVE	A,[1,,1]
	ADDM	A,(TP)		;BUMP POINTERS
	ADDB	A,-2(TP)
	JUMPL	A,EQUV1		;JUMP IF STILL MORE STUFF
	SUB	P,[1,,1]	;POP OFF TYPE
	JRST	EQLST2

UNEQUV:	SUB	P,[1,,1]
	SUB	TP,[10,,10]
	POPJ	P,



EQCHST:	PUSHJ	P,PUSHCD	;SAVE ARGS TWICE
	PUSHJ	P,PUSHCD
	MCALL	1,LENGTH		;FIND LENGTH
	PUSH	P,B		;AND SAVE
	MCALL	1,LENGTH
	POP	P,A		;RESTORE OLD LENGTH
	CAIE	A,(B)		;SAME
	JRST	EQLST3	;NO, LOSE
	JUMPE	A,EQLST2	;BOTH 0 LENGTH, WINS
	MOVE	A,(TP)		;GET BYTE POINTERS
	MOVE	B,-2(TP)
	HRRZ	C,-1(TP)	;POINT TO DOPE WORD
	HRRZ	D,-3(TP)

	LDB	0,A		;GET BYTES
	LDB	E,B

EQCHS2:	CAIG	C,1(A)		;STILL WINNING?
	JRST	EQCHS3		;NO, SEE IF OTHER STRING EMPTY
	CAIE	0,(E)		;CHARS EQUAL?
	JRST	EQCHS4	;NO, LOSE
	JUMPE	E,EQLST2	;NULL CHAR, WINS

	ILDB	0,A		;GET NEXT CHARS
	ILDB	E,B
	JRST	EQCHS2

EQCHS3:	JUMPE	E,EQLST2		;IF E NULL , WIN
	CAIG	D,1(B)		;CHECK OVERFLOW
	JRST	EQLST2
	JRST	EQLST3

EQCHS4:	JUMPE	0,EQCHS3		;SEE IF OTHER EMPTY
	JRST	EQLST3


PUSHCD:	PUSH	TP,(C)
	PUSH	TP,1(C)
	PUSH	TP,(D)
	PUSH	TP,1(D)
	POPJ	P,

; NTH, AT AND REST

MFUNCTION NTH,SUBR

	ENTRY
	MOVEI	E,1		;E IS A SWITCH
	JRST	INTH



MFUNCTION GET,SUBR
	ENTRY
	HLRE A,AB	;GET -NUM OF A
	ASH A,-1	;DIVIDE BY 2
	AOJGE A,TFA	;0 OR 1 ARGS IS TOO FEW
	GETYP	A,2(AB)		;GET FIRST TYPE
	CAIE A,TFIX	;IF INDICATOR IS TFIX THEN WORRY
	JRST IGETP
	MOVEI B,(AB)	;GET OBJECT
	PUSHJ P,PTYPE
	MOVEI E,1	;E IS A SWITCH
	JRST @IGETBL(A)	;DISPATCH
PRDISP IGETBL,IIGETP,[[P2WORD,INTH],[P2WORD,INTH],[P2NWORD,INTH],[PARGS,INTH],[PNWORD,INTH],[PCHSTR,INTH]]

MFUNCTION PUT1,SUBR
	JRST IPUT1

MFUNCTION PUT,SUBR
IPUT1:	ENTRY
	HLRE A,AB	;-NUM OF ARGS
	ASH A,-1
	AOJGE A,TFA	;0 OR 1 ARGS IS TOO FEW
	GETYP	A,2(AB)
	CAIE A,TFIX
	JRST IPUTP
	MOVEI B,(AB)
	PUSHJ P,PTYPE
	JRST @IPUTBL (A)
PRDISP IPUTBL,IIPUTP,[[P2WORD,IPUT],[P2NWORD,IPUT],[PARGS,IPUT],[PNWORD,IPUT],[PCHSTR,IPUT]]


IPUT:	HLRE A,AB
	ASH A,-1
	ADDI	A,2		; ALREADY CHECKED FOR > 1
	JUMPE	A,TFA		; CANT REMOVE
	AOJL	A,TMA
	PUSH TP,0(AB)
	PUSH TP,1(AB)
	PUSH TP,2(AB)
	PUSH TP,3(AB)
	MCALL 2,AT
	PUSH TP,A
	PUSH TP,B
	PUSH TP,4(AB)
	PUSH TP,5(AB)
	MCALL 2,SETLOC
	MOVE A,(AB)
	MOVE B,1(AB)
	JRST FINIS



MFUNCTION REST,SUBR

	ENTRY

	MOVEI	E,0
	JRST	INTH

MFUNCTION AT,SUBR

	ENTRY

	MOVNI	E,1
INTH:	JUMPGE	AB,TFA		;NO ARGS, LOSE
	MOVEI	C,1		;DEFAULT ARG
	CAML	AB,[-2,,0]	;2D ARG SUPPLIED?
	JRST	INTH2
	CAMGE	AB,[-4,,0]	;CHECK TOO MANY
	JRST	TMA
	HLRZ	C,2(AB)		;GET ITS TYPE
	CAIE	C,TFIX
	JRST	WTYP2		;NOT FIXED MEANS LOSE
	SKIPGE	C,3(AB)		;MAKE SURE POSITIVE
	JRST	OUTRNG

INTH2:	SKIPE	E		;SKIP IF A REST CALL
	JUMPE	C,OUTRNG	;IF NTH OR AT, 0 LOSES
	MOVE	B,AB		;GET GOODIE
	PUSHJ	P,PTYPE		;GET PRIM TYPE
	MOVE	B,1(AB)
	JRST	@INTHBL(A)	;DISPATCH

PRDISP INTHBL,IWTYP1,[[P2WORD,NLST],[P2NWORD,NVEC],[PARGS,NARGS]
[PNWORD,NUVEC],[PCHSTR,NCHRS]]


NLST:	MOVSI	0,TLIST		;SET B'S TYPE FOR INTERRUPTABLE
	HLLM	0,BSTO(PVP)
	JRST	NLST2

NLST1:	INTGO			;CHECK INTERRUPTS
	HRRZ	B,(B)		;CDR THE LIST
NLST2:	JUMPE	B,OUTRNG	;HIT NIL, LOSER
	SOJG	C,NLST1		;COUNT DOWN
	SETZM	BSTO(PVP)		;RESET BSTO
	JUMPE	E,NLST3	;JUMP TO HACK REST
	JUMPL	E,NLST4	;AND TO HANDLE AT
	HLLZ	A,(B)		;CHECK FOR DEFER
	CAMN	A,$TDEFER
	HRRZ	B,1(B)		;POINT TO GOODIE
	CAMN	A,$TDEFER
	MOVE	A,(B)		;GET FULL WORD TYPE
	MOVE	B,1(B)
	JRST	FINIS

NLST3:	SKIPL	C		;C<0, REST CALLED FOR 0
	HRRZ	B,(B)		;OTHERWISE CDR
	MOVSI	A,TLIST
	JRST	FINIS

NLST4:	MOVSI	A,TLOCL		;RETURN LIST LOCATIVE
	JRST	FINIS




NARGS:	SKIPA	D,$TLOCA		;TYPE OF ARGS LOCATIVE

NVEC:	MOVSI	D,TLOCV		;TYPE OF OTHER LOCATIVE
	SOJL	C,NVEC4		;JUMP IF REST 0
	HRLI	C,(C)		;TO BOTH HALVES
	LSH	C,1		;TIMES 2
	ADD	B,C		;POINT TO IT
	JUMPGE	B,OUTRNG	;OUT OF RANGE
	JUMPE	E,NVEC1		;JUMP FOR REST
	JUMPL	E,NVEC2		;JUMP FOR AT
	MOVE	A,(B)		;GOBBLE GOODIE
	MOVE	B,1(B)
	JRST	FINIS

NVEC1:	ADD	B,[2,,2]	;REST IT
NVEC4:	SKIPA	A,(AB)	;RETURN LIST
NVEC2:	MOVE	A,D		;RETURN LOCATIVE
	HRR	A,(AB)		;GET TIME IF A VECTOR
	JRST	FINIS

NUVEC:	SOJL	C,NUVEC3	;REST 0
	HRLI	C,(C)		;TO BOTH HALVES
	ADD	B,C
	JUMPGE	B,OUTRNG	;JUMP IF OVERFLOW
	JUMPE	E,NUVEC1	;HANDLE REST
	JUMPL	E,NUVEC2	;AND AT
	HLRE	C,B		;FIND UNIFROM TYPE
	SUBM	B,C		;DOPE WORD POINTER TO C
	HLLZ	A,(C)		;GET THE TYPE
	MOVE	B,(B)
	JRST	FINIS

NUVEC1:	ADD	B,[1,,1]	;BUMP FOR REST
NUVEC3:	SKIPA	A,$TUVEC
NUVEC2:	MOVSI	A,TLOCU		;LOCATIVE TO UNIFROM VECTOR
	JRST	FINIS

NCHRS:	SOJL	C,NCHST3	;REST 0
	PUSH	P,E		;SAVE SWITCH
	LDB	D,[366000,,B]	;POSITION FIELD OF BYTE POINTER
	LDB	A,[300600,,B]	;SIZE FIELD
	PUSH	P,A		;SAVE SIZE
	IDIVI	D,(A)		;COMPUT BYTES IN 1ST WORD
	MOVEI	0,36.		;NOW COMPUTE BYTES PER WORD
	IDIVI	0,(A)		;BYTES PER WORD IN 0
	MOVE	E,0		;COPY OF BYTES PER WORD TO E
	SUBI	0,1(D)		;0 # OF UNSUED BYTES IN 1ST WORD
	ADDB	C,0		;C AND 0 NO.OF CHARS FROM WORD BOUNDARY
	IDIVI	C,(E)		;C/ REL WORD D/ CHAR IN LAST
	ADDI	C,(B)		;POINTO WORD WITH C
	HRRZ	0,(AB)		;DOPE WORD POINTER TO 0
	POP	P,A		;RESTORE BITS PER BYTE
	CAIGE	0,2(C)		;SKIP IF OKK
	JRST	OUTRNG		;LOSES
	IMULI	A,1(D)		;A/ BITS USED IN LAST WORD
	MOVEI	0,36.
	SUBI	0,(A)		;0 HAS NEW POSITION FIELD
	DPB	0,[360600,,B]	;INTO BYTE POINTER
	HRRI	B,(C)		;POINT TO RIGHT WORD
	POP	P,E		;RESTORE SWITCH
	JUMPE	E,NCHST1	;REST
	JUMPL	E,NCHST2
	LDB	B,B		;GET NTH CHAR
	JUMPE	B,OUTRNG	;LOSER
	HLRZ	A,(AB)		;GET TYPE
	CAIN	A,TCHSTR		;TYPE CHAR STRING?
	LSH	B,29.		;YES, POSITION BYTE
	MOVSI	A,TCHRS
	JRST	FINIS



NCHST1:	IBP	B		;BUMP BYTE POINTER
NCHST3:	MOVE	A,(AB)		;RETURN TYPE
	JRST	FINIS

NCHST2:	HRRZ	A,(AB)		;GET TYPE
	HRLI	A,TLOCC		;MAKE LOCATIVE TO  CSTRING
	JRST	FINIS

; FUNCTION TO DECIDE IF FURTHER DECOMPOSITION POSSIBLE

MFUNCTION MONAD,SUBR,MONAD?

	ENTRY	1

	MOVE	B,AB		; CHECK PRIM TYPE
	PUSHJ	P,PTYPE
	JUMPE	A,IDNT1		;RETURN ARGUMENT
	SKIPE	B,1(AB)
	JRST	@MONTBL(A)	;DISPATCH ON PTYPE
	JRST	IDNT1

PRDISP MONTBL,IFALSE,[[P2NWORD,MON1],[PNWORD,MON1],[PARGS,MON1]
[PCHSTR,CHMON]]

MON1:	JUMPGE	B,IDNT1		;EMPTY VECTOR
	JRST	IFALSE

CHMON:	LDB	A,B		;GOBBLE BYTE
	JUMPE	A,IDNT1		;ZERO BYTE TERMINATES
	IBP	B		;BUMP POINTER
	HRRZ	A,(AB)		;GOBBLE DOPE WORD POINTER
	CAILE	A,1(B)		;SKIP IF END
	JRST	IFALSE
	JRST	IDNT1



; FUNCTION TO DETERMINE MEMBERSHIP IN LISTS AND VECTORS

MFUNCTION MEMBER,SUBR

	MOVE	E,[PUSHJ P,EQLTST]	;TEST ROUTINE IN E
	JRST	MEMB

MFUNCTION MEMQ,SUBR

	MOVE	E,[PUSHJ P,EQTST]	;EQ TESTER

MEMB:	ENTRY	2
	MOVE	B,AB		;POINT TO FIRST ARG
	PUSHJ	P,PTYPE		;CHECK PRIM TYPE
	ADD	B,[2,,2]	;POINT TO 2ND ARG
	PUSHJ	P,PTYPE
	JUMPE	A,WTYP2		;2ND WRONG TYPE
	SKIPE	B,3(AB)		;GOBBLE LIST VECTOR ETC. POINTER
	JRST	@MEMTBL(A)	;DISPATCH
	JRST	IFALSE		;OR REPORT LOSSAGE

PRDISP MEMTBL,WTYP2,[[P2WORD,MEMLST],[PNWORD,MUVEC],[P2NWORD,MEMVEC]
[PARGS,MEMVEC],[PCHSTR,MEMCH]]



MEMLST:	MOVSI	0,TLIST		;SET B'S TYPE TO LIST
	MOVEM	0,BSTO(PVP)

MEMLS1:	INTGO			;CHECK INTERRUPTS
	MOVEI	C,(B)		;COPY POINTER
	GETYP	D,(C)		;GET TYPE
	MOVSI	A,(D)		;COPY
	CAIE	D,TDEFER		;DEFERRED?
	JRST	MEMLS2
	MOVE	C,1(C)		;GET DEFERRED DATUM
	GETYPF	A,(C)		;GET FULL TYPE WORD
MEMLS2:	MOVE	C,1(C)		;GET DATUM
	XCT	E		;DO THE COMPARISON
	JRST	MEMLS3		;NO MATCH
	MOVSI	A,TLIST
MEMLS5:	SETZM	BSTO(PVP)		;RESET B'S TYPE
	JRST	FINIS		;QUIT

MEMLS3:	HRRZ	B,(B)		;STEP THROGH
	JUMPN	B,MEMLS1	;STILL MORE TO DO
MEMLS4:	MOVSI	A,TFALSE	;RETURN FALSE
	JRST	MEMLS5		;RETURN 0

MEMVEC:	JUMPGE	B,IFALSE	;EMPTY VECTOR
	MOVSI	A,TVEC		;CLOBBER B'S TYPE TO VECTOR
	MOVEM	0,BSTO(PVP)

MEMV1:	INTGO			;CHECK FOR INTS
	GETYPF	A,(B)		;GET FULL TYPE
	MOVE	C,1(B)		;AND DATA
	XCT	E		;DO COMPARISON INS
	JRST	MEMV2		;NOT EQUAL
	MOVSI	A,TVEC
	JRST	MEMLS5		;RETURN WITH POINTER



MEMV2:	ADD	B,[2,,2]	;INCREMENT AND GO
	JUMPL	B,MEMV1		;STILL WINNING
MEMV3:	MOVEI	B,0
	JRST	MEMLS4		;AND RETURN FALSE

MUVEC:	JUMPGE	B,IFALSE
	GETYP	A,(AB)		;GET TYPE OF GODIE
	HLRE	C,B		;LOOK FOR UNIFORM TYPE
	SUBM	B,C		;DOPE POINTER TO C
	GETYP	C,(C)		;GET THE TYPE
	CAIE	A,(C)		;ARE THEY THE SAME?
	JRST	IFALSE		;NO, LOSE
	MOVSI	0,TUVEC		;SET B'S TYPE
	MOVEM	0,BSTO(PVP)
	MOVSI	A,(A)		;TYPE TO LH

MUVEC1:	INTGO			;CHECK OUT INTS
	MOVE	C,(B)		;GET DATUM
	XCT	E		;COMPARE
	JRST	MUVEC2		;NOT WINNERS
	AOBJN	B,MUVEC1	;LOOP TO WINNAGE
	JRST	MEMV3		;LOSE RETURN

MUVEC2:	MOVSI	A,TUVEC
	JRST	MEMLS5


MEMCH:	GETYP	A,(AB)		;IS ARG A SINGLE CHAR
	CAIE	A,TCHRS		;SKIP IF POSSIBLE WINNER
	JRST	WTYP1
	MOVE	C,1(AB)		;GET ARG
	TDNE	C,[3777,,-1]	;ONE CHAR ONLY
	JRST	WTYP1
	LSH	C,29.
	MOVSI	0,TCHSTR		;ALLOW INTERRUPTS
	MOVEM	0,BSTO(PVP)
	HRRZ	D,2(AB)		;POINT TO DOPE WORD
	LDB	A,B		;GET 1ST CHAR

MEMCH1:	INTGO
	CAIN	A,(C)		;CHECK IT
	JRST	MEMCH2
	ILDB	A,B		;GET NEXT CHAR
	JUMPE	A,MEMV3	;RET FALSE
	CAILE	D,1(B)		;CHECK PASSING DOPE WORD
	JRST	MEMCH1
	JRST	MEMV3		;PASSED DOPE WORD, CONTINUE

MEMCH2:	MOVE	A,2(AB)
	JRST	MEMLS5



EQTST:	CAMN	C,1(AB)		;CHECK VALUE
	CAME	A,(AB)		;AND TYPE
	POPJ	P,
	AOS	(P)		;SKIP RETURN
	POPJ	P,

EQLTST:	PUSH	TP,BSTO(PVP)
	PUSH	TP,B
	PUSH	TP,A
	PUSH	TP,C
	PUSH	P,E		;SAVE INS
	MOVE	C,AB		;SET UP CALL TO IEQUAL
	MOVEI	D,-1(TP)
	AOS	-1(P)		;ASSUME SKIP
	PUSHJ	P,IEQUAL	;GO INO EQUAL
	SOS	-1(P)		;UNDO SKIP
	MOVE	B,-2(TP)		;RESTORE B
	SUB	TP,[4,,4]	;AND POOP OF CRAP
	POP	P,E
	POPJ	P,

; FUNCTION TO RETURN THE TOP OF A VECTOR , CSTRING OR UNIFORM VECTOR

MFUNCTION TOP,SUBR

	ENTRY	1

	MOVE	B,AB		;CHECK ARG
	PUSHJ	P,PTYPE
	JRST	@TOPTBL(A)	;DISPATCH

PRDISP TOPTBL,IWTYP1,[[PNWORD,VTOP],[P2NWORD,VTOP],[PCHSTR,CHTOP],[PARGS,ATOP]]

VTOP:	HRRZ	B,1(AB)		;GET CURR ADDR
	HLRE	C,1(AB)		;AND -LENGTH
	SUB	B,C		;POINT TO DOPE WORD
	HLRZ	D,1(B)		;TOTAL LENGTH
	SUBI	B,-2(D)		;POINT TO TOP
	MOVNI	D,-2(D)		;-LENGTH
	HRLI	B,(D)		;B NOW POINTS TO TOP
TFINIS:	MOVE	A,(AB)		;RETURN TYPE
	JRST	FINIS

CHTOP:	MOVE	B,1(AB)		;BYTE POINTER TO B
	LDB	C,[300600,,B]	;GET SIZE FIELD
	MOVEI	D,36.		;BITD PER WORD
	SUBI	D,(C)		;POSITION OF 1ST BYTE
	DPB	D,[360600,,B]	;CLOBBER INTO B
	HRRZ	C,(AB)		;POINT TO DOPE WORD
	HLRZ	D,(C)		;GET COUNT
	SUBI	C,-1(D)		;POINT TO TOP
	HRRI	B,(C)
	JRST	TFINIS



ATOP:	PUSHJ	P,GETATO	;CALL INTERNAL TOP GETTER
	JRST	TFINIS		;FINISH, GETTING TYPE IN A

GETATO:	HRRZ	B,1(AB)		;GET LOCN
	HLRE	C,1(AB)		;GET -LENGTH
	SUB	B,C		;POINT PAST
	GETYP	A,(B)		;GET NEXT TYPE (ASSURED OF BEING EITHER TTB OR TENTRY)
	CAIN	A,TENTRY		;IF ENTRY
	MOVEI	B,FRAMLN(B)	;POINT TO FRAME
	CAIN	A,TTB		;ELSE IF TTB
	HRRZ	B,1(B)		;GOBBLE FRAME
	MOVE	B,ABSAV(B)	;GET SAVED AB
	POPJ	P,		;AND RETURN





; FUNCTION TO CLOBBER THE CDR OF A LIST

MFUNCTION PUTREST,SUBR,[PUTREST]
	JRST PUTR1


MFUNCTION RPLACD,SUBR

PUTR1:	ENTRY	2

	MOVE	B,AB		;COPY ARG POINTER
	PUSHJ	P,PTYPE		;CHECK IT
	CAIE	A,P2WORD	;LIST?
	JRST	WTYP1		;NO, LOSE
	ADD	B,[2,,2]	;AND NEXT ONE
	PUSHJ	P,PTYPE
	CAIE	A,P2WORD
	JRST	WTYP2		;NOT LIST, LOSE
	MOVE	B,1(AB)		;GET FIRST
	MOVE	D,3(AB)		;AND 2D LIST
	HRRM	D,(B)		;CLOBBER
	MOVE	A,(AB)		;RETURN CALLED TYPE
	JRST	FINIS



; FUNCTION TO CLOBBER AN ELEMENT OF A LIST OR VECTOR

MFUNCTION SETLOC,SUBR

	ENTRY	2

	GETYP	A,(AB)		;GOBBLE TYPE OF 1ST ARG
	MOVE	B,1(AB)		;GET GOODIE
	CAIN	A,TLOCL		;LOCATIVE TO LIST?
	JRST	SETLST
	CAIN	A,TLOCV		;TO A VECTOR?
	JRST	SETV
	CAIN	A,TLOCU		;TO A UNIFORM VECTOR
	JRST	SETU
	CAIN	A,TLOCA		;TO A STACK
	JRST	SETS		;GO DO A STACK
	CAIN	A,TLOCD		;LOCATIVE TO IDENTIFIER
	JRST	SETVAR		;YES, GO CLOBBER
	CAIE	A,TLOCC		;TO A CHSTR
	JRST	WTYP1		;LOSER

	GETYP	A,2(AB)		;GET TYPE
	CAIE	A,TCHRS		;CHARS?
	JRST	WTYP2
	MOVE	A,3(AB)		;GET WORD
	TDNE	A,[3777,,-1]	;MORE THAN ONE
	JRST	WTYP2		;YES, LOSE
	LSH	A,-29.		;POSITION
	DPB	A,B		;CLOBBER IN
TWOID:	MOVE	A,2(AB)
	MOVE	B,3(AB)		;RETURN 2D ARG
	JRST	FINIS

SETS:	MOVE	B,AB		;CECK ARGS
	PUSHJ	P,PTYPE		;CHECK THE TYPE
	MOVE	B,1(AB)		;GET DATUM AND TREAT LIKE VECTOR
	JRST	SETV		;NOW TREAT LIKE A VECTOR

SETLST:	GETYP	A,2(AB)		;GET 2D ARG
	MOVEI	D,(A)		;COPY
	PUSHJ	P,NWORDT		;NEED DEFERRED?
	SOJN	A,MDEFER		;YES, CONS ONE UP
	HRLM	D,(B)		;CLOBBER TYPE IN
CLOBV:	MOVE	A,3(AB)
	MOVEM	A,1(B)		;CLOBBER VALUE IN
	JRST	TWOID

MDEFER:	PUSH	TP,$TLIST		;CALL NCONS
	PUSH	TP,[0]
	MCALL	1,NCONS
	MOVE	C,1(AB)		;GET LIST BACK
	MOVSI	A,TDEFER		;SET TYPE
	HLLM	A,(C)
	MOVEM	B,1(C)		;AND VALUE
SETV:	GETYPF	A,2(AB)		;GET FULL TYPE
	MOVEM	A,(B)
	JRST	CLOBV



SETU:	HLRE	A,B		;GET LENGTH
	SUBM	B,A		;POINT TO DOPE WORD
	GETYP	A,(A)		;GET UNIFORM TYPE
	GETYP	C,2(AB)		;AND DESIRED TYPE
	CAIE	A,(C)		;SAME?
	JRST	WRNGUT
	MOVE	C,3(AB)
	MOVEM	C,(B)		;CLOBBER
	JRST	TWOID


SETVAR:	MOVE	B,AB		;GO CHECK LOCATIVE
	PUSHJ	P,CHLOCI
	MOVE	B,1(AB)		;WAS A WINNER, GET POINTER
	JRST	SETV		;AND HANDLE LIKE A VECTOR

; SUBROUTINE TO GET GOODIE POINTED TO BY LOCATIVE

MFUNCTION IN,SUBR

	ENTRY	1

	GETYP	A,(AB)		;GET TYPE
	CAIE	A,TLOCL		;LIST?
	CAIN	A,TLOCV		;VECTOR?
	JRST	IN1		;YES, WIN
	CAIE	A,TLOCU		;UNIFORM VECTOR
	CAIN	A,TLOCC		;OR CHAR STRING
	JRST	IN1
	CAIN	A,TLOCD		;LOCATIVE TO IDENTIFIER
	JRST	INIDNT		;LOOK IN AN IDENTIFIER
	CAIE	A,TLOCA		;ARGS?
	JRST	WTYP1		;NO, LOSE
	MOVE	B,AB		;CHECK ARGS ARG
	PUSHJ	P,PTYPE
IN1:	MOVEI	C,1		;SET ARGS FOR INTH
	MOVEI	E,1
	JRST	INTH2		;NOW TREAT LIKE NTH

INIDNT:	MOVE	B,AB		;CHECK OUT LOCATIVE
	PUSHJ	P,CHLOCI
	MOVE	B,1(AB)		;GET WINNING LOCATIVE
	GETYPF	A,(B)		;GET TYPE
	MOVE	B,1(B)
	JRST	FINIS




; FUNCTION TO BACK UP A VECTOR, UVECTOR OR CHAR STRING

MFUNCTION BACK,SUBR

	ENTRY

	MOVEI	C,1		;ASSUME BACKING UP ONE
	JUMPGE	AB,TFA		;NO ARGS IS TOO FEW
	CAML	AB,[-2,,0]	;SKIP IF MORE THAN 2 ARGS
	JRST	BACK1		;ONLY ONE ARG
	GETYP	A,2(AB)		;GET TYPE
	CAIE	A,TFIX		;MUST BE FIXED
	JRST	WTYP2
	SKIPGE	C,3(AB)		;GET NUMBER
	JRST	OUTRNG
	CAMGE	AB,[-4,,0]	;SKIP IF WINNING NUMBER OF ARGS
	JRST	TMA
	JUMPE	C,IDNT1		;BACK UP 0 IS NO OP
BACK1:	MOVE	B,AB		;SET UP TO FIND TYPE
	PUSHJ	P,PTYPE		;GET PRIM TYPE
	MOVE	B,1(AB)		;GET DATUM
	JRST	@BCKTBL(A)

PRDISP BCKTBL,IWTYP2,[[PNWORD,BACKU],[P2NWORD,BACKV],[PCHSTR,BACKC],[PARGS,BACKA]]

BACKV:	LSH	C,1		;GENERAL, DOUBLE AMOUNT
BACKU:	HRLI	C,(C)		;TO BOTH HALVES
	SUB	B,C		;BACK UP VECTOR POINTER
	HLRE	C,B		;FIND OUT IF OVERFLOW
	SUBM	B,C		;DOPE POINTER TO C
	HLRZ	A,1(C)		;GET LENGTH
	SUBI	C,-2(A)		;POINT TO TOP
	ANDI	C,-1
	CAILE	C,(B)		;SKIP IF A WINNER
	JRST	OUTRNG		;COMPLAIN
BACKUV:	MOVE	A,(AB)		;RETURN TYPE
	JRST	FINIS

BACKC:	LDB	E,[300600,,B]	;BYTE SIZE
	MOVEI	0,36.		;BITS PER WORD
	IDIVI	0,(E)		;DIVIDE TO FIND BYTES/WORD
	IDIV	C,0		;C/ WORDS BACK, D/BYTES BACK
	SUBI	B,(C)		;BACK WORDS UP
	JUMPE	D,CHBOUN	;CHECK BOUNDS

	IMULI	0,(E)		;0/ BITS OCCUPIED BY FULL WORD
	LDB	A,[360600,,B]	;GET POSITION FILED
BACKC2:	ADDI	A,(E)		;BUMP
	CAIGE	A,36.
	JRST	BACKC1		;O.K.
	SUB	A,0
	SUBI	B,1		;DECREMENT POINTER PART
BACKC1:	SOJG	D,BACKC2	;DO FOR ALL BYTES



	DPB	A,[360600,,B]	;FIX UP POINT BYTER
CHBOUN:	HRRZ	A,(AB)		;GET DOPE POINTER
	HLRZ	C,(A)		;GET SIZE
	SUBI	A,-1(C)		;TOP OF STRING TO A
	CAIG	A,(B)
	JRST	BACKUV
	JRST	OUTRNG


BACKA:	LSH	C,1		;NUMBER TIMES 2
	HRLI	C,(C)		;TO BOTH HALVES
	SUB	B,C		;FIX POINTER
	MOVE	E,B		;AND SAVE
	PUSHJ	P,GETATO		;LOOK A T TOP
	CAMLE	B,E		;COMPARE
	JRST	OUTRNG
	MOVE	B,E
	MOVE	A,(AB)		;RETURN CALLED TYPE
	JRST	FINIS



;ERROR COMMENTS FOR SOME PRIMITIVES

OUTRNG:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE OUT-OF-BOUNDS
	JRST	CALER1

WRNGUT:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE UNIFORM-VECTORS-TYPE-DIFFERS
	JRST	CALER1

IWTYP1:
WTYP1:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE FIRST-ARG-WRONG-TYPE
	JRST	CALER1

IWTYP2:
WTYP2:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE SECOND-ARG-WRONG-TYPE
	JRST	CALER1

ERRIFS:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE ILLEGAL-FSUBR-ARGUMENT
	JRST	CALER1

ERRTFA:
TFA:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE TOO-FEW-ARGUMENTS
	JRST	CALER1

TMA:	PUSH	TP,$TATOM
	PUSH	TP,MQUOTE TOO-MANY-ARGUMENTS
	JRST	CALER1

IIGETP:	JRST	IGETP		;FUDGE FOR MIDAS/STINK LOSSAGE
IIPUTP:	JRST	IPUTP


	
END

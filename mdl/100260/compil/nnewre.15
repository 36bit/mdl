
" Generate code for a poor innocent PROG or REPEAT."

<PUT REP-STATE
     DECL
     '<LIST [5 <LIST [REST SYMTAB DATUM <OR FALSE ATOM> <OR ATOM FALSE>]>]>>

""

<DEFINE PROG-REP-GEN (PNOD PWHERE
		      "AUX" (BSTB .BSTB) (NTSLOTS .NTSLOTS) XX (SPECD <>)
			    START:TAG (STB .STK) (STK (0 !.STK))
			    (NTMPS
			     <COND (.PRE .TMPS)
				   (<STACK:L .STK .BSTB>)
				   (ELSE (0))>) (TMPS .TMPS) BTP (BASEF .BASEF)
			    EXIT EXIT:OFF AGAIN (FRMS .FRMS) (OPRE .PRE) DEST
			    (CD <>) (AC-HACK .AC-HACK) (K <KIDS .PNOD>)
			    (SPEC-LIST .SPEC-LIST) TEM)
	#DECL ((NTSLOTS STB) <SPECIAL LIST> (BASEF PNOD) <SPECIAL NODE>
	       (PWHERE DEST) <OR ATOM DATUM> (SPECD PRE) <SPECIAL ANY>
	       (STK FRMS) <SPECIAL LIST> (BTP NSTB) LIST
	       (AC-HACK) <SPECIAL <PRIMTYPE LIST>> (TMPS) <SPECIAL LIST>
	       (START:TAG) <SPECIAL ATOM> (K) <LIST [REST NODE]>
	       (SPEC-LIST) <SPECIAL LIST>)
	<REGSTO <> <>>
	<PUT .PNOD ,SPECS-START <- <SPECS-START .PNOD> .TOT-SPEC>>
	<SET TMPS .NTMPS>
	<BEGIN-FRAME <TMPLS .PNOD> <ACTIVATED .PNOD> <PRE-ALLOC .PNOD>>
	<SET DEST
	     <COND (<==? .PWHERE FLUSHED> FLUSHED)
		   (ELSE <GOODACS .PNOD .PWHERE>)>>
	<PROG ((PRE .PRE) (TOT-SPEC .TOT-SPEC))
	      #DECL ((PRE) <SPECIAL ANY> (TOT-SPEC) <SPECIAL FIX>)
	      <OR .PRE
		  <EMIT-PRE <NOT <OR <ACTIVATED .PNOD> <0? <SSLOTS .BASEF>>>>>>
	      <COND (<ACTIVATED .PNOD>
		     <REGSTO T>
		     <SET TOT-SPEC 0>
		     <SET SPEC-LIST ()>
		     <ADD:STACK ,FRAMLN>
		     <SET FRMID <+ .FRMID 1>>
		     <PUT .FRMS 5 .NTSLOTS>
		     <SET FRMS
			  (.FRMID
			   <SET STK (0 !.STK)>
			   .PNOD
			   <COND (.PRE FUZZ)
				 (<STACK:L .STK <2 .FRMS>>)
				 (ELSE FUZZ)>
			   (<FORM GVAL <TMPLS .PNOD>>)
			   !.FRMS)>
		     <SET PRE <>>
		     <SET AC-HACK <>>
		     <SET BASEF .PNOD>
		     <SET NTSLOTS (<FORM GVAL <TMPLS .PNOD>>)>
		     <COND (<NOT <==? .PWHERE FLUSHED>>
			    <SET DEST <FUNCTION:VALUE>>)>
		     <BUILD:FRAME <SET EXIT:OFF <MAKE:TAG "EXIT">>>
		     <SET TMPS (2)>
		     <SET BSTB .STK>)>
	      <SET EXIT <MAKE:TAG "EXIT">>
	      <PUT .PNOD ,STK-B .STB>
	      <COND (<AND <NOT .PRE> <NOT <ACTIVATED .PNOD>>>
		     <SET NTSLOTS (<FORM GVAL <TMPLS .PNOD>> !.NTSLOTS)>)>
	      <BIND-CODE .PNOD>
	      <SET SPEC-LIST (.PNOD .SPECD <SPECS-START .PNOD> !.SPEC-LIST)>
	      <SET BTP .STK>
	      <IF-NOT .OPRE <SET BASEF .PNOD>>
	      <SET STK (0 !.STK)>
	      <COND (<OR <AGND .PNOD> <==? <NODE-SUBR .PNOD> ,REPEAT>>
		     <PROG-START-AC .PNOD>)>
	      <LABEL:TAG <SET AGAIN <MAKE:TAG "AGAIN">>>
	      <COND (<OR <AGND .PNOD> <==? <NODE-SUBR .PNOD> ,REPEAT>>
		     <CALL-INTERRUPT>)>
	      <PUT .PNOD ,BTP-B .BTP>
	      <PUT .PNOD ,DST .DEST>
	      <PUT .PNOD ,SPCS-X .SPECD>
	      <PUT .PNOD ,ATAG .AGAIN>
	      <PUT .PNOD ,RTAG .EXIT>
	      <PUT .PNOD ,PRE-ALLOC .PRE>
	      <COND (<OR <==? <NODE-SUBR .PNOD> ,REPEAT> <AGND .PNOD>>
		     <COND (<OR <==? <NODE-SUBR .PNOD> ,REPEAT>
				<==? .DEST FLUSHED>>
			    <RET-TMP-AC <SET TEM <SEQ-GEN .K FLUSHED T T>>>)
			   (ELSE
			    <SET TEM <SET CD <SEQ-GEN .K .DEST T T>>>
			    <COND (<==? .TEM ,NO-DATUM>
				   <COND (<EMPTY? <CDST .PNOD>>
					  <SET CD ,NO-DATUM>)
					 (ELSE <SET CD <CDST .PNOD>>)>)>)>)
		    (ELSE
		     <COND (<==? .DEST FLUSHED>
			    <RET-TMP-AC <SET TEM <SEQ-GEN .K .DEST T>>>
			    <COND (<NOT <==? .TEM ,NO-DATUM>>)>)
			   (ELSE
			    <SET TEM <SET CD <SEQ-GEN .K .DEST T>>>
			    <COND (<==? .TEM ,NO-DATUM>
				   <COND (<EMPTY? <CDST .PNOD>>
					  <SET CD ,NO-DATUM>)
					 (ELSE <SET CD <CDST .PNOD>>)>)>)>)>
	      <OR <ASSIGNED? NPRUNE> <PUT .PNOD ,KIDS ()>>
	      <AND .CD
		   <TYPE? .CD DATUM>
		   <PROG ()
			 <ACFIX .DEST .CD>
			 <RETURN-UP .PNOD>>>
	      <COND (<AND <==? <NODE-SUBR .PNOD> ,PROG> <N==? .TEM ,NO-DATUM>>
		     <COND (<ACTIVATED .PNOD> <PROG:END>)
			   (.PRE
			    <POP:LOCS .STK .STB>
			    <UNBIND:FUNNY <SPECS-START .PNOD> !.NTSLOTS>)
			   (ELSE <UNBIND:LOCS .STK .STB>)>)
		    (<==? <NODE-SUBR .PNOD> ,REPEAT>
		     <IF-NOT <==? .DEST FLUSHED> <MOVE:ARG .DEST .DEST>>
		     <AGAIN-UP .PNOD>
		     <BRANCH:TAG .AGAIN>)>
	      <COND (<OR <AGND .PNOD> <==? <NODE-SUBR .PNOD> ,REPEAT>>
		     <CLEANUP-STATE .PNOD>)>
	      <COND (<AND <TYPE? .DEST DATUM>
			  <ISTYPE? <DATTYP .DEST>>
			  .CD
			  <TYPE? <DATTYP .CD> AC>>
		     <RET-TMP-AC <DATTYP .CD> .CD>)>
	      <LABEL:TAG .EXIT>
	      <COND (<ACTIVATED .PNOD> <LABEL:OFF .EXIT:OFF>)
		    (ELSE <SET TEM .TOT-SPEC>)>>
	<OR <ACTIVATED .PNOD> <SET TOT-SPEC .TEM>>
	<SET STK .STB>
	<COND (.CD
	       <AND <TYPE? <DATTYP .DEST> AC>
		    <FIX-ACLINK <DATTYP .DEST> .DEST .CD>>
	       <AND <TYPE? <DATVAL .DEST> AC>
		    <FIX-ACLINK <DATVAL .DEST> .DEST .CD>>)>
	<SET XX <MOVE:ARG .DEST .PWHERE>>
	<END-FRAME>
	.XX>

""

" Generate code for a RETURN."

<DEFINE RETURN-GEN (NOD WHERE
		    "AUX" (SPECD .SPECD) N NN CD1 DEST (NF 0) NOT-HANDLED-PROG
			  (NT .NTSLOTS))
	#DECL ((NOD N PNOD) NODE (WHERE) <OR ATOM DATUM> (CD1) DATUM
	       (SPECD) <SPECIAL ANY> (NF) FIX)
	<PROG ()
	      <COND (<1? <LENGTH <KIDS .NOD>>> <SET N .PNOD>)
		    (<SET NN <RET-AGAIN-ONLY <NODE-NAME <2 <KIDS .NOD>>>>>
		     <SET N .NN>)
		    (ELSE <RETURN <SUBR-GEN .NOD .WHERE>>)>
	      -
	      <SET NOT-HANDLED-PROG
		   <NOT <OR <==? <NODE-SUBR .N> ,REPEAT>
			    <AND <==? <NODE-SUBR .N> ,PROG> <AGND .N>>>>>
	      <COND (<==? <SET DEST <DST .N>> FLUSHED>
		     <RET-TMP-AC <GEN <1 <KIDS .NOD>> FLUSHED>>)
		    (ELSE
		     <PUT .N
			  ,CDST
			  <SET CD1 <GEN <1 <KIDS .NOD>> <DATUM !.DEST>>>>
		     <RET-TMP-AC .CD1>
		     <ACFIX <DST .N> .CD1>)>
	      <AND .NOT-HANDLED-PROG <VAR-STORE>>
	      <COND (<ACTIVATED .N>
		     <REPEAT ((L .FRMS))
			     #DECL ((L) LIST)
			     <COND (<==? <3 .L> .N> <RETURN>)>
			     <AND <EMPTY? <SET L <REST .L 5>>> <RETURN>>
			     <SET NT <5 .L>>
			     <SET NF <+ .NF 1>>>
		     <GO:BACK:FRAMES .NF>
		     <OR .NOT-HANDLED-PROG <RETURN-UP .N>>)
		    (ELSE
		     <REPEAT ((LL .SPEC-LIST))
			     #DECL ((LL) LIST)
			     <AND <2 .LL> <RETURN <SET SPECD T>>>
			     <AND <==? <1 .LL> .N> <RETURN>>
			     <SET LL <REST .LL 3>>>
		     <COND (<PRE-ALLOC .N>
			    <POP:LOCS .STK <STK-B .N>>
			    <UNBIND:FUNNY <SPECS-START .N> !.NT>)
			   (ESLE <UNBIND:LOCS .STK <STK-B .N>>)>
		     <OR .NOT-HANDLED-PROG
			 <PROG ((STB <STK-B .N>))
			       #DECL ((STB) <SPECIAL LIST>)
			       <RETURN-UP .N>>>
		     <BRANCH:TAG <RTAG .N>>)>
	      ,NO-DATUM>>

<DEFINE GO:BACK:FRAMES (NF) 
	#DECL ((NF) FIX)
	<OR <0? .NF>
	    <REPEAT ()
		    <EMIT '<`MOVE  `TB*  |OTBSAV  `(TB) >>
		    <COND (<0? <SET NF <- .NF 1>>> <RETURN>)>>>>

""

" Generate code for an AGAIN."

<DEFINE AGAIN-GEN (NOD WHERE
		   "AUX" N NN (SPECD .SPECD) (PRE <>) NOT-HANDLED-PROG)
   #DECL ((NOD N PNOD) NODE (SPECD) <SPECIAL ANY>)
   <PROG ()
	 <COND (<EMPTY? <KIDS .NOD>> <SET N .PNOD>)
	       (<SET NN <RET-AGAIN-ONLY <NODE-NAME <1 <KIDS .NOD>>>>>
		<SET N .NN>)
	       (ELSE <VAR-STORE <>> <RETURN <SUBR-GEN .NOD .WHERE>>)>
	 <COND (<SET NOT-HANDLED-PROG
		     <NOT <OR <==? <NODE-SUBR .N> ,PROG>
			      <==? <NODE-SUBR .N> ,REPEAT>>>>
		<VAR-STORE>)>
	 <COND (<N==? .N <1 .SPEC-LIST>>
		<REPEAT ((L1 ()) (LL .SPEC-LIST))
			#DECL ((LL L1) LIST)
			<AND <EMPTY? <SET L1 <REST .LL 3>>> <RETURN>>
			<AND <2 .LL> <SET SPECD <3 .LL>>>
			<COND (<==? <4 .LL> .N>
			       <RETURN <SET PRE <PRE-ALLOC <1 .LL>>>>)
			      (ELSE <SET LL .L1>)>>)>
	 <COND (.PRE <POP:LOCS .STK <BTP-B .N>> <UNBIND:FUNNY .SPECD !.NTSLOTS>)
	       (ELSE <UNBIND:LOCS .STK <BTP-B .N>>)>
	 <OR .NOT-HANDLED-PROG <PROG ((STK <BTP-B .N>)) #DECL ((STK) <SPECIAL LIST>)
					<AGAIN-UP .N>>>
	 <BRANCH:TAG <ATAG .N>>
	 ,NO-DATUM>>

" Generate code for a GO in a PROG/REPEAT."

<DEFINE GO-GEN (NOD WHERE "AUX" (N <1 <KIDS .NOD>>) (RT <RESULT-TYPE .N>)) 
	#DECL ((NOD N) NODE (WHERE) <OR ATOM DATUM>)
	<VAR-STORE>
	<COND (<==? .RT ATOM>
	       <POP:LOCS .STK <BTP-B .PNOD>>
	       <BRANCH:TAG <UNIQUE:TAG <NODE-NAME <1 <KIDS .NOD>>> <>>>)
	      (ELSE
	       <RET-TMP-AC <STACK:ARGUMENT <GEN .N DONT-CARE>>>
	       <REGSTO T>
	       <EMIT '<MCALL!-OP!-PACKAGE 1 GO>>)>
	,NO-DATUM>

<DEFINE TAG-GEN (NOD WHERE
		 "AUX" (ATM <UNIQUE:TAG <NODE-NAME <1 <KIDS .NOD>>> <>>))
	#DECL ((NOD) NODE)
	<EMIT <INSTRUCTION `MOVEI  `O  .ATM>>
	<EMIT '<`SUBI  `O  `(M) >>
	<EMIT '<`PUSH  `TP*  <TYPE-WORD!-OP!-PACKAGE FIX>>>
	<EMIT '<`PUSH  `TP*  0>>
	<REGSTO T>
	<EMIT '<`PUSHJ  `P*  |MAKACT >>
	<EMIT '<`PUSH  `TP*  `A >>
	<EMIT '<`PUSH  `TP*  `B >>
	<EMIT '<MCALL!-OP!-PACKAGE 2 TAG>>
	<MOVE:ARG <FUNCTION:VALUE T> .WHERE>>

" Update ACs with respect to their datums."

<DEFINE ACFIX (OLD1 NEW1 "AUX" OLD NEW) 
	#DECL ((OLD NEW) DATUM)
	<COND (<TYPE? .OLD1 DATUM>
	       <SET NEW .NEW1>
	       <SET OLD .OLD1>
	       <COND (<==? <DATTYP .OLD> ANY-AC>
		      <PUT .OLD ,DATTYP <DATTYP .NEW>>)>
	       <COND (<==? <DATVAL .OLD> ANY-AC>
		      <PUT .OLD ,DATVAL <DATVAL .NEW>>)>)>
	T>

" Generate code to flush stack for leaving a PROG etc."

<DEFINE PROG:UNBIND () 
	#DECL ((STK STB) LIST (PNOD) NODE)
	<COND (.PRE
	       <POP:LOCS .STK .STB>
	       <UNBIND:FUNNY <SPECS-START .PNOD> !.NTSLOTS>)
	      (ELSE <UNBIND:LOCS .STK .STB>)>>

""

"ROUTINES TO ALLOW KEEPING VARIABLES IN AC'S THRU LOOPS.  THE OUTINES KEEP INFORMATION
 IN THE PROG NODE TELLING INFORMATION AT VARIOUS POINTS (I.E. AGAIN AND RETURN POINTS).
 VARIABLES KEPT IN ACS WILL CONTAIN POINTERS TO THE PROG NODES INVOLVED AND THE DECISION
 WILL BE MADE TO KEEP THEM IN AC'S WHEN THEY ARE FIRST REFERENCED.  AGAINS AND RETURNS
 WILL EMIT NULL MACROS AND A FIXUP ROUTINE WILL BE USED AT THE END TO COERCE THE STATES
 CORRECTLY."

"ROUTINE TO INITIALIZE STATE INFORMATION ON ENTERING LOOPS.  IT TAKES A PROG/REPEAT NODE
 AND WILL UPDATE INFORMATION CONTAING SLOTS AS WELL AS PUTTING THE NODE INTO PROG-AC
 SLOTS OF APPROPRIATE SYMTABS. THE SLOTS MAY CONTAIN MULTIPLE PROG NODES BUT THE ONE
 CURRENTLY BEING HACKED WILL BE FIRST.  IF FLUSHING A VAR THE ENTIRE SLOT WILL BE
 FLUSHED."

"MANIFESTS FOR PROG-AC"

<SETG PROG-SLOT 1>

<SETG NUM-SYM-SLOT 2>

<SETG STORED-SLOT 3>

<SETG INACS-SLOT 4>

"MANIFESTED VARIABLES FOR SLOT STORE IN PROG-VARS"

<SETG SYM-SLOT 1>

<SETG SAVED-NUM-SYM-SLOT 2>

<SETG SAVED-PROG-AC-SLOT 3>

<SETG SAVED-POTLV-SLOT 4>

<SETG LENGTH-PROG-VARS 4>

"MANIFESTS FOR AGAIN AND RETURN STATES"

<SETG SAVED-AC-STATE 1>

<SETG SAVED-CODE:PTR 2>

<SETG SAVED-STACK-STATE 3>

<SETG SAVED-RET-FLAG 4>

<SETG LENGTH-CONTROL-STATE 4>

"OFFSETS FOR STACK:INFO"

<SETG SAVED-FRMS 1>

<SETG SAVED-BSTB 2>

<SETG SAVED-NTSLOTS 3>

<SETG SAVED-STK 4>

"SLOTS FOR SAVED-AC-SLOT"

<SETG CSYMT-SLOT 1>

<SETG CINACS-SLOT 2>

<SETG CSTORED-SLOT 3>

<SETG CPOTLV-SLOT 4>

<SETG LENGTH-CSTATE 4>

"SLOTS FOR LOOP-VARS"

<SETG LSYM-SLOT 1>

<SETG LINACS-SLOT 2>

<SETG LOOPVARS-LENGTH 2>

<MANIFEST NUM-SYM-SLOT
	  LSYM-SLOT
	  LOOPVARS-LENGTH
	  LINACS-SLOT
	  SAVED-FRMS
	  CSYMT-SLOT
	  CINACS-SLOT
	  CSTORED-SLOT
	  CPOTLV-SLOT
	  LENGTH-CSTATE
	  SAVED-BSTB
	  SAVED-NTSLOTS
	  SAVED-STK
	  STORED-SLOT
	  INACS-SLOT
	  PROG-SLOT
	  SYM-SLOT
	  SAVED-NUM-SYM-SLOT
	  SAVED-POTLV-SLOT
	  SAVED-PROG-AC-SLOT
	  LENGTH-PROG-VARS
	  LENGTH-CONTROL-STATE
	  SAVED-AC-STATE
	  SAVED-CODE:PTR
	  SAVED-STACK-STATE
	  SAVED-RET-FLAG>

<DEFINE PROG-START-AC (PNOD "AUX" (PVARS ()) ONSYMT OPROG-AC OPOTLV) 
	#DECL ((PNOD) NODE)
	<MAPF <>
	      <FUNCTION (AC "AUX" SYMT) 
		      #DECL ((AC) AC)
		      <COND (<SET SYMT <CLEAN-AC .AC>>
			     <COND (<NOT <MEMQ .PNOD <PROG-AC .SYMT>>>
				    <SET ONSYMT <NUM-SYM .SYMT>>
				    <SMASH-NUM-SYM .SYMT>
				    <SET OPROG-AC <PROG-AC .SYMT>>
				    <SET OPOTLV <POTLV .SYMT>>
				    <PUT .SYMT ,POTLV <>>
				    <PUT .SYMT
					 ,PROG-AC
					 (.PNOD
					  TMP
					  <STORED .SYMT>
					  <DATUM <DATTYP <INACS .SYMT>>
						 <DATVAL <INACS .SYMT>>>)>
				    <SET PVARS
					 (.SYMT
					  .ONSYMT
					  .OPROG-AC
					  .OPOTLV
					  !.PVARS)>)>)>>
	      ,ALLACS>
	<PUT .PNOD ,LOOP-VARS ()>
	<PUT .PNOD ,AGAIN-STATES ()>
	<PUT .PNOD ,RETURN-STATES ()>
	<PUT .PNOD ,PROG-VARS .PVARS>
	<VAR-STORE <>>
	<REPEAT ((PTR .PVARS) SYMT)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<SET SYMT <SYM-SLOT .PTR>>
		<OR <STORED-SLOT <PROG-AC .SYMT>>
		    <PUT <PROG-AC .SYMT> ,NUM-SYM-SLOT <2 <NUM-SYM .SYMT>>>>
		<SET PTR <REST .PTR ,LENGTH-PROG-VARS>>>>

<DEFINE CLEAN-AC (AC "AUX" ACRES) 
   <COND
    (<SET ACRES <ACRESIDUE .AC>>
     <PUT .AC ,ACRESIDUE <>>
     <MAPF <>
      <FUNCTION (SYM) 
	 <COND
	  (<TYPE? .SYM SYMTAB>
	   <MAPF <>
		 <FUNCTION (SYMT) 
			 <COND (<N==? .SYMT .SYM>
				<COND (<OR <NOT <TYPE? .SYMT SYMTAB>>
					   <STORED .SYMT>>
				       <SMASH-INACS .SYMT <>>)
				      (ELSE <STOREV .SYMT T>)>)>>
		 .ACRES>
	   <PUT .AC ,ACRESIDUE (.SYM)>
	   <MAPLEAVE <1 <ACRESIDUE .AC>>>)>>
      .ACRES>)>>

<DEFINE AGAIN-UP (PNOD "OPTIONAL" (RET <>) "AUX" CSTATE) 
	#DECL ((PNOD) NODE (RET) <OR ATOM FALSE>)
	<SET CSTATE <CURRENT-AC-STATE>>
	<PUT .PNOD
	     ,AGAIN-STATES
	     (.CSTATE .CODE:PTR <STACK:INFO> .RET !<AGAIN-STATES .PNOD>)>>

<DEFINE RETURN-UP (PNOD "OPTIONAL" (STK .STB)  "AUX" CSTATE) 
	#DECL ((PNOD) NODE (STK) <SPECIAL LIST>)
	      <COND (<NOT <AND <==? <NODE-SUBR .PNOD> ,PROG> <NOT <AGND .PNOD>>>>
		     <SET CSTATE <CURRENT-AC-STATE .PNOD>>
		     <PUT .PNOD
			  ,RETURN-STATES
			  (.CSTATE
			   .CODE:PTR
			   <STACK:INFO>
			   T
			   !<RETURN-STATES .PNOD>)>)>>

<DEFINE STACK:INFO ()
	(.FRMS .BSTB .NTSLOTS .STK)>
""

"OK FOLKS HERE IT IS.  THIS IS THE ROUTINE THAT MERGES ALL THE STATES IN LOOPS
 AND DOES THE RIGHT THING IN ALL CASES (MAYBE?).  IT TAKES A PROG AND MAKES SURE
 THAT STATES ARE CONSISTENT AT AGAIN AND RETURN POINTS.  FOR AGAIN POINTS IT
 MAKES SURE THAT ALL LOOP VARIABLES IN THE RIGHT ACS."

<DEFINE CLEANUP-STATE (PNOD
		       "AUX" (LOOPVARS <LOOP-VARS .PNOD>)
			     (AGAIN-ST <AGAIN-STATES .PNOD>)
			     (RETURN-ST <RETURN-STATES .PNOD>))
	#DECL ((PNOD) NODE (RETURN-ST) <SPECIAL LIST>)
	<FIXUP-STORES .AGAIN-ST>
	<FIXUP-STORES .RETURN-ST>
	<CLEANUP-VARS <PROG-VARS .PNOD>>
	<LOOP-REPEAT .LOOPVARS .AGAIN-ST>
	<LOOP-RETURN .RETURN-ST>>

<DEFINE LOOP-REPEAT (LOOPVARS AGAIN-ST) 
	<REPEAT ((APTR .AGAIN-ST))
		#DECL ((APTR)
		       <LIST [REST REP-STATE <PRIMTYPE LIST> LIST <OR ATOM FALSE>]>)
		<COND (<EMPTY? .APTR> <RETURN>)>
		<LOOP-RESTORE <LIST !.LOOPVARS>
			      <SAVED-CODE:PTR .APTR>
			      <SAVED-AC-STATE .APTR>
			      <SAVED-STACK-STATE .APTR>
			      <SAVED-RET-FLAG .APTR>>
		<COND (<SAVED-RET-FLAG .APTR>
		       <SET RETURN-ST (<SAVED-CODE:PTR .APTR> <SAVED-AC-STATE .APTR>
				       <SAVED-STACK-STATE .APTR> T !.RETURN-ST)>)>
		<SET APTR <REST .APTR ,LENGTH-CONTROL-STATE>>>>

<DEFINE LOOP-RESTORE (LPV INST ACS STACK-INFO RET) 
	#DECL ((LPV INST STACK-INFO) <PRIMTYPE LIST> (ACS) REP-STATE
	       (RET) <OR ATOM FALSE>)
	<PROG ((SCODE:PTR .INST) (BSTB <SAVED-BSTB .STACK-INFO>)
	       (FRMS <SAVED-FRMS .STACK-INFO>)
	       (NTSLOTS <SAVED-NTSLOTS .STACK-INFO>)
	       (STK <SAVED-STK .STACK-INFO>))
	      #DECL ((NTSLOTS BSTB FRMS STK SCODE:PTR) <SPECIAL LIST>)
	      <STORE-SAVED-ACS .LPV .ACS>
	      <MOVE-AROUND-ACS .LPV .ACS .RET>
	      <GET-ACS-FROM-STACK .LPV .ACS>>>

<DEFINE MOVE-AROUND-ACS (LPV ACS RET) 
	#DECL ((LPV) LIST (ACS) REP-STATE (RET) <OR ATOM FALSE>)
	<REPEAT ((LPVP .LPV) CSYMT CINACS INAC)
		#DECL ((SYMT) SYMTAB (CINACS) DATUM)
		<COND (<EMPTY? .LPVP> <RETURN>)>
		<SET CSYMT <LSYM-SLOT .LPVP>>
		<SET CINACS <LINACS-SLOT .LPVP>>
		<COND (<SET INAC <AC? .CSYMT .ACS>>
		       <PUT .LPVP ,LSYM-SLOT <>>
		       <COND (<=? .INAC .CINACS>)
			     (<TYPE? <DATTYP .CINACS> ATOM>
			      <ONE-EXCH-AC .CINACS .INAC .ACS .CSYMT .RET>)
			     (<TWO-AC-EXCH .CINACS .INAC .ACS .CSYMT .RET>)>)>
		<SET LPVP <REST .LPVP ,LOOPVARS-LENGTH>>>>

<DEFINE ONE-EXCH-AC (DEST-INAC CURR-INAC ACS CSYMT RET) 
	#DECL ((DEST-INAC CURR-INAC) <DATUM ANY AC> (ACS) REP-STATE)
	<SEMIT <INSTRUCTION `EXCH 
			    <ACSYM <DATVAL .CURR-INAC>>
			    <ADDRSYM <DATVAL .DEST-INAC>>>>
	<SWAP-INAC <DATVAL .CURR-INAC>
		   <DATVAL .DEST-INAC>
		   .ACS
		   .CSYMT
		   .RET>>

<DEFINE TWO-AC-EXCH (DEST-INAC CURR-INAC ACS CSYMT RET) 
   #DECL ((DEST-INAC CURR-INAC) DATUM)
   <COND
    (<TYPE? <DATTYP .CURR-INAC> AC>
     <COND (<==? <DATTYP .CURR-INAC> <DATTYP .DEST-INAC>>
	    <ONE-EXCH-AC .DEST-INAC .CURR-INAC .ACS .CSYMT .RET>)
	   (<==? <DATTYP .DEST-INAC> <DATVAL .CURR-INAC>>
	    <SEMIT <INSTRUCTION `EXCH 
				<ACSYM <DATTYP .CURR-INAC>>
				<ADDRSYM <DATTYP .DEST-INAC>>>>
	    <SWAP-INAC <DATTYP .CURR-INAC> <DATTYP .DEST-INAC> .ACS .CSYMT .RET>
	    <COND (<==? <DATVAL .DEST-INAC> <DATVAL .CURR-INAC>>)
		  (<SEMIT <INSTRUCTION `EXCH 
				       <ACSYM <DATVAL .CURR-INAC>>
				       <ADDRSYM <DATVAL .DEST-INAC>>>>
		   <SWAP-INAC <DATVAL .CURR-INAC>
			      <DATVAL .DEST-INAC>
			      .ACS
			      .CSYMT
			      .RET>)>)
	   (ELSE
	    <SEMIT <INSTRUCTION `EXCH 
				<ACSYM <DATTYP .CURR-INAC>>
				<ADDRSYM <DATTYP .DEST-INAC>>>>
	    <SWAP-INAC <DATTYP .CURR-INAC> <DATTYP .DEST-INAC> .ACS .CSYMT .RET>
	    <COND (<==? <DATVAL .DEST-INAC> <DATVAL .CURR-INAC>>)
		  (<SEMIT <INSTRUCTION
			   `EXCH 
			   <ACSYM <DATVAL .CURR-INAC>>
			   <ADDRSYM <DATVAL .DEST-INAC>>>>
		   <SWAP-INAC <DATVAL .CURR-INAC>
			      <DATVAL .DEST-INAC>
			      .ACS
			      .CSYMT
			      .RET>)>)>)
    (<COND (<==? <DATVAL .CURR-INAC> <DATVAL .DEST-INAC>>)
	   (<SEMIT <INSTRUCTION `EXCH 
				<ACSYM <DATVAL .CURR-INAC>>
				<ADDRSYM <DATVAL .DEST-INAC>>>>
	    <SWAP-INAC <DATVAL .CURR-INAC>
		       <DATVAL .DEST-INAC>
		       .ACS
		       .CSYMT
		       .RET>)>
     <SEMIT <INSTRUCTION `MOVE 
			 <ACSYM <DATTYP .DEST-INAC>>
			 !<ADDR:TYPE .CURR-INAC>>>)>>

""

<DEFINE CURRENT-AC-STATE ("OPTIONAL" (RETPNOD <>) "AUX" (BST ()) PAC) 
   #DECL ((VALUE) REP-STATE)
   <COND (.RETPNOD <SET BST <BINDING-STRUCTURE .RETPNOD>>)>
   <MAPF ,LIST
    <FUNCTION (AC "AUX" (ACR <ACRESIDUE .AC>) (SACR ())) 
       <MAPF <>
	<FUNCTION (SYMT) 
	   <COND
	    (<AND <TYPE? .SYMT SYMTAB> <NOT <MEMQ .SYMT .BST>>>
	     <SET SACR
		  (.SYMT
		   <SINACS .SYMT>
		   <COND (<STORED .SYMT>
			  <OR <NOT <TYPE? <NUM-SYM .SYMT> LIST>>
			      <NOT <1 <NUM-SYM .SYMT>>>
			      <L? <LENGTH <NUM-SYM .SYMT>> 2>
			      <2 <NUM-SYM .SYMT>>>)>
		   <AND <SET PAC <PROG-AC .SYMT>>
			<NOT <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PAC>>>>>
		   !.SACR)>)>>
	.ACR>
       .SACR>
    ,ALLACS>>

<DEFINE KILL-LOOP-AC (SYMT "AUX" PNOD) 
	<COND (<AND <TYPE? .SYMT SYMTAB>
		    <SET PNOD <PROG-AC .SYMT>>
		    <NOT <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PNOD>>>>>
	       <PUT .SYMT ,PROG-AC <>>)>>

<DEFINE LVAL-UP (SYMT "AUX" PNAC) 
   #DECL ((SYMT) SYMTAB)
   <COND (<AND <SET PNAC <PROG-AC .SYMT>>
	       <SET PNAC <PROG-SLOT .PNAC>>
	       <NOT <MEMQ .SYMT <LOOP-VARS .PNAC>>>>
	  <COND (<INACS .SYMT>
		 <PUT .PNAC
		      ,LOOP-VARS
		      (.SYMT <INACS-SLOT <PROG-AC .SYMT>> !<LOOP-VARS .PNAC>)>
		 <COND (<STORED-SLOT <PROG-AC .SYMT>>)
		       (<KILL-STORE <NUM-SYM-SLOT <PROG-AC .SYMT>>>)>
		 <COND (<NOT <POTLV .SYMT>> <PUT .SYMT ,STORED <>>)>)
		(ELSE <KILL-LOOP-AC .SYMT>)>)>>

""

<DEFINE STORE-SAVED-ACS (LPV ACS "AUX" CINAC) 
   #DECL ((LPV) LIST (ACS) REP-STATE)
   <MAPF <>
    <FUNCTION (ONE-ACS AC) 
	    #DECL ((ONE-ACS) LIST)
	    <REPEAT ((PTR .ONE-ACS) SYMT)
		    #DECL ((PTR) LIST (SYMT) SYMBOL)
		    <COND (<EMPTY? .PTR> <RETURN>)
			  (<AND <NOT <MEMQ <SET SYMT <CSYMT-SLOT .PTR>> .LPV>>
				<NOT <AND <TYPE? <DATTYP <SET CINAC <CINACS-SLOT .PTR>>>
						 AC>
					  <==? .AC <DATTYP .CINAC>>
					  <TYPE? <DATVAL .CINAC> AC>>>>
			   <SPEC-STOREV .SYMT .CINAC <CSTORED-SLOT .PTR>>)>
		    <SET PTR <REST .PTR ,LENGTH-CSTATE>>>>
    .ACS
    ,ALLACS>>

<DEFINE AC? (SYMT ACS) 
	#DECL ((SYMT) SYMTAB (ACS) LIST)
	<MAPF <>
	      <FUNCTION (AC) 
		      #DECL ((AC) LIST)
		      <REPEAT ((PTR .AC))
			      #DECL ((PTR) LIST)
			      <COND (<EMPTY? .PTR> <RETURN <>>)>
			      <COND (<==? <CSYMT-SLOT .PTR> .SYMT> 
				     <MAPLEAVE <CINACS-SLOT .PTR>>)>
			      <SET PTR <REST .PTR ,LENGTH-CSTATE>>>>
	      .ACS>>

"THIS ROUTINE SWAPS PORTIONS OF DATUMS.  IT TAKES TWO ACS AND THE ACS LIST AND SWAPS THE
 INFORMATION IN THE ACS LIST. AC2 IS THE GOAL AC AND ENDS UP CONTAINING ONLY ONE DATUM."

<DEFINE SWAP-INAC (AC1 AC2 ACS SYMT RET
		   "AUX" (NUM1 <ACNUM .AC1>) (NUM2 <ACNUM .AC2>) SWDAT1 SWDAT2
			 (ACL1 <ACLINK .AC1>) (ACL2 <ACLINK .AC2>) (PUTR ()))
	#DECL ((AC1 AC2) AC (NUM1 NUM2) FIX (ACS) REP-STATE
	       (RET) <OR ATOM FALSE>)
	<COND (.RET
	       <SWAP-DATUMS .ACL1 .AC1 .AC2>
	       <SWAP-DATUMS .ACL2 .AC2 .AC1>
	       <PUT .AC2 ,ACLINK .ACL1>
	       <PUT .AC1 ,ACLINK .ACL2>)>
	<SET SWDAT1 <NTH .ACS .NUM1>>
	<SET SWDAT2 <NTH .ACS .NUM2>>
	<REPEAT ((PTR .SWDAT1) SUB-PTR)
		#DECL ((PTR) LIST)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<COND (<SET SUB-PTR <MEMQ .AC1 <CINACS-SLOT .PTR>>>
		       <SET PUTR (.SUB-PTR .AC2 !.PUTR)>)>
		<SET PTR <REST .PTR ,LENGTH-CSTATE>>>
	<REPEAT ((PTR .SWDAT2) SUB-PTR)
		#DECL ((PTR) LIST)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<COND (<SET SUB-PTR <MEMQ .AC2 <CINACS-SLOT .PTR>>>
		       <SET PUTR (.SUB-PTR .AC1 !.PUTR)>)>
		<SET PTR <REST .PTR ,LENGTH-CSTATE>>>
	<REPEAT ()
		<COND (<EMPTY? .PUTRS> <RETURN>)>
		<PUT <1 .PUTRS> 1 <2 .PUTRS>>
		<SET PUTRS <REST .PUTRS 2>>>
	<PUT .ACS .NUM1 .SWDAT2>
	<PUT .ACS .NUM2 .SWDAT1>>

<DEFINE SWAP-DATUMS (ACL ACOLD ACNEW) 
	#DECL ((ACL) <OR FALSE <LIST [REST DATUM]>>)
	<MAPF <>
	      <FUNCTION (DAT "AUX" ACLTEM) 
		      #DECL ((DAT) DATUM)
		      <COND (<SET ACLTEM <MEMQ .ACOLD .DAT>>
			     <PUT .ACLTEM 1 .ACNEW>)
			    (ELSE <MESSAGE INCONSISTENCY "BAD ACLINK">)>>
	      .ACL>>

<DEFINE GET-ACS-FROM-STACK (LPV ACS) 
   #DECL ((LPV) LIST (ACS) REP-STATE)
   <REPEAT ((LPVP .LPV) DAT DAT2)
	   #DECL ((LPVP) LIST (DAT) DATUM)
	   <COND (<EMPTY? .LPVP> <RETURN>)>
	   <COND (<LSYM-SLOT .LPVP>
		  <SET DAT2 <LADDR <LSYM-SLOT .LPVP> <> <>>>
		  <SET DAT <LINACS-SLOT .LPVP>>
		  <COND (<TYPE? <DATTYP .DAT> AC>
			 <SEMIT <INSTRUCTION
				 `MOVE 
				 <ACSYM <DATTYP .DAT>>
				 !<ADDR:TYPE .DAT2>>>)>
		  <SEMIT <INSTRUCTION `MOVE 
				      <ACSYM <DATVAL .DAT>>
				      !<ADDR:VALUE .DAT2>>>)>
	   <SET LPVP <REST .LPVP ,LOOPVARS-LENGTH>>>>

""

"ROUTINES TO HANDLE LOOP-RETURNS."

<DEFINE LOOP-RETURN (RETINFO "AUX" LST) 
	#DECL ((LST RETINFO) LIST)
	<MAPF <>
	      <FUNCTION (AC "AUX" ACR) 
		      #DECL ((AC) AC)
		      <PUT .AC ,ACLINK <>>
		      <COND (<SET ACR <ACRESIDUE .AC>>
			     <MAPF <>
				   <FUNCTION (IT) <SMASH-INACS .IT <> <>>>
				   .ACR>)>
		      <PUT .AC ,ACRESIDUE <>>>
	      ,ALLACS>
	<COND (<NOT <EMPTY? .RETINFO>>
	       <SET LST <MERGE-RETURNS .RETINFO>>
	       <REPEAT ((PTR .RETINFO))
		       #DECL ((PTR) LIST)
		       <COND (<EMPTY? .PTR> <RETURN>)>
		       <MERGE-SINGLE-RETURN
			<SAVED-AC-STATE .PTR>
			<SAVED-CODE:PTR .PTR>
			.LST
			<SAVED-STACK-STATE .PTR>>
		       <SET PTR <REST .PTR ,LENGTH-CONTROL-STATE>>>)>>

"ROUTINE TO FIGURE OUT A MERGE BETWEEN DIFFERENT RETURN POINTS.  IN THE END A LIST OF
 THINGS TO REMAIN IN AC'S ARE PRODUCED."

<DEFINE MERGE-RETURNS (RETINFO "AUX" (ACKEEP ())) 
   #DECL ((ACKEEP) LIST
	  (RETINFO) <LIST [REST
			   REP-STATE
			   <PRIMTYPE LIST>
			   LIST
			   <OR ATOM FALSE>]>)
   <REPEAT ((CNT 1) MERGER)
	   #DECL ((CNT) FIX)
	   <SET MERGER <NTH <SAVED-AC-STATE .RETINFO> .CNT>>
	   <COND (<NOT <EMPTY? .MERGER>>
		  <REPEAT ((PTR <REST .RETINFO ,LENGTH-CONTROL-STATE>))
			  <COND (<EMPTY? .PTR> <RETURN>)>
			  <SET MERGER
			       <MERG-IT .MERGER
					<NTH <SAVED-AC-STATE .PTR> .CNT>>>
			  <COND (<EMPTY? .MERGER> <RETURN>)>
			  <SET PTR <REST .PTR ,LENGTH-CONTROL-STATE>>>)>
	   <COND (<NOT <EMPTY? .MERGER>> <SET ACKEEP (!.MERGER !.ACKEEP)>)>
	   <COND (<G? <SET CNT <+ .CNT 1>> 5> <RETURN>)>>
   .ACKEEP>

"ROUTINE TO FIGURE OUT IF THINGS MERGE"

<DEFINE MERG-IT (CURR-STATE NEW-STATE "AUX" (OLD-STATE .CURR-STATE) SPTR) 
	#DECL ((CURR-STATE NEW-STATE) LIST)
	<COND (<AND <SET SPTR <MEMQ <CSYMT-SLOT .CURR-STATE> .NEW-STATE>>
		    <=? <CINACS-SLOT .CURR-STATE> <CINACS-SLOT .SPTR>>>
	       <COND (<AND <CSTORED-SLOT .CURR-STATE> <CSTORED-SLOT .SPTR>>)
		     (<PUT .CURR-STATE ,CSTORED-SLOT <>>)>)
	      (<SET CURR-STATE <REST .CURR-STATE ,LENGTH-CSTATE>>)>
	<REPEAT ((PTR .CURR-STATE))
		#DECL ((PTR) LIST)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<COND (<AND <SET SPTR <MEMQ <CSYMT-SLOT .PTR> .NEW-STATE>>
			    <=? <CINACS-SLOT .SPTR> <CINACS-SLOT .CURR-STATE>>>
		       <COND (<AND <CSTORED-SLOT .CURR-STATE>
				   <CSTORED-SLOT .SPTR>>)
			     (<PUT .CURR-STATE ,CSTORED-SLOT <>>)>)
		      (ELSE
		       <PUTREST <REST .OLD-STATE <- ,LENGTH-CSTATE 1>>
				<REST .PTR ,LENGTH-CSTATE>>
		       <SET PTR .OLD-STATE>)>
		<SET OLD-STATE .PTR>
		<SET PTR <REST .PTR ,LENGTH-CSTATE>>>
	.CURR-STATE>

<DEFINE MERGE-SINGLE-RETURN (THISRETURN INS MERGEDRETURN STACK-INFO "AUX" SYMT) 
   #DECL ((INS THISRETURN MERGEDRETURN STACK-INFO) LIST)
   <PROG ((SCODE:PTR .INS) (FRMS <SAVED-FRMS .STACK-INFO>)
	  (BSTB <SAVED-BSTB .STACK-INFO>) (NTSLOTS <SAVED-NTSLOTS .STACK-INFO>)
	  (STK <SAVED-STK .STACK-INFO>))
     #DECL ((FRMS BSTB NTSLOTS STK SCODE:PTR) <SPECIAL LIST>)
     <MAPF <>
      <FUNCTION (CP AC) 
	 #DECL ((AC) AC)
	 <REPEAT ()
		 <COND (<EMPTY? .CP> <RETURN>)>
		 <COND (<AND <NOT <MEMQ <SET SYMT <CSYMT-SLOT .CP>>
					.MERGEDRETURN>>
			     <OR <==? .AC <DATVAL <CINACS-SLOT .CP>>>
				 <NOT <TYPE? <DATVAL <CINACS-SLOT .CP>> AC>>>>
			<SPEC-STOREV .SYMT <CINACS-SLOT .CP> <CSTORED-SLOT .CP>>
			<FLUSH-RESIDUE .AC .SYMT>)
		       (ELSE
			<PUT .SYMT ,STORED <CSTORED-SLOT .CP>>
			<SMASH-INACS .SYMT <CINACS-SLOT .CP>>
			<SMASH-ITEM-INTO-DATUM .SYMT <CINACS-SLOT .CP>>)>
		 <SET CP <REST .CP ,LENGTH-CSTATE>>>>
      .THISRETURN
      ,ALLACS>>>

<DEFINE SPEC-STOREV (SYMT INAC STORED) 
	<SMASH-INACS .SYMT .INAC>
	<SMASH-ITEM-INTO-DATUM .SYMT .INAC>
	<FLUSH-SYMTAB-FROM-AC .SYMT>
	<COND (<TYPE? .SYMT SYMTAB>
	       <AND <NOT .STORED>
		    <PROG ((CODE:TOP (())) (CODE:PTR .CODE:TOP))
			  #DECL ((CODE:TOP CODE:PTR) <SPECIAL LIST>)
			  <PUT .SYMT ,STORED <>>
			  <STOREV .SYMT>
			  <MAPF <> ,SEMIT <REST .CODE:TOP>>>>
	       <PUT .SYMT ,STORED T>)>
	<SMASH-INACS .SYMT <>>>

<DEFINE CLEANUP-SYMT (SYM) 
	#DECL ((SYM) SYMTAB)
	<PUT .SYM ,PROG-AC <>>
	<PUT .SYM ,NUM-SYM T>>

<DEFINE SEMIT (FRM) 
	#DECL ((SCODE:PTR) LIST)
	<PUTREST .SCODE:PTR (.FRM !<REST .SCODE:PTR>)>
	<SET SCODE:PTR <REST .SCODE:PTR>>>

""

<DEFINE FLUSH-SYMTAB-FROM-AC (SYMT "AUX" (INAC <SINACS .SYMT>) AC) 
	<COND (<TYPE? <SET AC <DATTYP .INAC>> AC>
	       <FLUSH-RESIDUE .AC .SYMT>)>
	<COND (<TYPE? <SET AC <DATVAL .INAC>> AC>
	       <FLUSH-RESIDUE .AC .SYMT>)>>

<DEFINE SMASH-ITEM-INTO-DATUM (SYM DAT "AUX" AC) 
	#DECL ((SYM) SYMBOL (DAT) DATUM)
	<COND (<TYPE? <SET AC <DATTYP .DAT>> AC>
	       <OR <MEMQ .SYM <ACRESIDUE .AC>>
		   <PUT .AC ,ACRESIDUE (.SYM !<ACRESIDUE .AC>)>>)>
	<COND (<TYPE? <SET AC <DATVAL .DAT>> AC>
	       <OR <MEMQ .SYM <ACRESIDUE .AC>>
		   <PUT .AC ,ACRESIDUE (.SYM !<ACRESIDUE .AC>)>>)>>

<DEFINE GET-NUM-SYM (SYM "AUX" (SLOT <NUM-SYM .SYM>) NT) 
	<COND (<AND <TYPE? .SLOT LIST> <1 .SLOT>>
	       <PUTREST .SLOT (<SET NT <MAKE:TAG "VAR">> !<REST .SLOT>)>)
	      (ELSE <SET NT T>)>
	.NT>

<DEFINE SMASH-NUM-SYM (SYM) #DECL ((SYM) SYMTAB) <PUT .SYM ,NUM-SYM (T)>>

<DEFINE CLEANUP-VARS (VARLST) 
	#DECL ((VARLST) LIST)
	<REPEAT ((PTR .VARLST) VAR)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<PUT <SET VAR <SYM-SLOT .PTR>>
		     ,NUM-SYM
		     <SAVED-NUM-SYM-SLOT .PTR>>
		<PUT .VAR ,PROG-AC <SAVED-PROG-AC-SLOT .PTR>>
		<PUT .VAR ,POTLV <SAVED-POTLV-SLOT .PTR>>
		<SET PTR <REST .PTR ,LENGTH-PROG-VARS>>>>

<DEFINE FIXUP-STORES (STATE) 
   #DECL ((STATE) <LIST [REST REP-STATE <PRIMTYPE LIST> LIST <OR ATOM FALSE>]>)
   <REPEAT ((PTR .STATE))
     <COND (<EMPTY? .PTR> <RETURN>)>
     <MAPR <>
      <FUNCTION (STATE-ITEMS "AUX" SYMT PAC (STATE-ITEM <1 .STATE-ITEMS>)) 
	 <REPEAT ()
	   <COND (<EMPTY? .STATE-ITEM> <RETURN>)>
	   <SET SYMT <CSYMT-SLOT .STATE-ITEM>>
	   <COND (<OR <CPOTLV-SLOT .STATE-ITEM>
		      <N==? <CSTORED-SLOT .STATE-ITEM> T>>
		  <COND (<OR <AND <N==? <CSTORED-SLOT .STATE-ITEM> T>
				  <MEMQ <CSTORED-SLOT .STATE-ITEM> .KILL-LIST>>
			     <AND <CPOTLV-SLOT .STATE-ITEM>
				  <CSTORED-SLOT .STATE-ITEM>
				  <SET PAC <PROG-AC .SYMT>>
				  <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PAC>>>
				  <NOT <STORED-SLOT .PAC>>>>
			 <PUT .STATE-ITEM ,CSTORED-SLOT <>>)>)>
	   <COND (<AND <CPOTLV-SLOT .STATE-ITEM>
		       <OR <NOT <SET PAC <PROG-AC .SYMT>>>
			   <NOT <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PAC>>>>>>
		  <SET STATE-ITEM <REST .STATE-ITEM ,LENGTH-CSTATE>>)
		 (<RETURN>)>>
	 <COND
	  (<NOT <EMPTY? .STATE-ITEM>>
	   <REPEAT ((START-STATE .STATE-ITEM)
		    (STATE-ITEM <REST .STATE-ITEM ,LENGTH-CSTATE>))
	     <COND (<EMPTY? .STATE-ITEM> <RETURN>)>
	     <SET SYMT <CSYMT-SLOT .STATE-ITEM>>
	     <COND
	      (<OR <CPOTLV-SLOT .STATE-ITEM>
		   <N==? <CSTORED-SLOT .STATE-ITEM> T>>
	       <COND (<OR <AND <N==? <CSTORED-SLOT .STATE-ITEM> T>
			       <MEMQ <CSTORED-SLOT .STATE-ITEM> .KILL-LIST>>
			  <AND <CPOTLV-SLOT .STATE-ITEM>
			       <CSTORED-SLOT .STATE-ITEM>
			       <SET PAC <PROG-AC .SYMT>>
			       <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PAC>>>
			       <NOT <STORED-SLOT .PAC>>>>
		      <PUT .STATE-ITEM ,CSTORED-SLOT <>>)>)>
	     <COND (<AND <CPOTLV-SLOT .STATE-ITEM>
			 <OR <NOT <SET PAC <PROG-AC .SYMT>>>
			     <NOT <MEMQ .SYMT <LOOP-VARS <PROG-SLOT .PAC>>>>>>
		    <PUTREST .START-STATE <REST .STATE-ITEM ,LENGTH-CSTATE>>)>
	     <SET STATE-ITEM <REST .STATE-ITEM ,LENGTH-CSTATE>>
	     <SET START-STATE <REST .START-STATE ,LENGTH-CSTATE>>>)>
	 <PUT .STATE-ITEMS 1 .STATE-ITEM>>
      <SAVED-AC-STATE .PTR>>
     <SET PTR <REST .PTR ,LENGTH-CONTROL-STATE>>>>

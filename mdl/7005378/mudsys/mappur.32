TITLE MAPURE-PAGE LOADER

RELOCATABLE

MAPCH==0			; channel for MAPing

.GLOBAL PURVEC,PURTOP,PURBOT,P.TOP,GCSTOP,FRETOP,MUDSTR,STRTO6,PLOAD,AGC,GCDOWN
.GLOBAL SQUTOA,IGVAL,IBLOCK,PURCLN,MOVPUR,GETPAG,GCFLG,NOSHUF,DIR,NDIRS,SQUPNT
.GLOBAL PLODR,SQUKIL,GETBUF,KILBUF,INPLOD,SQKIL,PVSTOR,TVSTOR,DSTOREM,SLEEPR
.GLOBAL OPSYS

.INSRT MUDDLE >

SYSQ

IFE ITS,[
IF1, .INSRT STENEX >
]


RDTP==1000,,200000
FME==1000,,-1


IFN ITS,[
PGMSK==1777
PGSHFT==10.
]
IFE ITS,[
FLUSHP==0
ELN==3				; Length of table entry
PGMSK==777
PGSHFT==9.
]



LNTBYT==340700
ELN==4				; LENGTH OF SLOT
PGS==3				; PTR AND LENGTH OF PAGE IN FILE


IFE ITS,[
RDPG==120000
CWTP==100400
MFORK==400000
%GTJFN=000001
%OPBIT==202000
%OWBIT==302000
]
; THIS ROUTINE TAKES A SLOT OFFSET IN REGISTER A AND MAPS IN THE ASSOCIATED
; FILE. IT CLOBBERS ALL ACs AND SKIP RETURNS IF IT WINS.

OFF==-5
NAM==-4
LASTC==-3
DIR==-2
SPAG==-1
PGNO==0
VER==-6
FLEN==-7
TEMP==-10
WRT==-11
NSLOTS==12

; IT FIRST LOOKS TO SEE IF IT HAS THE PAGE NUMBER OF THE FILE

PLOAD:	ADD	P,[NSLOTS,,NSLOTS]
	MOVEM	A,OFF(P)
	PUSH	TP,[0]
	PUSH	TP,[0]
IFE ITS,[
	SKIPN	MAPJFN
	PUSHJ	P,OPSAV
]

PLOADX:	PUSHJ	P,SQKIL
	MOVE	A,OFF(P)
	ADD	A,PURVEC+1		; GET TO SLOT
	SKIPE	B,PGS(A)		; SKIP IF PAGE NUMBER
	JRST	GETIT			; GET THE FILE
	MOVE	B,(A)			; GET SIXBIT OF FILE NAME
	MOVEM	B,NAM(P)		; SAVE FIRST FILE NAME
	MOVE	0,B			; COPY FILE NAME
	MOVEI	A,6			; FIND LAST CHARACTER
	TRNE	0,77			; SKIP IF NOT DONE
	JRST	.+3
	LSH	0,-6			; BACK A CHAR
	SOJG	A,.-3			; NOW CHAR IS BACKED OUT
	ANDI	0,77		; LASTCHR

; NOT TO TRY TO FIND FILE IN MAIN DATA BASE.
; THE GC'S WINDOW IS USED IN THIS CASE.

IFN ITS,[
	.CALL	MNBLK		; OPEN CHANNEL TO MAIN FILE
	PUSHJ	P,TRAGN			; TRY OPENING UP CHANNEL AGAIN IF POSSIBLE
]
IFE ITS,[
	MOVE	E,MAPJFN
	MOVEM	E,DIRCHN
]
	MOVE	D,NAM(P)
	MOVEM	0,LASTC(P)
	PUSHJ	P,GETDIR
	MOVEM	E,DIR(P)
	PUSHJ	P,GENVN			; GET VERSION # AS FIX
	MOVE	E,DIR(P)
	MOVE	D,NAM(P)
	MOVE	A,B
	PUSHJ	P,DIRSRC		; SEARCH DIRECTORY
	JRST	NTHERE			; GO TRY FIXING UP ITS NOT THERE
	MOVE	B,OFF(P)		; GET SLOT NUMBER
	ADD	B,PURVEC+1		; POINT TO SLOT
	HRRZ	C,1(A)			; GET BLOCK NUMBER
	HRRM	C,PGS(B)		; SMASH INTO SLOT
	LDB	C,[LNTBYT,,1(A)]	; SMASH IN LENGTH
	HRLM	C,PGS(B)		; SMASH IN LENGTH
	JRST	PLOADX

; NOW TRY TO FIND FILE IN WORKING DIRECTORY

NTHERE:	PUSHJ	P,KILBUF
	MOVE	A,OFF(P)			; GET POINTER TO PURVEC SLOT
	ADD	A,PURVEC+1
	PUSHJ	P,GENVN			; GET VERSION NUMBER
	HRRZM	B,VER(P)
	PUSHJ	P,OPMFIL		; OPEN FILE
	JRST	FIXITU
	
; NUMBER OF PAGES ARE IN A
; STARTING PAGE NUMBER IN E

PLOD1:	PUSHJ   P,ALOPAG        ; get the necessary pages
        JRST    MAPLS2
	MOVE	E,SPAG(P)
	MOVEM	B,PGNO(P)
IFN ITS,[
        MOVN    A,FLEN(P)	; get neg count
        MOVSI   A,(A)           ; build aobjn pointer
        HRR     A,PGNO(P)       ; get page to start
        MOVE    B,A             ; save for later
	HRRI    0,(E)           ; page pointer for file
        DOTCAL	CORBLK,[[1000,,200000],[1000,,-1],A,[1000,,MAPCH],0]
        .LOSE	1000
        .CLOSE  MAPCH,          ; no need to have file open anymore
]
IFE ITS,[
	MOVEI	A,(E)		; First page on rh of A
	HRL	A,FILCHN	; JFN to lh of A
	HRLI	B,400000	; specify this fork
	MOVSI	C,120000	; bits for read/execute
	MOVE	D,FLEN(P)		; # of pages to D
	HRROI	E,(B)		; build page aobjn for later
	TLC	E,-1(D)		; sexy way of doing lh

	PMAP
	ADDI	A,1
	ADDI	B,1
	SOJG	D,.-3		; map 'em all
	MOVE	B,E
]

; now try to smash slot in PURVEC

PLOAD1:	MOVE    A,PURVEC+1 ; get pointer to it
        ASH     B,PGSHFT        ; convert to aobjn pointer to words
	MOVE	C,OFF(P)		; get slot offset
        ADDI    C,(A)           ; point to slot
        MOVEM   B,1(C)          ; clobber it in
        ANDI    B,-1            ; isolate address of page
        HRRZ    D,PURVEC   ; get offset into vector for start of chain
	TRNE	D,400000	; skip if not end marker
	JRST	SCHAIN
        HRLI    D,A             ; set up indexed pointer
        ADDI    D,1
        HRRZ    0,@D            ; get its address
	JUMPE	0,SCHAIN	; no chain exists, start one
	CAILE	0,(B)		; skip if new one should be first
	AOJA	D,INLOOP	; jump into the loop

	SUBI	D,1		; undo ADDI
FCLOB:	MOVE	E,OFF(P)		; get offset for this guy
	HRRM	D,2(C)		; link up
	HRRM	E,PURVEC	; store him away
	JRST	PLOADD

SCHAIN:	MOVEI	D,400000	; get end of chain indicator
	JRST	FCLOB		; and clobber it in

INLOOP:	MOVE	E,D		; save in case of later link up
	HRR	D,@D		; point to next table entry
	TRNE	D,400000	; 400000 is the end of chain bit
	JRST	SLFOUN		; found a slot, leave loop
	ADDI	D,1		; point to address of progs
	HRRZ	0,@D		; get address of block
	CAILE	0,(B)		; skip if still haven't fit it in
	AOJA	D,INLOOP	; back to loop start and point to chain link
	SUBI	D,1		; point back to start of slot

SLFOUN:	MOVE	0,OFF(P)		; get offset into vector of this guy
	HRRM	0,@E		; make previous point to us
	HRRM	D,2(C)		; link it in


PLOADD:	AOS	-NSLOTS(P)		; skip return

MAPLOS:	SUB	P,[NSLOTS,,NSLOTS]	; flush stack crap
	SUB	TP,[2,,2]
	POPJ	P,


MAPLS0: ERRUUO	EQUOTE NO-SAV-FILE
	JRST	MAPLOS
MAPLS1:	ERRUUO	EQUOTE NO-SAV-OR-FIXUP-FILE
 	JRST	MAPLOS

MAPLS2:	ERRUUO	EQUOTE NO-ROOM-AVAILABLE
	JRST	MAPLOS

FIXITU:

FIXITU:

;OPEN FIXUP FILE ON MUDSAV

IFN ITS,[
	.CALL	FIXBLK		; OPEN UP FIXUP FILE
	PUSHJ	P,TRAGN			; SEE IF TOTALLY LOSING
]
IFE ITS,[
	MOVSI	A,%GTJFN		; GTJFN BITS
	MOVE	B,FXSTR
	GTJFN
	FATAL	FIXUP FILE NOT FOUND
	MOVEM	A,DIRCHN
	MOVE	B,[440000,,%OPBIT]
	OPENF
	FATAL	FIXUP FILE CANT BE OPENED
]

	MOVE	0,LASTC(P)			; GET DIRECTORY
	PUSHJ	P,GETDIR
	MOVE	D,NAM(P)
	PUSHJ	P,DIRSR1		; SEARCH DIRECTORY FOR FIXUP
	JRST	NOFXUP			; NO FIXUP IN MAIN DIRECTORY
	HRRZ	A,1(A)			; GET BLOCK NUMBER OF START
	ASH	A,8.			; CONVERT TO WORDS
IFN ITS,[
	.ACCES	MAPCH,A			; ACCESS FILE
]

IFE ITS,[
	MOVEI	B,(A)
	MOVE	A,DIRCHN
	SFPTR
	JFCL
]
	PUSHJ	P,KILBUF
FIXT1:	PUSHJ	P,RFXUP			; READ IN THE FIXUP FILE

IFN ITS,[
	.CALL	MNBLK			; REOPEN SAV FILE
	PUSHJ	P,TRAGN
]

IFE ITS,[
	MOVE	A,MAPJFN		; SET UP DIRCHAN AGAIN
	MOVEM	A,DIRCHN
]

; NOW TRY TO LOCATE SAV FILE

	MOVE	0,LASTC(P)		; GET LASTCHR
	PUSHJ	P,GETDIR		; GET DIRECTORY
	HRRZ	A,VER(P)			; GET VERSION #
	MOVE	D,NAM(P)		; GET NAME OF FILE
	PUSHJ	P,DIRSRC		; SEARCH DIRECTORY
	JRST	MAPLS1			; NO SAV FILE THERE
	HRRZ	E,1(A)			; GET STARTING BLOCK #
	LDB	A,[LNTBYT,,1(A)]	; GET LENGTH INTO A
	MOVEM	A,FLEN(P)		; SAVE LENGTH
	MOVEM	E,SPAG(P)		; SAVE STARTING BLOCK NUMBER
	PUSHJ	P,KILBUF
	MOVE	A,FLEN(P)
	PUSHJ	P,ALOPAG		; GET PAGES
	JRST	MAPLS2
	MOVE	E,SPAG(P)

	PUSHJ	P,RSAV			; READ IN CODE
; now to do fixups

FXUPGO:	MOVE	A,(TP)		; pointer to them
	SETOM	INPLOD		;  ABSOLUTE CLUDGE TO PREVENT BUFFER FROM SCREWING US
	ASH	B,PGSHFT	; aobjn to program
FIX1:	SKIPL	E,(A)		; read one hopefully squoze
	FATAL	ATTEMPT TO TYPE FIX PURE
	TLZ	E,740000

NOPV1:	PUSHJ	P,SQUTOA	; look it up
	FATAL	BAD FIXUPS

; N.B. THE VALUE IN THE FIXUPS FOR AN ADDRESS CAN BE NEGATIVE. IF THIS HAPPENS
; IT MEANS THAT THE LEFT HALF CONTAINS THE VALUE INSTEAD OF THE RIGHT HALF
NOPV2:	AOBJP	A,FIX2
	HLRZ	D,(A)		; get old value
	HRRZS	E
	SUBM	E,D		; D is diff between old and new
	HRLM	E,(A)		; fixup the fixups
NOPV3:	MOVEI	0,0		; flag for which half
FIX4:	JUMPE	0,FIXRH		; jump if getting rh
	MOVEI	0,0		; next time will get rh
	AOBJP	A,FIX2		; done?
	HLRE	C,(A)		; get lh
	JUMPE	C,FIX3		; 0 terminates
FIX5:	SKIPGE	C		; If C is negative then left half garbage
	JRST	FIX6
	ADDI	C,(B)		; access the code

NOPV4:	ADDM	D,-1(C)		; and fix it up
	JRST	FIX4

; FOR LEFT HALF CASE

FIX6:	MOVNS	C		; GET TO ADRESS
	ADDI	C,(B)		; ACCESS TO CODE
	HLRZ	E,-1(C)		; GET OUT WORD
	ADDM	D,E		; FIX IT UP
	HRLM	E,-1(C)
	JRST	FIX4

FIXRH:	MOVEI	0,1		; change flag
	HRRE	C,(A)		; get it and
	JUMPN	C,FIX5

FIX3:	AOBJN	A,FIX1		; do next one
	PUSHJ	P,SQUKIL	; KILL SQUOZE TABLE
	SETZM	INPLOD
FIX2:
IFN ITS,[
	HRRZS	VER(P)		; INDICATE SAV FILE
	MOVEM	B,TEMP(P)
	PUSHJ	P,OPWFIL
	FATAL	MAP FIXUP LOSSAGE
	.IOT	MAPCH,B		; write out the goodie
	.CLOSE	MAPCH,
	PUSHJ	P,OPMFIL
	FATAL	WHERE DID THE FILE GO?
	MOVE	E,TEMP(P)
	ASH	E,-PGSHFT	; to page AOBJN
	DOTCAL	CORBLK,[[1000,,200000],[1000,,-1],E,[1000,,MAPCH],0]
	.LOSE	1000
	.CLOSE	MAPCH,

	MOVEI	0,1		; INDICATE FIXUP
	HRLM	0,VER(P)
	PUSHJ	P,OPWFIL
	FATAL	CANT WRITE FIXUPS
	MOVE	E,(TP)
	HLRE	A,E		; get length
	MOVNS	A
	ADDI	A,2		; account for these 2 words
	MOVE	0,[-2,,A]	; write version and length
	.IOT	MAPCH,0
	.IOT	MAPCH,E		; out go the fixups
	SETZB	0,A
	MOVEI	B,MAPCH
	.CLOSE	MAPCH,
]
IFE ITS,[
	MOVEM	D,TEMP(P)
	PUSHJ	P,OPWFIL	; OPEN FILE FOR WRITE
	FATAL MAP FIXUP LOSSAGE
	MOVE	A,DIRCHN	; GET JFN
	MOVEI	B,TEMP(P)	; ready to write it out
	HRLI	B,444400
	HLRE	C,TEMP(P)
	SOUT			; zap it out
	TLO	A,400000	; dont recycle the JFN
	CLOSF
	JFCL
	ANDI	A,-1		; kill sign bit
	MOVE	B,[440000,,240000]
	OPENF
	FATAL MAP FIXUP LOSSAGE
	MOVE	B,TEMP(P)
	ASH	B,-PGSHFT	; aobjn to pages
	HLRE	D,B		; -count
	HRLI	B,400000
	MOVSI	A,(A)
	MOVSI	C,120000

	PMAP
	ADDI	A,1
	ADDI	B,1
	AOJL	D,.-3

	HLRZS	A
	TLO	A,400000
	CLOSF
	JFCL

	MOVEI	E,1
	HRLM	E,VER(P)	; OPEN FIXUP FILE
	
	SKIPGE	MUDSTR+2
	JRST	NOFIXO		; exp vers, dont write out
	PUSHJ	P,OPWFIL
	FATAL MAP FIXUP LOSSAGE
	MOVE	A,DIRCHN
	HLRE	B,(TP)		; length of fixup vector
	MOVNS	B
	ADDI	B,2		; for length and version words
	BOUT
	PUSH	P,GENVN
	BOUT
	MOVSI	B,444400	; byte pointer to fixups
	HRR	B,(TP)
	HLRE	C,(TP)
	SOUT
	CLOSF
	JFCL
]
NOFIXO:	JRST	PLOAD1



; Here to try to get a free page block for new thing
;	A/	# of pages to get

ALOPAG:	MOVE	C,GCSTOP	; FOOL GETPAG
	ADDI	C,3777
	ASH	C,-PGSHFT
	MOVE	B,PURBOT
	ASH	B,-PGSHFT
	SUBM	B,C		; SEE IF ROOM
	CAIL	C,(A)
	JRST	ALOPGW
	PUSHJ	P,GETPAG	; try to get enough pages
	POPJ	P,
ALOPGW:	AOS	(P)		; won skip return
	MOVE	0,PURBOT
	ASH	0,-PGSHFT
	SUBI	0,(A)
	MOVE	B,0
	ASH	0,PGSHFT
	MOVEM	0,PURBOT
	CAML	0,P.TOP
	POPJ	P,
IFE ITS,[
	SUBI	0,1777
	ANDCMI	0,1777
]
	MOVEM	0,P.TOP
	POPJ	P,

GETPAG:	MOVE	C,P.TOP		; top of GC space
	ASH	C,-PGSHFT	; to page number
	MOVE	B,PURBOT	; current bottom of pure space
	ASH	B,-PGSHFT	; also to pages
	SUBM	B,C		; pages available ==> C
	CAMGE	C,A		; skip if have enough already
	JRST	GETPG1		; no, try to shuffle around
	SUBI	B,(A)		; B/  first new page
	AOS	(P)
	POPJ	P,		; return with new free page in B

; Here if shuffle must occur or gc must be done to make room

GETPG1:	MOVEI	0,0
	SKIPE	NOSHUF		; if can't shuffle, then ask gc
	JRST	ASKAGC
	MOVE	0,PURTOP	; get top of mapped pure area
	SUB	0,P.TOP
	ASH	0,-PGSHFT	; to pages
	CAMGE	0,A		; skip if winnage possible
	JRST	ASKAGC		; please AGC give me some room!!
	SUBM	A,C		; C/ amount we must flush to make room

; Here to find pages for flush using LRU algorithm

GL1:	MOVE	B,PURVEC+1	; get pointer to pure sr vector
	MOVEI	0,-1		; get very large age

GL2:	SKIPN	1(B)		; skip if not already flushed
	JRST	GL3
	HLRZ	D,2(B)		; get this ones age
	CAMLE	D,0		; skip if this is a candidate
	JRST	GL3
	MOVE	E,B		; point to table entry with E
	MOVEI	0,(D)		; and use as current best
GL3:	ADD	B,[ELN,,ELN]	; look at next
	JUMPL	B,GL2

	HLRE	B,1(E)		; get length of flushee
	ASH	B,-PGSHFT	; to negative # of pages
	ADD	C,B		; update amount needed
IFN ITS,	SETZM	1(E)		; indicate it will be gone
IFE ITS,	MOVNS	1(E)		; dont lose information
	JUMPG	C,GL1		; jump if more to get

; Now compact pure space

	PUSH	P,A		; need all acs
	SETZB	E,A
	HRRZ	D,PURVEC	; point to first in core addr order
	HRRZ	C,PURTOP	; get destination page
	ASH	C,-PGSHFT	; to page number

CL1:	ADD	D,PURVEC+1	; to real pointer
IFN ITS,	SKIPE	1(D)		; skip if this one is a flushee
IFE ITS,	SKIPGE	1(D)
	JRST	CL2


	HRRZ	D,2(D)		; point to next one in chain
	JUMPN	E,CL3		; jump if not first one
	HRRM	D,PURVEC	; and use its next as first
	JRST	CL4

CL3:	HRRM	D,2(E)		; link up
	JRST	CL4

; Found a stayer, move it if necessary

CL2:	MOVEI	E,(D)		; another pointer to slot
	HLRE	B,1(D)		; - length of block
	HRRZ	D,1(D)		; pointer to block
	SUB	D,B		; point to top of block
	ASH	D,-PGSHFT		; to page number
	CAIN	D,(C)		; if not moving, jump
	JRST	CL6

	ASH	B,-PGSHFT	; to pages
IFN ITS,[
CL5:	SUBI	C,1		; move to pointer and from pointer
	SUBI	D,1
	DOTCAL	CORBLK,[[1000,,200000],[1000,,-1],C,[1000,,-1],D]
	FATAL	PURE SHUFFLE LOSSAGE
	AOJL	B,CL5		; count down
]
IFE ITS,[
	PUSH	P,B		; save # of pages
	MOVEI	A,-1(D)		; copy from pointer
	HRLI	A,400000	; get this fork code
	RMAP			; get a JFN (hopefully)
	EXCH	D,(P)		; D # of pages (save from)
	ADDM	D,(P)		; update from
	MOVEI	B,-1(C)		; to pointer in B
	HRLI	B,400000
	MOVSI	C,120000	; read/execute modes

	PMAP			; move a page
	SUBI	A,1
	SUBI	B,1
	AOJL	D,.-3		; move them all

	MOVEI	C,1(B)
	POP	P,D
]
; Update the table address for this loser

	SUBM	C,D		; compute offset (in pages)
	ASH	D,PGSHFT	; to words
	ADDM	D,1(E)		; update it
CL7:	HRRZ	D,2(E)		; chain on
CL4:	TRNN	D,400000	; skip if end of chain
	JRST	CL1

	ASH	C,PGSHFT	; to words
	MOVEM	C,PURBOT	; reset pur bottom
	POP	P,A
	JRST	GETPAG

CL6:	HRRZ	C,1(E)		; get new top of world
	ASH	C,-PGSHFT	; to page #
	JRST	CL7

; SUBR to create an entry in the vector for one of these guys

MFUNCTION PCODE,SUBR

	ENTRY	2

	GETYP	0,(AB)		; check 1st arg is string
	CAIE	0,TCHSTR
	JRST	WTYP1
	GETYP	0,2(AB)		; second must be fix
	CAIE	0,TFIX
	JRST	WTYP2

	MOVE	A,(AB)		; convert name of program to sixbit
	MOVE	B,1(AB)
	PUSHJ	P,STRTO6
PCODE4:	MOVE	C,(P)		; get name in sixbit

; Now look for either this one or an empty slot

	MOVEI	E,0
	MOVE	B,PURVEC+1

PCODE2:	CAMN	C,(B)		; skip if this is not it
	JRST	PCODE1		; found it, drop out of loop
	JUMPN	E,.+3		; dont record another empty if have one
	SKIPN	(B)		; skip if slot filled
	MOVE	E,B		; remember pointer
	ADD	B,[ELN,,ELN]
	JUMPL	B,PCODE2	; jump if more to look at

	JUMPE	E,PCODE3	; if E=0, error no room
	MOVEM	C,(E)		; else stash away name and zero rest
	SETZM	1(E)
	SETZM	2(E)
	JRST	.+2

PCODE1:	MOVE	E,B		; build <slot #>,,<offset>
	MOVEI	0,0		; flag whether new slot
	SKIPE	1(E)		; skip if mapped already
	MOVEI	0,1
	MOVE	B,3(AB)
	HLRE	D,E
	HLRE	E,PURVEC+1
	SUB	D,E
	HRLI	B,(D)
	MOVSI	A,TPCODE
	SKIPN	NOSHUF		; skip if not shuffling
	JRST	FINIS
	JUMPN	0,FINIS		; jump if winner
	PUSH	TP,A
	PUSH	TP,B
	HLRZ	A,B
	PUSHJ	P,PLOAD
	JRST	PCOERR
	POP	TP,B
	POP	TP,A
	JRST	FINIS

PCOERR:	ERRUUO	EQUOTE PURE-LOAD-FAILURE


PCODE3:	HLRE	A,PURVEC+1	; get current length
	MOVNS	A
	ADDI	A,10*ELN	; add 10(8) more entry slots
	PUSHJ	P,IBLOCK
	EXCH	B,PURVEC+1	; store new one and get old
	HLRE	A,B		; -old length to A
	MOVSI	B,(B)		; start making BLT pointer
	HRR	B,PURVEC+1
	SUBM	B,A		; final dest to A
	BLT	B,-1(A)
	JRST	PCODE4

; Here if must try to GC for some more core

ASKAGC:	SKIPE	GCFLG		; if already in GC, lose
	POPJ	P,
	MOVEM	A,0		; amount required to 0
	ASH	0,PGSHFT	; TO WORDS
	MOVEM	0,GCDOWN	; pass as funny arg to AGC
	EXCH	A,C		; save A from gc's destruction
IFN ITS,	.IOPUSH	MAPCH,		; gc uses same channel
	PUSH	P,C
	MOVE	C,[8,,9.]	; SET UP INDICATORS FOR GC
	PUSHJ	P,AGC
	POP	P,C
IFN ITS,	.IOPOP	MAPCH,
	EXCH	C,A
	JUMPGE	C,GETPAG
	ERRUUO	EQUOTE NO-MORE-PAGES

; Here to clean up pure space by flushing all shared stuff

PURCLN:	SKIPE	NOSHUF
	POPJ	P,
	MOVEI	B,400000
	HRRM	B,PURVEC	; flush chain pointer
	MOVE	B,PURVEC+1	; get pointer to table
CLN1:	SETZM	1(B)		; zero pointer entry
	SETZM	2(B)		; zero link and age slots
	SETZM	3(B)
	ADD	B,[ELN,,ELN]	; go to next slot
	JUMPL	B,CLN1		; do til exhausted
	MOVE	B,PURBOT	; now return pages
	SUB	B,PURTOP	; compute page AOBJN pointer
	JUMPE	B,CPOPJ		; no pure pages?
	MOVSI	B,(B)
	HRR	B,PURBOT
	ASH	B,-PGSHFT
IFN ITS,[
	DOTCAL	CORBLK,[[1000,,0],[1000,,-1],B]
	FATAL	SYSTEM WONT TAKE CORE BACK?
]
IFE ITS,[

	HLRE	D,B		; - # of pges to flush
	HRLI	B,400000	; specify hacking hom fork
	MOVNI	A,1
	MOVEI	C,0

	PMAP
	ADDI	B,1
	AOJL	D,.-2

]

	MOVE	B,PURTOP	; now fix up pointers
	MOVEM	B,PURBOT	;   to indicate no pure
CPOPJ:	POPJ	P,

; Here to move the entire pure space.
;	A/	# and direction of pages to move (+ ==> up)

MOVPUR:	SKIPE	NOSHUF
	FATAL	CANT MOVE PURE SPACE AROUND
	IFE ITS [ASH A,1]
	SKIPN	B,A		; zero movement, ignore call
	POPJ	P,

	ASH	B,PGSHFT	; convert to words for pointer update
	MOVE	C,PURVEC+1	; loop through updating non-zero entries
	SKIPE	1(C)
	ADDM	B,1(C)
	ADD	C,[ELN,,ELN]
	JUMPL	C,.-3

	MOVE	C,PURTOP	; found pages at top and bottom of pure
	ASH	C,-PGSHFT
	MOVE	D,PURBOT
	ASH	D,-PGSHFT
	ADDM	B,PURTOP	; update to new boundaries
	ADDM	B,PURBOT
	CAIN	C,(D)		; differ?
	POPJ	P,
	JUMPG	A,PUP		; if moving up, go do separate CORBLKs

IFN ITS,[
	SUBM	D,C		; -size of area to C (in pages)
	MOVEI	E,(D)		; build pointer to bottom of destination
	ADD	E,A
	HRLI	E,(C)
	HRLI	D,(C)
	DOTCAL	CORBLK,[[1000,,200000],[1000,,-1],E,[1000,,-1],D]
	FATAL	CANT MOVE PURE
	POPJ	P,

PUP:	SUBM	C,D		; pages to move to D
	ADDI	A,(C)		; point to new top

PUPL:	SUBI	C,1
	SUBI	A,1
	DOTCAL	CORBLK,[[1000,,200000],[1000,,-1],A,[1000,,-1],C]
	FATAL	CANT MOVE PURE
	SOJG	D,PUPL
	POPJ	P,
]
IFE ITS,[
	SUBM	D,C		; pages to move to D
	MOVSI	E,(C)		; build aobjn pointer
	HRRI	E,(D)		; point to lowest
	ADD	D,A		; D==> new lowest page
PURCL1:	MOVSI	A,400000	; specify here
	HRRI	A,(E)		; get a page
	RMAP			; get a real handle on it
	MOVE	B,D		; where to go
	HRLI	B,400000
	MOVSI	C,120000
	PMAP
	ADDI	D,1
	AOBJN	E,PURCL1
	POPJ	P,

PUP:	SUB	D,C		; - count to D
	MOVSI	E,(D)		; start building AOBJN
	HRRI	E,(C)		; aobjn to top
	ADD	C,A		; C==> new top
	MOVE	D,C

PUPL:	MOVSI	A,400000
	HRRI	A,(E)
	RMAP			; get real handle
	MOVE	B,D
	HRLI	B,400000
	MOVSI	C,120000
	PMAP
	SUBI	E,2
	SUBI	D,1
	AOBJN	E,PUPL

	POPJ	P,
]
IFN ITS,[
.GLOBAL CSIXBT
CSIXBT:	MOVEI	0,5
	PUSH	P,[440700,,C]
	PUSH	P,[440600,,D]
	MOVEI	D,0
CSXB2:	ILDB	E,-1(P)
	CAIN	E,177
	JRST	CSXB1
	SUBI	E,40
	IDPB	E,(P)
	SOJG	0,CSXB2
CSXB1:	SUB	P,[2,,2]
	MOVE	C,D
	POPJ	P,
]
GENVN:	MOVE	C,[440700,,MUDSTR+2]
	MOVEI	D,5
	MOVEI	B,0
VNGEN:	ILDB	0,C
	CAIN	0,177
	POPJ	P,
	IMULI	B,10.
	SUBI	0,60
	ADD	B,0
	SOJG	D,VNGEN
	POPJ	P,

IFE ITS,[
MSKS:	774000,,0
	777760,,0
	777777,,700000
	777777,,777400
	777777,,777776
]

; THESE ARE DIRECTORY SEARCH ROUTINES


; THIS ROUTINE DOES A BINARY SEARCH ON A DIRECTORY AND RETURNS A POINTER
; RESTED DOWN TO THE APPROPRIATE SLOT IN THE DIRECTORY.
; ARGS: E==DIR POINTER D==FILE-NAME 1 A==VERSION #
; RETS: A==RESTED DOWN DIRECTORY

DIRSR1:	TLOA	0,400000		; INDICATION OF ONE ARGUMENT SEARCH
DIRSRC:	TLZ	0,400000		; INDICATOR OF 2 ARGUMENT SEARCH
	PUSH	P,A			; SAVE VERSION #
	HLRE	B,E			; GET LENGTH INTO B
	MOVNS	B
	MOVE	A,E
	HRLS	B			; GET BOTH SIDES
UP:     ASH     B,-1            	; HALVE TABLE
        AND     B,[-2,,-2]      	; FORCE DIVIS BY 2
        MOVE    C,A             	; COPY POINTER
        JUMPLE  B,LSTHLV        	; CANT GET SMALLER
        ADD     C,B
        CAMLE   D,(C)			; SKIP IF EITHER FOUND OR IN TOP
        MOVE    A,C             	; POINT TO SECOND HALF
        CAMN    D,(C)           	; SKIP IF NOT FOUND
        JRST    WON
        CAML    D,(C)           	; SKIP IF IN TOP HALF
        JRST    UP
        HLLZS   C               	; FIX UP POINTER
        SUB     A,C
        JRST    UP

WON:	JUMPL	0,SUPWIN
	MOVEI	0,0			; DOWN FLAG
WON1:	LDB	A,[221200,,1(C)]	; GET VERSION NUMBER
	CAMN	A,(P)			; SKIP IF NOT EQUAL
	JRST	SUPWIN
	CAMG	A,(P)			; SKIP IF LT
	JRST	SUBIT
	SETO	0,
	SUB	C,[2,,2]		; GET NEW C
	JRST	SUBIT1
SUBIT:	ADD	C,[2,,2]		; SUBTRACT
	JUMPN	0,C1POPJ
SUBIT1:	CAMN	D,(C)			; SEE WHETHER WERE STILL WINNING
	JRST	WON1
C1POPJ:	SUB	P,[1,,1]		; GET RID OF VERSION #
	POPJ	P,			; LOSE LOSE LOSE
SUPWIN:	MOVE	A,C			; RETURN ARGUMENT IN A  
	AOS	-1(P)			; SKIP RETURN INDICATES IT WAS FOUND
	JRST	C1POPJ

LSTHLV: CAMN    D,(C)           	; LINEAR SEARCH REST
        JRST    WON
        ADD     C,[2,,2]
        JUMPL   C,.-3
	JRST	C1POPJ

; ROUTINE TO GET A DIRECTORY. ASSUMES MAPCH IS OPEN TO FIXUP OR SAV FILE AND 0 IS THE
; LAST CHAR TO BE HASHED. RETURNS POINTER TO DIRECTORY IN E

IFN ITS,[
GETDIR:	PUSH	P,C
	PUSH	P,0
	PUSHJ	P,SQKIL
	MOVEI	A,1			; GET A BUFFER
	PUSHJ	P,GETBUF
	MOVEI	C,(B)
	ASH	C,-10.
	DOTCAL	CORBLK,[[RDTP],[FME],C,[1000,,MAPCH],[1000,,0]]
	PUSHJ	P,SLEEPR
	POP	P,0
	IDIV	0,(B)			; A NOW CONTAINS THE DIRECTORY NUMBER
	ADDI	A,1(B)
	DOTCAL	CORBLK,[[RDTP],[FME],C,[1000,,MAPCH],(A)]
	PUSHJ	P,SLEEPR
	MOVN	E,(B)			; GET -LENGTH OF DIRECTORY
	HRLZS	E			; BUILD AOBJN PTR TO DIR
	HRRI	E,1(B)
	POP	P,C
	POPJ	P,
]
; IN WONDERFUL TOPS20 VERSION DIRCHN CONTAINS THE JFN

IFE ITS,[
GETDIR:	PUSH	P,C
	PUSH	P,0
	PUSHJ	P,SQKIL
	MOVEI	A,1			; GET A BUFFER
	PUSHJ	P,GETBUF
	MOVEI	E,(B)
	ASH	B,-9.
	HRLI	B,MFORK			; SET UP DESTINATION (CORE)
	MOVS	A,DIRCHN		; SET UP SOURCE (FILE)
	MOVSI	C,RDPG			; READ+EXEC ACCESS
	PMAP
	POP	P,0
	IDIV	0,(E)			; A NOW CONTAINS THE DIRECTORY NUMBER
	ADDI	A,1(E)			; POINT TO THE DIRECTORY ENTRY
	MOVE	A,(A)			; GET THE PAGE NUMBER
	HRL	A,DIRCHN		; SET UP SOURCE (FILE)
	PMAP				; AGAIN READ IN DIRECTORY
	MOVEI	A,(E)
	MOVN	E,(E)			; GET -LENGTH OF DIRECTORY
	HRLZS	E			; BUILD AOBJN PTR TO DIR
	HRRI	E,1(A)
	POP	P,C
]	POPJ	P,

; HERE IF CAN'T FIND FIXUP FILE IN MAIN DIRECTORY

NOFXUP:	MOVE	A,FXTBL			; GET AOBJN POINTER TO FIXUP TABLE
NOFXU1:	HRRZ	B,(A)			; GET VERSION TO TRY
	HRRM	B,VER(P)		; STUFF IN VERSION
	MOVEI	B,1			; DUMP IN FIXUP INDICATOR
	HRLM	B,VER(P)
	MOVEM	A,TEMP(P)		; SAVE POINTER TO FXTBL
	PUSHJ	P,OPMFIL		; LOOK FOR FIXUP FILE	
	JRST	NOFXU2
	PUSHJ	P,RFXUP			; READ IN THE FIXUP FILE
	HRRZS	VER(P)			; INDICATE SAF FILE
	PUSHJ	P,OPMFIL		; TRY OPENING IT
	JRST	MAPLS0			; GIVE UP NO SAV FILE TO BE HAD
	PUSHJ	P,RSAV
	JRST	FXUPGO			; GO FIXUP THE WORLD
NOFXU2:	MOVE	A,TEMP(P)		; GET BACK POINTER
	AOBJN	A,NOFXU1		; TRY NEXT
	JRST	MAPLS1			; NO FILE TO BE HAD




GETIT:	HRRZ	E,B			; GET BLOCK OF START
	HLRZ	A,B			; GET LENGTH
IFN ITS,[
	.CALL	MNBLK
	PUSHJ	P,TRAGN
]
	JRST	PLOD1

; ROUTINE TO SEE IF FILE IS NOT OPEN BECAUSE OF FNF AND FATAL IF SO

IFN ITS,[
TRAGN:	PUSH	P,0		; SAVE 0
	.STATUS	MAPCH,0		; GET STATUS BITS
	LDB	0,[220600,,0]
	CAIN	0,4		; SKIP IF NOT FNF
	FATAL	MAJOR FILE NOT FOUND
	POP	P,0
	SOS	(P)
	SOS	(P)		; RETRY OPEN
	POPJ	P,
]
IFE ITS,[
OPSAV:	MOVSI	A,%GTJFN	; BITS FOR GTJFN
	MOVE	B,SAVSTR	; STRING POINTER
	GTJFN
	FATAL	CANT FIND SAV FILE
	MOVEM	A,MAPJFN	; STORE THE JFN
	MOVE	B,[440000,,%OPBIT]
	OPENF
	FATAL	CANT OPEN SAV FILE
	POPJ	P,
]

; OPMFIL IS USED TO OPEN A FILE ON MUDTMP.  IT CAN OPEN EITHER A SAV OR FIXUP FILE
; AND THE VERSION NUMBER IS SPECIFIED.  THE ARGUMENTS ARE
; NAM-1(P) HAS SIXBIT OF FILE NAME
; VER-1(P) HAS 0,,VERSION # FOR SAV FILE AND 1,,VERSION# FOR FIXUP FILE
; RETURNS LENGTH OF FILE IN SLEN AND 

OPWFIL:	SETOM	WRT-1(P)
	SKIPA
OPMFIL:	SETZM	WRT-1(P)

IFN ITS,[
	HRRZ	C,VER-1(P)		; GET VERSION NUMBER
	PUSHJ	P,NTOSIX		; CONVERT TO SIXBIT
	HRLI	C,(SIXBIT /SAV/)	; BUILD SECOND FILE NAME
	HLRZ	0,VER-1(P)
	SKIPE	0			; SKIP IF SAV
	HRLI	C,(SIXBIT/FIX/)
	MOVE	B,NAM-1(P)		; GET NAME
	MOVSI	A,7			; WRITE MODE
	SKIPL	WRT-1(P)
	MOVSI	A,6			; READ MODE
RETOPN: .CALL	FOPBLK
	JRST	OPCHK			; SEE IF FIXUP IS NECESSARY OR JUST REOPENING
	DOTCAL	FILLEN,[[1000,,MAPCH],[2000,,A]]
	 .LOSE	1000
	ADDI	A,PGMSK			; ROUND
	ASH	A,-PGSHFT		; TO PAGES
	MOVEM	A,FLEN-1(P)
	SETZM	SPAG-1(P)
	AOS	(P)			; SKIP RETURN TO SHOW SUCCESS
	POPJ	P,

OPCHK: .STATUS	MAPCH,0			; GET STATUS BITS
	LDB	0,[220600,,0]
	CAIE	0,4			; SKIP IF FNF
	JRST	OPCHK1			; RETRY
	POPJ	P,

OPCHK1:	MOVEI	0,1			; SLEEP FOR A WHILE
	.SLEEP
	JRST	OPCHK

; NTOSIX GETS NUMBER IN C AND CONVERTS IT TO SIXBIT AND RETURNS RESULT IN C
 
NTOSIX:	PUSH	P,A			; SAVE A AND B
	PUSH	P,B
	PUSH	P,D
	MOVE	D,[220600,,C]
	MOVEI	A,(C)			; GET NUMBER
	MOVEI	C,0
	IDIVI	A,100.			; GET RESULT OF DIVISION
	SKIPN	A
	JRST	ALADD
	ADDI	A,20			; CONVERT TO DIGIT
	IDPB	A,D
ALADD:	MOVEI	A,(B)
	IDIVI	A,10.			; GET TENS DIGIT
	ADDI	A,20
	IDPB	A,D
	ADDI	B,20
	IDPB	B,D
	POP	P,D
	POP	P,B
	POP	P,A
	POPJ	P,

]

IFE ITS,[
	MOVE	E,P		; save pdl base
	MOVE	B,NAM-1(E)		; GET FIRST NAME
	PUSH	P,[0]		; slots for building strings
	PUSH	P,[0]
	MOVE	A,[440700,,1(E)]
	MOVE	C,[440600,,B]
	
; DUMP OUT SIXBIT NAME

	MOVEI	D,6
	ILDB	0,C
	JUMPE	0,.+4		; violate cardinal ".+ rule"
	ADDI	0,40		; to ASCII
	IDPB	0,A
	SOJG	D,.-4

	MOVE	0,[ASCII /  SAV/]
	HLRZ	C,VER-1(E)		; GET SAV/FIXUP FLAG
	SKIPE	C
	MOVE	0,[ASCII /  FIX/]
	PUSH	P,0 
	HRRZ	C,VER-1(E)		; get ascii of vers no.
	PUSHJ	P,NTOSEV	; CONVERT TO STRING LEFT JUSTIFIED
	PUSH	P,C
	MOVEI	B,-1(P)		; point to it
	HRLI	B,260700
	HRROI	D,1(E)		; point to name
	MOVEI	A,1(P)

	PUSH	P,[100000,,]
	PUSH	P,[377777,,377777]
	PUSH	P,[-1,,[ASCIZ /DSK/]]
	PUSH	P,[-1,,[ASCIZ /MUDTMP/]]
	PUSH	P,D
	PUSH	P,B
	PUSH	P,[0]
	PUSH	P,[0]
	PUSH	P,[0]
	MOVEI	B,0
	MOVE	D,4(E)		; save final version string
	GTJFN
	JRST	OPMLOS		; FAILURE
	MOVEM	A,DIRCHN
	MOVE	B,[440000,,%OPBIT]
	SKIPE	WRT-1(P)
	MOVE	B,[440000,,%OWBIT]
	OPENF
	FATAL	OPENF FAILED
	MOVE	P,E		; flush crap
	PUSH	P,A
	SIZEF			; get length
	JRST	MAPLOS
	MOVEM	C,FLEN-1(E)
	SETZM	SPAG-1(E)

; RESTORE STACK AND LEAVE

	MOVE	P,E
	AOS	(P)
	POPJ	P,

OPMLOS:	MOVE	P,E
	POPJ	P,

; CONVERT A NUMBER IN C TO AN ASCII STRING LEFT JUSTIFIED IN C

NTOSEV:	PUSH	P,A			; SAVE A AND B
	PUSH	P,B
	PUSH	P,D
	MOVE	D,[250700,,C]
	MOVEI	A,(C)			; GET NUMBER
	MOVEI	C,0
	IDIVI	A,100.			; GET RESULT OF DIVISION
	SKIPN	A
	JRST	ALADD
	ADDI	A,60			; CONVERT TO DIGIT
	IDPB	A,D
ALADD:	MOVEI	A,(B)
	IDIVI	A,10.			; GET TENS DIGIT
	ADDI	A,60
	IDPB	A,D
	ADDI	B,60
	IDPB	B,D
	POP	P,D
	POP	P,B
	POP	P,A
	POPJ	P,

]

; ROUTINE TO READ IN THE FIXUPS FROM DIRCHN OR MAPCH WORKS
; FOR FIXUP FILE OR FIXUPS IN A SEPERATE FILE AS LONG AS THE
; CHANNEL IS OPENED AND ACCESSED TO THE RIGHT PLACE

RFXUP:
IFN ITS,[
	MOVE	0,[-2,,A]		; PREPARE TO READ VERSION AND LENGTH
	.IOT	MAPCH,0			; READ IT IN
	SKIPGE	0			; SKIP IF NOT HIT EOF
	FATAL	BAD FIXUP FILE
	MOVEI	A,-2(A)			; COUNT FOR FIRST 2 WORDS
	HRRM	B,VER-1(P)		; SAVE VERSION #
	.IOPUS	MAPCH,			; PUSH THE MAPPING CHANNEL
	SETOM	PLODR
	PUSHJ	P,IBLOCK		; GET A UVECTOR OF APPROPRIATE SIZE
	SETZM	PLODR
	.IOPOP	MAPCH,
	MOVE	0,$TUVEC
	MOVEM	0,-1(TP)		; SAVE UVECTOR
	MOVEM	B,(TP)
	MOVE	A,B			; GET AOBJN POINTER TO UVECTOR FOR IOT
	.IOT	MAPCH,A			; GET FIXUPS
	.CLOSE	MAPCH,
	POPJ	P,
]

IFE ITS,[
	MOVE	A,DIRCHN
	BIN				; GET LENGTH OF FIXUP
	MOVE	C,A
	SKIPN	OPSYS
	MOVE	C,B			; BIN RESULT IN B IN TOPS20
	MOVE	A,DIRCHN
	BIN				; GET VERSION NUMBER
	HRRM	A,VER-1(P)
	SKIPN	OPSYS
	MOVEM	B,VER(P)
	SETOM	PLODR
	MOVEI	A,-2(C)
	PUSHJ	P,IBLOCK
	SETZM	PLODR
	MOVSI	0,$TUVEC
	MOVEM	0,-1(TP)
	MOVEM	B,(TP)
	MOVE	A,DIRCHN
	HLRE	C,B
	SKIPE	OPSYS			; SKIP IF TOPS20 SINCE C MUST BE NEGETIVE
	MOVNS	C			; C IS POSITIVE FOR TENEX ?????
	HRLI	B,444400
	SIN
	MOVE	A,DIRCHN
	CLOSF
	FATAL	CANT CLOSE FIXUP FILE
	RLJFN
	FATAL	CANT RELEASE FIXUP JFN
	POPJ	P,
]

; ROUTINE TO READ IN THE CODE

RSAV:

IFN ITS,[
	MOVN	A,FLEN-1(P)	; build aobjn pointer
	MOVSI	A,(A)
	HRRI	A,(B)
	MOVE	B,A
	HRRI	0,(E)
	DOTCAL	CORBLK,[[1000,,104000],[1000,,-1],A,[1000,,MAPCH],0]
	FATAL	CORBLK FAILED
	.CLOSE	MAPCH,
	POPJ	P,
]
IFE ITS,[
	MOVS	A,DIRCHN	; SOURCE (MUDSAV)
	HRR	A,E
	HRLI	B,MFORK		;DESTINATION (FORK)
	MOVSI	C,CWTP		;MAKE COPY ON WRITE
	SKIPE	OPSYS
	JRST	RSAV1		; HANDLE TENEX
	MOVSI	C,500400	; REPEAT COUNT BIT FOR TOPS20
	HRR	C,FLEN-1(P)	; PAGE
	PMAP
	POPJ	P,

RSAV1:	HRRZ	D,FLEN-1(P)	; GET IN PAGE COUNT
	PMAP
	ADDI	A,1		; NEXT PAGE
	ADDI	B,1	
	SOJN	D,RSAV1		; LOOP
	POPJ	P,
]



; CONSTANTS RELATED TO DATA BASE
DEV:	SIXBIT /DSK/
MODE:	6,,0
MNDIR:	SIXBIT /MUDSAV/				; DIR OF MAIN DATA BASE FILES
WRKDIR:	SIXBIT /MUDTMP/				; DIRECTORY OF UPDATE FILES

IFN ITS,[
MNBLK:	SETZ
	SIXBIT /OPEN/
	MODE
	DEV
	[SIXBIT /SAV/]
	[SIXBIT /FILE/]
	SETZ MNDIR


FIXBLK:	SETZ
	SIXBIT /OPEN/
	MODE
	DEV
	[SIXBIT /FIXUP/]
	[SIXBIT /FILE/]
	SETZ MNDIR

FOPBLK:	SETZ
	SIXBIT /OPEN/
        A
        DEV
        B
        C
        SETZ WRKDIR

FXTBL:	-2,,.+1
	55.
	54.
]
IFE ITS,[

FXSTR:	440700,,[ASCIZ /<MUDSAV>FIXUP.FILE/]
SAVSTR:	440700,,[ASCIZ /<MUDSAV>SAV.FILE/]

FXTBL:	-3,,.+1
	55.
	54.
	104.
]
IMPURE

SAVSNM:	0					; SAVED SNAME
INPLOD:	0					; FLAG SAYING WE ARE IN MAPPUR

IFE ITS,[
MAPJFN: 0					; JFN OF <MUDSAV>SAV FILE
DIRCHN:	0					; JFN USED BY GETDIR
]

PURE

END


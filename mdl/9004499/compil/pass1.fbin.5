'<PCODE "2PASS1">

"	This file contains the first pass of the MUDDLE compiler.
The functions therein take a MUDDLE function and build a more detailed
model of it.  Each entity in the function is represented by an object
of type NODE.  The entire function is represented by the functions node
and it points to the rest of the nodes for the function." 

"	Nodes vary in complexity and size depending on what they represent.
A function or prog/repeat node is contains more information than a node
for a quoted object.  All nodes have some fields in common to allow
general programs to traverse the model." 

"	The model built by PASS1 is used by the analyzer (SYMANA), the
variable allocator (VARANA) and the code generator (CODGEN).  In some
cases the analyzers and generators for certain classes of SUBRs are 
together in their own files (e.g.  CARITH, STRUCT, ISTRUC)." 

"Type specification for NODE." 

<NEWTYPE NODE VECTOR '<VECTOR FIX ANY ANY ANY <LIST [REST NODE]> FIX <OR FALSE 
ATOM> [REST LIST ANY ANY LIST FIX SYMTAB FIX FIX <OR FALSE ATOM> ATOM ANY LIST 
LIST ANY ANY ANY ANY ANY ANY ANY <PRIMTYPE LIST> FIX FIX ANY LIST LIST LIST LIST
]>> 

"Offsets into pass 1 structure entities and functions to create same." 

<SETG NODE-TYPE 1> 

<SETG PARENT 2> 

<SETG RESULT-TYPE 3> 

<SETG NODE-NAME 4> 

<SETG KIDS 5> 

<SETG STACKS 6> 

<SETG SEGS 7> 

<SETG TYPE-INFO 8> 

<SETG SIDE-EFFECTS 9> 

<SETG RSUBR-DECLS 10> 

<SETG BINDING-STRUCTURE 11> 

<SETG SPECS-START 12> 

<SETG SYMTAB 13> 

<SETG SSLOTS 14> 

<SETG USLOTS 15> 

<SETG ACTIVATED 16> 

<SETG TMPLS 17> 

<SETG PRE-ALLOC 18> 

<SETG STK-B 19> 

<SETG BTP-B 20> 

<SETG SPCS-X 21> 

<SETG DST 22> 

<SETG CDST 23> 

<SETG ATAG 24> 

<SETG RTAG 25> 

<SETG ASSUM 26> 

<SETG AGND 27> 

<SETG ACS 28> 

<SETG TOTARGS 29> 

<SETG REQARGS 30> 

<SETG LOOP-VARS 31> 

"Variables kept in acs thru loop." 

<SETG AGAIN-STATES 32> 

"States at agains" 

<SETG RETURN-STATES 33> 

"States at repeats." 

<SETG PROG-VARS 34> 

"Vars handled in this prog/repeat." 

<SETG CLAUSES ,KIDS> 

<SETG NODE-SUBR ,RSUBR-DECLS> 

<SETG PREDIC ,NODE-NAME> 

<SETG ACCUM-TYPE ,DST> 

<SETG DEAD-VARS ,CDST> 

<SETG LIVE-VARS ,TYPE-INFO> 

<SETG VSPCD ,ATAG> 

<SETG INIT-DECL-TYPE ,RTAG> 

"Create a simple node (for quoted stuff etc.)" 

<SETG NODE1  %<RSUBR!- '[ %<PCODE!- "2PASS1" 0> NODE1 #DECL ("VALUE" NODE ANY 
ANY ANY ANY ANY) ARGCHK TYPE-OK? TYPE-AND GET-ELE-TYPE HACK-NAME ISTYPE-GOOD? 
TYPE-ATOM-OK? SRCH-SYM MESSAGE MAKE:TAG %<TYPE-W NODE VECTOR> "FRM" VARTBL T ANY
 %<TYPE-W SYMTAB VECTOR> (1 1) RESULT (NODE) %<RGLOC LVARTBL T> (SYMTAB) RQRG (
FIX) TRG ERROR " EMPTY FUNCTION " " NO ARG LIST " " NO BODY " IND VALUE "VALUE" 
DCL (<PRIMTYPE LIST>) ACS:TOP GLUE (() STACK) ACS:BOT (LIST) NACS RES:BOT ARGN 
BNDL:TOP BNDL:BOT MODE ["BIND" "CALL" "OPT" "OPTIONAL" "ARGS" "TUPLE" "AUX" 
"EXTRA" "ACT" "NAME"] (<VECTOR [REST STRING]>) DOIT %<RGLOC INIT-D T> (ANY) ATOM
 FORM LIST " TWO DECL STRINGS IN A ROW " " UNRECOGNIZED STRING IN DECL " ![1 2 1
2 1 2 1 2 1 1!] %<RGLOC DOITS T> "OPT" "OPTIONAL" " BAD THING IN DECL " 
"DECL LIST AT END OF DECL" SPECIAL UNSPECIAL %<TYPE-C SYMTAB VECTOR> %<RGLOC 
NORM-D T> " LIST NOT IN OPT OR AUX " "QUOTE" " BAD BIND " ENVIRONMENT %<RGLOC 
INIT1-D T> " BAD CALL " %<RGLOC ERR-D T> " BAD SYNTAX ARGLIST " 
"BAD USE OF OPTIONAL " " BAD ARGS " " BAD TUPLE " TUPLE " QUOTED AUX " 
" BAD ACTIVATION " ACTIVATION QUOTE " BAD FORM IN ARGLIST " 
" BAD LIST IN ARGLIST " %<RGLOC ALLACS T> %<TYPE-W AC VECTOR> GLOSP DECLS 
" BAD DECL LIST " ITUPLE PARENT PTHIS-OBJECT PTHIS-TYPE %<RGLOC PDEFAULT T> 
FALSE APPLY APPLICATION (ACTIVATION) PAPPLY-OBJECT PAPPLY-TYPE %<RGLOC PAPDEF T>
 WARNING " LOCAL VALUE USED FOR " REASONABLE DUMMY " NO VALUE FOR " "ERROR" %<
RGLOC MACROERR T> MACACT %<RGLOC MACACT T> %<TYPE-C FUNNY VECTOR> 
" MACRO EXPANSION LOSSAGE " %<TYPE-W FUNNY VECTOR> " " 
" FORM NOT BEING COMPILED " LVAL SET NOTE " REDCLARED SPECIAL " ![FORM LIST 
UVECTOR VECTOR!] " BAD APPLICATION OF A NUMBER " INTH IPUT %<RGLOC NTH T> %<
RGLOC PUT T> " EMPTY " " NO DODY FOR " "AUX" "WRONG # OF ARGS TO UNWIND " COND 
"BAD COND" %<RGLOC TYPE-INFO T> %<TYPE-W IRSUBR LIST> NAME OBJ RDCL %<RGLOC 
INIT-R T> SEGSW (1) RM ["VALUE" "CALL" "QUOTE" "OPTIONAL" "QUOTE" "ARGS" "TUPLE"
] KDS TKDS RSB "BAD STRING IN RSUBR DECL " %<RGLOC RDOIT T> %<RGLOC SDOIT T> ALL
 " TOO FEW ARGS TO " REST STRUCTURED "BAD ARG TO " " TOO MANY ARGS TO " 
" 2 STRINGS IN ROW IN DCL " %<RGLOC INIT1-R T> "BAD CALL TO " 
"BAD SEGMENT GOODIE. " %<RGLOC INIT2-R T> STRING INCONISTANCY 
"SHOULDN'T GET HERE " FCNS RSUB-DEC "UNCOMPILED FUNCTION CALLED " "ANONF" INT? (
<OR FALSE ATOM>) GROUP-NAME " COMPILING ANONYMOUS FUNCTION " %<RGLOC COMP2 T> 
" FINISHED ANONYMOUS FUNCTION " RSUBR FOO ILIST IVECTOR VECTOR ISTRING IUVECTOR 
UVECTOR IFORM IBYTES BYTES]>> 
<AND <ASSIGNED? GLUE> .GLUE <PUT ,NODE1 PGLUE ![715828223 -1 -1 -1 -1 -1 -1 -1 
-1 -1 -1073741824 0!]>> 


"Create a function node with all its hair." 

<SETG NODEF %<RSUBR-ENTRY '[NODE1 NODEF #DECL ("VALUE" NODE ANY ANY ANY ANY ANY 
ANY ANY ANY ANY ANY ANY ANY)] 36>> 

"Create a PROG/REPEAT node with nearly as much hair." 

<SETG NODEPR %<RSUBR-ENTRY '[NODE1 NODEPR #DECL ("VALUE" NODE ANY ANY ANY ANY 
ANY ANY ANY ANY ANY)] 135>> 

"Create a COND node." 

<SETG NODECOND %<RSUBR-ENTRY '[NODE1 NODECOND #DECL ("VALUE" NODE ANY ANY ANY 
ANY ANY)] 236>> 

"Create a node for a COND clause." 

<SETG NODEB %<RSUBR-ENTRY '[NODE1 NODEB #DECL ("VALUE" NODE ANY ANY ANY ANY ANY)
] 276>> 

"Create a node for a SUBR call etc." 

<SETG NODEFM %<RSUBR-ENTRY '[NODE1 NODEFM #DECL ("VALUE" NODE ANY ANY ANY ANY 
ANY ANY)] 316>> 

"	Definitions associated with compiler symbol tables." 

"Offsets for variable description blocks" 

<NEWTYPE SYMTAB VECTOR '<VECTOR <PRIMTYPE VECTOR> ATOM <OR FALSE ATOM> FIX <OR 
ATOM FIX> <OR FALSE ATOM> LIST ANY ANY FIX <OR FALSE NODE> <OR FALSE 'T> <OR 
FALSE DATUM LIST> <OR FALSE 'T> <OR FALSE 'T> LIST ANY ANY <OR FALSE FIX>>> 

<SETG NEXT-SYM 1> 

<SETG NAME-SYM 2> 

<SETG SPEC-SYM 3> 

<SETG CODE-SYM 4> 

<SETG ARGNUM-SYM 5> 

<SETG PURE-SYM 6> 

<SETG DECL-SYM 7> 

<SETG ADDR-SYM 8> 

<SETG INIT-SYM 9> 

<SETG FRMNO 10> 

<SETG RET-AGAIN-ONLY 11> 

<SETG ASS? 12> 

<SETG INACS 13> 

<SETG STORED 14> 

<SETG USED-AT-ALL 15> 

<SETG DEATH-LIST 16> 

<SETG CURRENT-TYPE 17> 

<SETG COMPOSIT-TYPE 18> 

<SETG USAGE-SYM 19> 

"How a variable is used in a loop." 

<SETG PROG-AC ,CURRENT-TYPE> 

<SETG NUM-SYM ,COMPOSIT-TYPE> 

<SETG POTLV ,USED-AT-ALL> 

"Slot used to store information for variables in loops." 

"Add a symbol to the symbol table" 

<SETG ADDVAR %<RSUBR-ENTRY '[NODE1 ADDVAR #DECL ("VALUE" SYMTAB ANY ANY ANY ANY 
ANY ANY ANY ANY)] 360>> 

"Offsets for Global symbol table" 

<SETG GNEXT-SYM 1> 

<SETG GNAME-SYM 2> 

<SETG GDECL-SYM 3> 

"Some specialized decl stuff." 

<SETG LVARTBL <PROG ((VARTBL [])) #DECL ((VARTBL) <SPECIAL ANY>) <ADDVAR OBLIST 
T -1 0 T '(<OR LIST OBLIST>) <> <>> <ADDVAR OUTCHAN T -1 0 T '(CHANNEL) <> <>> <
ADDVAR INCHAN T -1 0 T '(CHANNEL) <> <>> .VARTBL>> 

<PUT CHANNEL DECL '<CHANNEL FIX [11 ANY] [5 FIX]>> 

<PUT STRING DECL '<STRING [REST CHARACTER]>> 

<PUT OBLIST DECL '<UVECTOR [REST <LIST [REST <OR ATOM LINK>]>]>> 

"Codes for the node types in the tree built by pass1 and modified by
other passes." 

"Give symbolic codes arbitrary increasing values." 

<PROG ((N 1)) <SETG CODVEC <MAPF ,UVECTOR <FUNCTION (ATM) <SETG .ATM .N> <SET N 
<+ .N 1>> .ATM> ![FUNCTION-CODE QUOTE-CODE SEGMENT-CODE FORM-CODE PROG-CODE 
SUBR-CODE COND-CODE BRANCH-CODE RSUBR-CODE LVAL-CODE SET-CODE OR-CODE AND-CODE 
RETURN-CODE COPY-CODE GO-CODE AGAIN-CODE ARITH-CODE 0-TST-CODE NOT-CODE 1?-CODE 
TEST-CODE EQ-CODE TY?-CODE LNTH-CODE MT-CODE NTH-CODE REST-CODE PUT-CODE 
PUTR-CODE FLVAL-CODE FSET-CODE FGVAL-CODE FSETG-CODE MIN-MAX-CODE STACKFORM-CODE
CHTYPE-CODE ABS-CODE FIX-CODE FLOAT-CODE MOD-CODE ID-CODE ASSIGNED?-CODE 
ISTRUC-CODE ISTRUC2-CODE BITS-CODE BITL-CODE GETBITS-CODE PUTBITS-CODE MAP-CODE 
MFCN-CODE ISUBR-CODE READ-EOF-CODE READ-EOF2-CODE EOF-CODE GET-CODE GET2-CODE 
IPUT-CODE IREMAS-CODE IRSUBR-CODE MARGS-CODE MPSBR-CODE MAPLEAVE-CODE 
MAPRET-STOP-CODE UNWIND-CODE GVAL-CODE SETG-CODE SEG-CODE LENGTH?-CODE TAG-CODE 
MFIRST-CODE PRINT-CODE MEMQ-CODE FORM-F-CODE INFO-CODE OBLIST?-CODE AS-NXT-CODE 
AS-IT-IND-VAL-CODE ALL-REST-CODE CASE-CODE SUBSTRUC-CODE BACK-CODE TOP-CODE 
COPY-LIST-CODE PUT-SAME-CODE ROT-CODE LSH-CODE BIT-TEST-CODE SPARE1-CODE 
SPARE2-CODE SPARE3-CODE SPARE4-CODE!]>> <SETG COMP-TYPES .N>> 

"Build a dispatch table based on node types." 

<SETG DISPATCH %<RSUBR-ENTRY '[NODE1 DISPATCH #DECL ("VALUE" VECTOR ANY "TUPLE" 
<TUPLE [REST <LIST FIX ANY>]>)] 431>> 

<SETG PREDV <IUVECTOR ,COMP-TYPES 0>> 

<MAPF <> <FUNCTION (N) <PUT ,PREDV .N 1>> ![,0-TST-CODE ,1?-CODE ,NOT-CODE ,
TEST-CODE ,EQ-CODE ,TY?-CODE ,MT-CODE ,OR-CODE ,AND-CODE ,ASSIGNED?-CODE ,
ISUBR-CODE ,NTH-CODE ,MEMQ-CODE ,LENGTH?-CODE ,OBLIST?-CODE ,AS-NXT-CODE ,
COND-CODE ,BIT-TEST-CODE!]> 

"Predicate:  does this type have special predicate code?" 

"	This the top level program for PASS1.  It takes a function as
input and returns the data structure representing the model." 

<SETG PASS1 %<RSUBR-ENTRY '[NODE1 PASS1 #DECL ("VALUE" NODE FUNCTION "OPTIONAL" 
ANY ANY ANY)] 485>> 

"	This function (and others on this page) take an arg list and
decls and parses them producing 3 things.

	1) An RSUBR decl list.

	2) A machine readable binding specification.

	3) Possibly an AC call spec.

Atoms are also entered into the symbol table." 

<SETG GEN-D %<RSUBR-ENTRY '[NODE1 GEN-D #DECL ("VALUE" <LIST LIST LIST> LIST <
PRIMTYPE LIST> ANY "OPTIONAL" <PRIMTYPE LIST>)] 852>> 

"Vector of legal strings in decl list." 

<SETG TOT-MODES ["BIND" "CALL" "OPT" "OPTIONAL" "ARGS" "TUPLE" "AUX" "EXTRA" 
"ACT" "NAME"]> 

"Amount to rest off decl vector after each encounter." 

<SETG RESTS ![1 2 1 2 1 2 1 2 1 1!]> 

"This function used for normal args when \"BIND\" and \"CALL\" still possible." 

<SETG INIT-D %<RSUBR-ENTRY '[NODE1 INIT-D #DECL ("VALUE" FIX ANY ANY)] 1453>> 

"This function for normal args when \"CALL\" still possible." 

<SETG INIT1-D %<RSUBR-ENTRY '[NODE1 INIT1-D #DECL ("VALUE" FIX ANY ANY)] 1478>> 

"Handle a normal argument or quoted normal argument." 

<SETG NORM-D %<RSUBR-ENTRY '[NODE1 NORM-D #DECL ("VALUE" FIX ANY ATOM)] 1509>> 

"Handle \"BIND\" decl." 

<SETG BIND-D %<RSUBR-ENTRY '[NODE1 BIND-D #DECL ("VALUE" ANY ANY ATOM)] 1614>> 

"Handle \"CALL\" decl." 

<SETG CALL-D %<RSUBR-ENTRY '[NODE1 CALL-D #DECL ("VALUE" ANY ANY ATOM)] 1673>> 

"Flush on extra atoms after \"CALL\", \"ARGS\" etc." 

<SETG ERR-D %<RSUBR-ENTRY '[NODE1 ERR-D #DECL ("VALUE" ANY ANY ANY)] 1752>> 

"Handle \"OPTIONAL\" decl." 

<SETG OPT-D %<RSUBR-ENTRY '[NODE1 OPT-D #DECL ("VALUE" FIX ANY ATOM)] 1771>> 

"Handle \"ARGS\" decl." 

<SETG ARGS-D %<RSUBR-ENTRY '[NODE1 ARGS-D #DECL ("VALUE" FIX ANY ATOM)] 1970>> 

"Handle \"TUPLE\" decl." 

<SETG TUP-D %<RSUBR-ENTRY '[NODE1 TUP-D #DECL ("VALUE" ANY ANY ATOM)] 2055>> 

"Handle \"AUX\" decl." 

<SETG AUX-D %<RSUBR-ENTRY '[NODE1 AUX-D #DECL ("VALUE" ANY ANY ATOM)] 2140>> 

"Handle \"NAME\" and \"ACT\" decl." 

<SETG ACT-D %<RSUBR-ENTRY '[NODE1 ACT-D #DECL ("VALUE" ANY ANY ATOM)] 2226>> 

"Fixup activation atoms after node generated." 

<SETG ACT-FIX %<RSUBR-ENTRY '[NODE1 ACT-FIX #DECL ("VALUE" <OR ATOM FALSE> NODE 
<LIST [REST SYMTAB]>)] 2275>> 

"Table of varius decl handlers." 

<SETG DOITS ![,ACT-D ,ACT-D ,AUX-D ,AUX-D ,TUP-D ,ARGS-D ,OPT-D ,OPT-D ,CALL-D ,
BIND-D!]> 

"Check for quoted arguments." 

<SETG QUOTCH %<RSUBR-ENTRY '[NODE1 QUOTCH #DECL ("VALUE" ATOM FORM)] 2314>> 

"Chech for (arg init) or ('arg init)." 

<SETG LISTCH %<RSUBR-ENTRY '[NODE1 LISTCH #DECL ("VALUE" ANY LIST)] 2364>> 

"Add a decl to RSUBR decls and update AC call spec." 

<SETG PUT-RES %<RSUBR-ENTRY '[NODE1 PUT-RES #DECL ("VALUE" ATOM LIST)] 2418>> 

"Add code to set up a certain kind of argument." 

<SETG PUT-DCL %<RSUBR-ENTRY '[NODE1 PUT-DCL #DECL ("VALUE" ANY FIX ATOM ANY ANY 
ANY)] 2622>> 

"Find decl associated with a variable, if none, use ANY." 

<SETG FIND:DECL %<RSUBR-ENTRY '[NODE1 FIND:DECL #DECL ("VALUE" ANY ATOM 
"OPTIONAL" <PRIMTYPE LIST>)] 2769>> 

"Add an AUX variable spec to structure." 

<SETG PAUX %<RSUBR-ENTRY '[NODE1 PAUX #DECL ("VALUE" ANY ATOM ANY ANY FIX)] 2858
>> 

"Main dispatch function during pass1." 

<SETG PCOMP %<RSUBR-ENTRY '[NODE1 PCOMP #DECL ("VALUE" NODE ANY ANY)] 3075>> 

"Build a node for <> or #FALSE ()." 

<SETG FALSE-QT %<RSUBR-ENTRY '[NODE1 FALSE-QT #DECL ("VALUE" NODE ANY)] 3125>> 

<PUT '<> PTHIS-OBJECT ,FALSE-QT> 

"Build a node for ()." 

<SETG NIL-QT %<RSUBR-ENTRY '[NODE1 NIL-QT #DECL ("VALUE" NODE ANY)] 3151>> 

<PUT () PTHIS-OBJECT ,NIL-QT> 

"Build a node for a LIST, VECTOR or UVECTOR." 

<SETG PCOPY %<RSUBR-ENTRY '[NODE1 PCOPY #DECL ("VALUE" NODE ANY)] 3177>> 

<PUT VECTOR PTHIS-TYPE ,PCOPY> 

<PUT UVECTOR PTHIS-TYPE ,PCOPY> 

<PUT LIST PTHIS-TYPE ,PCOPY> 

"Build a node for unknown things." 

<SETG PDEFAULT %<RSUBR-ENTRY '[NODE1 PDEFAULT #DECL ("VALUE" NODE ANY)] 3263>> 

"Further analyze a FORM and build appropriate node." 

<SETG PFORM %<RSUBR-ENTRY '[NODE1 PFORM #DECL ("VALUE" NODE <FORM ANY>)] 3291>> 

<PUT FORM PTHIS-TYPE ,PFORM> 

"Build a SEGMENT node." 

<SETG SEG-FCN %<RSUBR-ENTRY '[NODE1 SEG-FCN #DECL ("VALUE" NODE ANY)] 3364>> 

<PUT SEGMENT PTHIS-TYPE ,SEG-FCN> 

"Analyze a form or the form <ATM .....>" 

<SETG ATOM-FCN %<RSUBR-ENTRY '[NODE1 ATOM-FCN #DECL ("VALUE" ANY ANY ATOM)] 3410
>> 

<PUT ATOM PAPPLY-TYPE ,ATOM-FCN> 

"Expand MACRO and process result." 

<SETG PMACRO %<RSUBR-ENTRY '[NODE1 PMACRO #DECL ("VALUE" ANY ANY ANY)] 3477>> 

<NEWTYPE FUNNY VECTOR> 

<PROG (X) <COND (<TYPE? ,VALRET SUBR> <SETG REAL-VALRET ,VALRET>) (<AND <
GASSIGNED? <SET X <PARSE "OVALRET!-COMBAT!-">>> <TYPE? ,.X SUBR>> <SETG 
REAL-VALRET ,.X>) (<NOT <GASSIGNED? REAL-VALRET>> <ERROR ',VALRET COMPILE>)>> 

<PUT MACRO PAPPLY-TYPE ,PMACRO> 

<SETG MACROERR %<RSUBR-ENTRY '[NODE1 MACROERR #DECL ("VALUE" ANY ANY "TUPLE" 
TUPLE)] 3563>> 

"Build a node for a form whose 1st element is a form (could be NTH)." 

<SETG PFORM-FORM %<RSUBR-ENTRY '[NODE1 PFORM-FORM #DECL ("VALUE" NODE FORM ANY)]
3599>> 

<PUT FORM PAPPLY-TYPE ,PFORM-FORM> 

"Build a node for strange forms." 

<SETG PAPDEF %<RSUBR-ENTRY '[NODE1 PAPDEF #DECL ("VALUE" NODE ANY ANY)] 3701>> 

"For objects that require EVAL, make sure all atoms used are special." 

<SETG SPECIALIZE %<RSUBR-ENTRY '[NODE1 SPECIALIZE #DECL ("VALUE" ANY ANY)] 3741>
> 

"Build a SUBR call node." 

<SETG PSUBR-C %<RSUBR-ENTRY '[NODE1 PSUBR-C #DECL ("VALUE" NODE FORM ANY)] 3904>
> 

<PUT SUBR PAPPLY-TYPE ,PSUBR-C> 

<FLOAD "SBRNAM" "NBIN" "DSK" "COMPIL"> 

<SETG SUBR-NAME %<RSUBR-ENTRY '[NODE1 SUBR-NAME #DECL ("VALUE" ANY ANY ANY)] 
4003>> 

"Application of a FIX." 

<SETG FIX-FCN %<RSUBR-ENTRY '[NODE1 FIX-FCN #DECL ("VALUE" NODE FORM ANY)] 4037>
> 

<PUT FIX PAPPLY-TYPE ,FIX-FCN> 

<PUT OFFSET PAPPLY-TYPE ,FIX-FCN> 

"PROG/REPEAT node." 

<SETG PPROG-REPEAT %<RSUBR-ENTRY '[NODE1 PPROG-REPEAT #DECL ("VALUE" NODE <
PRIMTYPE LIST> ANY)] 4173>> 

<PUT ,PROG PAPPLY-OBJECT ,PPROG-REPEAT> 

<PUT ,REPEAT PAPPLY-OBJECT ,PPROG-REPEAT> 

<PUT ,BIND PAPPLY-OBJECT ,PPROG-REPEAT> 

"Unwind compiler." 

<SETG UNWIND-FCN %<RSUBR-ENTRY '[NODE1 UNWIND-FCN #DECL ("VALUE" NODE FORM ANY)]
4390>> 

<PUT ,UNWIND PAPPLY-OBJECT ,UNWIND-FCN> 

"Build a node for a COND." 

<SETG COND-FCN %<RSUBR-ENTRY '[NODE1 COND-FCN #DECL ("VALUE" NODE <FORM ANY> ANY
)] 4491>> 

<PUT ,COND PAPPLY-OBJECT ,COND-FCN> 

<PUT ,AND PAPPLY-OBJECT <GET SUBR PAPPLY-TYPE>> 

<PUT ,OR PAPPLY-OBJECT <GET SUBR PAPPLY-TYPE>> 

<PUT ,STACKFORM PAPPLY-OBJECT <GET SUBR PAPPLY-TYPE>> 

"Build a node for '<-object>-." 

<SETG QUOTE-FCN %<RSUBR-ENTRY '[NODE1 QUOTE-FCN #DECL ("VALUE" <OR FALSE NODE> 
FORM ANY)] 4675>> 

<PUT ,QUOTE PAPPLY-OBJECT ,QUOTE-FCN> 

"Build a node for a call to an RSUBR." 

<SETG RSUBR-FCN %<RSUBR-ENTRY '[NODE1 RSUBR-FCN #DECL ("VALUE" NODE FORM <OR 
RSUBR-ENTRY RSUBR>)] 4735>> 

<PUT RSUBR PAPPLY-TYPE ,RSUBR-FCN> 

<PUT RSUBR-ENTRY PAPPLY-TYPE <GET RSUBR PAPPLY-TYPE>> 

<SETG INTERNAL-RSUBR-FCN %<RSUBR-ENTRY '[NODE1 INTERNAL-RSUBR-FCN #DECL ("VALUE"
NODE FORM IRSUBR)] 4871>> 

<PUT IRSUBR PAPPLY-TYPE ,INTERNAL-RSUBR-FCN> 

"Predicate:  any segments in this object?" 

<SETG SEG? %<RSUBR-ENTRY '[NODE1 SEG? #DECL ("VALUE" <OR ATOM FALSE> <PRIMTYPE 
LIST>)] 4993>> 

"Analyze a call to an RSUBR with decls checking number of args and types wherever
 possible." 

<SETG PRSUBR-C %<RSUBR-ENTRY '[NODE1 PRSUBR-C #DECL ("VALUE" ANY ANY <PRIMTYPE 
LIST> <PRIMTYPE LIST>)] 5028>> 

<SETG SQUOT %<RSUBR-ENTRY '[NODE1 SQUOT #DECL ("VALUE" ATOM ANY)] 5596>> 

"Flush one possible decl away." 

<SETG CHOPPER %<RSUBR-ENTRY '[NODE1 CHOPPER #DECL ("VALUE" ATOM ANY)] 5608>> 

"Handle Normal arg when \"VALUE\" still possible." 

<SETG INIT-R %<RSUBR-ENTRY '[NODE1 INIT-R #DECL ("VALUE" NODE ANY ANY)] 5637>> 

"Handle Normal arg when \"CALL\" still possible." 

<SETG INIT2-R %<RSUBR-ENTRY '[NODE1 INIT2-R #DECL ("VALUE" NODE ANY ANY)] 5669>> 

"Handle normal arg." 

<SETG INIT1-R %<RSUBR-ENTRY '[NODE1 INIT1-R #DECL ("VALUE" NODE ANY LIST)] 5702>
> 

"Handle \"QUOTE\" arg." 

<SETG QINIT-R %<RSUBR-ENTRY '[NODE1 QINIT-R #DECL ("VALUE" NODE ANY LIST)] 5760>
> 

"Handle \"CALL\" decl." 

<SETG CAL-R %<RSUBR-ENTRY '[NODE1 CAL-R #DECL ("VALUE" ANY ANY ANY)] 5829>> 

"Handle \"ARGS\" decl." 

<SETG ARGS-R %<RSUBR-ENTRY '[NODE1 ARGS-R #DECL ("VALUE" ANY ANY ANY)] 5902>> 

"Handle \"TUPLE\" decl." 

<SETG TUPL-R %<RSUBR-ENTRY '[NODE1 TUPL-R #DECL ("VALUE" NODE ANY LIST)] 5971>> 

"Handle stuff with segments in arguments." 

<SETG SEGCHK %<RSUBR-ENTRY '[NODE1 SEGCHK #DECL ("VALUE" NODE ANY)] 6029>> 

<SETG SEGCH1 %<RSUBR-ENTRY '[NODE1 SEGCH1 #DECL ("VALUE" ANY ANY ANY ANY)] 6068>
> 

"Handle \"VALUE\" chop decl and do the rest." 

<SETG VAL-R %<RSUBR-ENTRY '[NODE1 VAL-R #DECL ("VALUE" <OR ATOM FALSE> ANY)] 
6114>> 

<SETG ERR-R %<RSUBR-ENTRY '[NODE1 ERR-R #DECL ("VALUE" ANY ANY ANY)] 6178>> 

<SETG RMODES ["VALUE" "CALL" "QUOTE" "OPTIONAL" "QUOTE" "ARGS" "TUPLE"]> 

<SETG RDOIT ![,TUPL-R ,ARGS-R ,QINIT-R ,INIT1-R ,QINIT-R ,CAL-R ,ERR-R!]> 

<SETG SDOIT ![,CHOPPER ,CHOPPER ,SQUOT ,CHOPPER ,SQUOT ,CHOPPER ,VAL-R!]> 

"Create a node for a call to a function." 

<SETG PFUNC %<RSUBR-ENTRY '[NODE1 PFUNC #DECL ("VALUE" <OR FALSE NODE> <PRIMTYPE
LIST> ANY)] 6195>> 

"Call compiler recursively to compile anonymous function." 

<SETG ANONF %<RSUBR-ENTRY '[NODE1 ANONF #DECL ("VALUE" NODE ANY ANY)] 6350>> 

"#FUNCTION (....) compiler -- call ANONF." 

<SETG FCN-FCN %<RSUBR-ENTRY '[NODE1 FCN-FCN #DECL ("VALUE" NODE ANY)] 6427>> 

<PUT FUNCTION PTHIS-TYPE ,FCN-FCN> 

<PUT FUNCTION PAPPLY-TYPE ,PFUNC> 

"<FUNCTION (..) ....> compiler -- call ANONF." 

<SETG FCN-FCN1 %<RSUBR-ENTRY '[NODE1 FCN-FCN1 #DECL ("VALUE" NODE <PRIMTYPE LIST
> ANY)] 6448>> 

<PUT ,FUNCTION PAPPLY-OBJECT ,FCN-FCN1> 

"Handle RSUBR that is really a function." 

<SETG RSUBR-CALL2 %<RSUBR-ENTRY '[NODE1 RSUBR-CALL2 #DECL ("VALUE" NODE ANY ANY 
ANY)] 6474>> 

"Handle an RSUBR that is already an RSUBR." 

<SETG RSUBR-CALL1 %<RSUBR-ENTRY '[NODE1 RSUBR-CALL1 #DECL ("VALUE" NODE <
PRIMTYPE LIST> ANY ANY)] 6596>> 

<SETG RSUBR-CALL3 %<RSUBR-ENTRY '[NODE1 RSUBR-CALL3 #DECL ("VALUE" NODE ANY ANY 
ANY)] 6712>> 

<SETG PLIST %<RSUBR-ENTRY '[NODE1 PLIST #DECL ("VALUE" NODE ANY ANY)] 6822>> 

<PUT ,ILIST PAPPLY-OBJECT ,PLIST> 

<SETG PIVECTOR %<RSUBR-ENTRY '[NODE1 PIVECTOR #DECL ("VALUE" NODE ANY ANY)] 6844
>> 

<PUT ,IVECTOR PAPPLY-OBJECT ,PIVECTOR> 

<SETG PISTRING %<RSUBR-ENTRY '[NODE1 PISTRING #DECL ("VALUE" NODE ANY ANY)] 6866
>> 

<PUT ,ISTRING PAPPLY-OBJECT ,PISTRING> 

<SETG PIUVECTOR %<RSUBR-ENTRY '[NODE1 PIUVECTOR #DECL ("VALUE" NODE ANY ANY)] 
6888>> 

<PUT ,IUVECTOR PAPPLY-OBJECT ,PIUVECTOR> 

<SETG PIFORM %<RSUBR-ENTRY '[NODE1 PIFORM #DECL ("VALUE" NODE ANY ANY)] 6910>> 

<PUT ,IFORM PAPPLY-OBJECT ,PIFORM> 

<SETG PIBYTES %<RSUBR-ENTRY '[NODE1 PIBYTES #DECL ("VALUE" NODE ANY ANY)] 6932>> 

<PUT ,IBYTES PAPPLY-OBJECT ,PIBYTES> 

<SETG PSTRUC %<RSUBR-ENTRY '[NODE1 PSTRUC #DECL ("VALUE" NODE <PRIMTYPE LIST> 
ANY ANY ANY)] 6954>> 

"READ, READCHR, READSTRING, NEXTCHR, READB, GET, GETL, GETPROP, GETPL" 

<PUT ,READ PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A READ 2 ANY>>> 

<PUT ,GC-READ PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A GC-READ 2 ANY>>> 

<PUT ,READCHR PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A READCHR 2 ANY>>> 

<PUT ,NEXTCHR PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A NEXTCHR 2 ANY>>> 

<PUT ,READB PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A READB 3 ANY>>> 

<PUT ,READSTRING PAPPLY-OBJECT <FUNCTION (O A) <CHANFCNS .O .A READSTRING 4 ANY>
>> 

<SETG CHANFCNS %<RSUBR-ENTRY '[NODE1 CHANFCNS #DECL ("VALUE" NODE <PRIMTYPE LIST
> ANY ANY FIX ANY)] 7173>> 

<PUT ,GET PAPPLY-OBJECT <FUNCTION (O A) <GETFCNS .O .A GET>>> 

<PUT ,GETL PAPPLY-OBJECT <FUNCTION (O A) <GETFCNS .O .A GETL>>> 

<PUT ,GETPROP PAPPLY-OBJECT <FUNCTION (O A) <GETFCNS .O .A GETPROP>>> 

<PUT ,GETPL PAPPLY-OBJECT <FUNCTION (O A) <GETFCNS .O .A GETPL>>> 

<SETG GETFCNS %<RSUBR-ENTRY '[NODE1 GETFCNS #DECL ("VALUE" NODE FORM ANY ANY)] 
7317>> 

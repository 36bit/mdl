<PACKAGE "LOOP">

<USE "FMACRO">

;"New Version 4/10/81"
;"Bugs, comments, gripes to MARKT"


<RENTRY ON DO IF TO>

<ENTRY  LOOP                	;"FUNCTIONS AND MACROS"
	LOOP-EXPAND 
	DEFINE-LOOP-GENERATOR
	LOOP-MEMO
	LOOP-DECLARE	        ;"FOR USE IN DEFINE-LOOP-PATH"
	LOOP-CREATE-VARIABLE
	LOOP-SOURCE-CODE
	LSCPOP
	LOOP-IN-PATH            ;"SIMPLE PATHS"
	LOOP-ON-PATH
	LOOP-ARITHMETIC-PATH
	INITIALLY 	        ;"KEYWORDS"
	FINALLY 
	COLLECT 
	COUNT 
	MAXIMIZE 
	MINIMIZE 
	SUM
	WHEN 
	UNLESS 
	WITH 
	ALWAYS 
	NEVER 
	FINISH 
	NAMED 
	THEREIS 
	WHILE 
	UNTIL 
	AS 
	FOR 
	= 
	BEING 
	FROM 
	DOWNFROM 
	UPFROM 
	INTO 
	AS-A
	ABOVE 
	BELOW
	BY 
	THE
	APPLYING
	STEP
	DOWNTO
	ITS
	HIS
	HER
	THEIR
	EACH
	OF
	THEN>

<SETG ILOOP-OBLIST <1 .OBLIST>>

<SETG LOOP-REGISTERS '![LOOP-PROLOGUE 
			LOOP-BODY 
			LOOP-EPILOGUE
			LOOP-PRE-EPILOGUE
			LOOP-AFTER-EPILOGUE 
			LOOP-CONDITIONALS 
			LOOP-AFTER-BODY 
			LOOP-DECLARATIONS
			LOOP-ILIST 
			LOOP-SET-LIST 
			LOOP-TESTS 
			LOOP-POSTTESTS
			LOOP-COLLECT-VARS 
			LOOP-SOURCE-CODE]>


<GDECL (LOOP-NAME) <OR ATOM FALSE>
       (RETVAR) ATOM
       (LOOP-PROLOGUE LOOP-BODY LOOP-EPILOGUE
	LOOP-PRE-EPILOGUE
	LOOP-AFTER-EPILOGUE LOOP-CONDITIONALS 
	LOOP-AFTER-BODY LOOP-DECLARATIONS
	LOOP-ILIST LOOP-SET-LIST LOOP-TESTS 
	LOOP-COLLECT-VARS LOOP-SOURCE-CODE)  LIST>


<SETG LOOP-KEYWORDS
     '![(INITIALLY LOOP-DO-INITIALLY)
	(FINALLY LOOP-DO-FINALLY)
	(DO LOOP-DO-DO)
	(COLLECT LOOP-DO-COLLECT LIST)
	(COUNT LOOP-DO-COLLECT COUNT)
	(MAXIMIZE LOOP-DO-COLLECT MAX)
	(MINIMIZE LOOP-DO-COLLECT MIN)
	(SUM LOOP-DO-COLLECT SUM)
	(WHEN LOOP-DO-WHEN #FALSE ())
	(IF LOOP-DO-WHEN #FALSE ())
	(UNLESS LOOP-DO-WHEN T)
	(WITH LOOP-DO-WITH)
	(ALWAYS LOOP-DO-ALWAYS T)
	(NEVER LOOP-DO-ALWAYS #FALSE ())
	(RETURN LOOP-DO-RETURN)
	(FINISH LOOP-DO-FINISH)
	(NAMED LOOP-DO-NAMED)
	(THEREIS LOOP-DO-THEREIS)
	(WHILE LOOP-DO-WHILE T)
	(UNTIL LOOP-DO-WHILE #FALSE ())
	(AS LOOP-DO-FOR)
	(FOR LOOP-DO-FOR)]>

<SETG LOOP-FOR-KEYWORDS 
     '![(= LOOP-FOR-EQUALS)
	(BEING LOOP-FOR-BEING)
	(FROM LOOP-FOR-ARITHMETIC #FALSE ())
	(DOWNFROM LOOP-FOR-ARITHMETIC DOWN)
	(UPFROM LOOP-FOR-ARITHMETIC UP)
	(IN LOOP-FOR-IN)
	(ON LOOP-FOR-ON)]>



<SETG LOOP-PATH-KEYWORDS '()>

<SETG LOOP-GENERATION-NUMBER 0>

<SETG LOOP-PATHS '()>

<GDECL (LOOP-GENERATION-NUMBER) FIX 
       (LOOP-REGISTERS) <UVECTOR [REST ATOM]>
       (LOOP-PATHS LOOP-PATH-KEYWORDS) LIST 
       (LOOP-KEYWORDS LOOP-FOR-KEYWORDS) <UVECTOR [REST LIST]>>


<DEFINE LOOP-LOOKUP-KEYWORD (WORD KWLIST)
	#DECL ((KWLIST) UVECTOR)
	<COND (<==? <TYPE .WORD> ATOM>
	       <MAPF <> <FUNCTION (L) <COND (<=? .WORD  <1 .L>>
					     <MAPLEAVE .L>)>>
		     .KWLIST>)>>


<DEFINE LOOP-LOOKUP-PATH (WORD)
	<COND (<==? <TYPE .WORD> ATOM>
	       <MAPF <> <FUNCTION (L) <COND (<MEMQ .WORD <1 .L>>
					     <MAPLEAVE .L>)>>
		     ,LOOP-PATHS>)>>


<DEFMAC LOOP ("ARGS" TEM-LOOP-SOURCE-CODE "AUX" (REDEFINE T))
	#DECL ((TEM-LOOP-SOURCE-CODE) LIST)
	<SETG LOOP-NAME <>>
	<SETG LAST-COLLECT-1 <>>
	<SETG RETVAR <LOOP-CREATE-VARIABLE>>
	<MAPF <> #FUNCTION ((AT) #DECL ((AT) ATOM)
				 <SETG .AT '()>)
		 ,LOOP-REGISTERS>
	<SETG LOOP-SOURCE-CODE .TEM-LOOP-SOURCE-CODE>
	<REPEAT (KEYWORD TEM TESTRETURN)
		<COND (<EMPTY? ,LOOP-SOURCE-CODE>
		       <RETURN 
			<FORM BIND ,LOOP-ILIST
				  !<AND <NOT <EMPTY? ,LOOP-DECLARATIONS>>
				  (<CHTYPE ,LOOP-DECLARATIONS DECL>)>
				      !<LREVERSE ,LOOP-SET-LIST>
					!<LREVERSE ,LOOP-PROLOGUE>
			    <FORM REPEAT !<AND ,LOOP-NAME (,LOOP-NAME)>
				  ((,RETVAR <>))
				  <CHTYPE ((,RETVAR) '<OR ATOM FALSE>) DECL>
				      !<LREVERSE ,LOOP-TESTS>
				      !<AND <NOT <EMPTY? ,LOOP-TESTS>>
					    <SET TESTRETURN 
				            (<FORM COND (<FORM LVAL ,RETVAR>
				          !<LREVERSE ,LOOP-PRE-EPILOGUE>
					  !<LREVERSE ,LOOP-EPILOGUE>
					  !<COND (<EMPTY? ,LOOP-AFTER-EPILOGUE>
						  '(<RETURN>))
					 (ELSE ,LOOP-AFTER-EPILOGUE)>)>)>>
				      !<LREVERSE ,LOOP-BODY>
				      !<LREVERSE ,LOOP-POSTTESTS>
				      !<AND <NOT <EMPTY? ,LOOP-POSTTESTS>>
					    <COND (<ASSIGNED? TESTRETURN>
						   .TESTRETURN)
				
					          (ELSE (<FORM COND (<FORM LVAL ,RETVAR>
	!<LREVERSE ,LOOP-PRE-EPILOGUE>
	!<LREVERSE ,LOOP-EPILOGUE>
	!<COND (<EMPTY? ,LOOP-AFTER-EPILOGUE>
'(<RETURN>))
(ELSE ,LOOP-AFTER-EPILOGUE)>)>))>>
				      !<LREVERSE ,LOOP-AFTER-BODY>>>>)
		      (<NOT <==? <TYPE <SET KEYWORD <LSCPOP>>> ATOM>>
		       <ERROR NON-ATOM-WHERE-KEYWORD-EXPECTED!-ERRORS
			      .KEYWORD>)
		      (<SET TEM <LOOP-LOOKUP-KEYWORD .KEYWORD ,LOOP-KEYWORDS>>
		       <APPLY ,<2 .TEM> !<REST .TEM 2>>)
		      (ELSE <ERROR UNKNOWN-LOOP-KEYWORD!-ERRORS .KEYWORD>)>>>


<DEFINE LOOP-EMIT-BODY (FORML PLACE "AUX" (REDEFINE T))
	#DECL ((PLACE) ATOM)
	<SETG .PLACE (<CHECKC .FORML> !,.PLACE)>>


<DEFINE LOOP-GET-FORM ("AUX" (REDEFINE T))
	<REPEAT ((FORMS '())
		 (NEXTFORM <LSCFIRST>))
		#DECL ((FORMS) LIST)
		<COND (<OR <EMPTY? ,LOOP-SOURCE-CODE>
			   <==? <TYPE .NEXTFORM> ATOM>>
		       <RETURN <COND (<EMPTY? .FORMS> <FORM>)
				     (<EMPTY? <REST .FORMS>> <1 .FORMS>)
			     (ELSE <FORM BIND '() !<LREVERSE .FORMS>>)>>)>
		<SET FORMS (<LSCPOP> !.FORMS)>
		<SET NEXTFORM <LSCFIRST>>>>


<DEFINE LOOP-DO-INITIALLY ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-PROLOGUE>>

<DEFINE LOOP-DO-DO ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-BODY>>

<DEFINE LOOP-DO-FINALLY ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-EPILOGUE>>


<DEFMAC LPOP (LNAME)
	#DECL ((LNAME) ATOM)
	<FORM BIND ((TMP <FORM 1 <FORM LVAL .LNAME>>))
	      <FORM SET .LNAME 
		    <FORM REST <FORM LVAL .LNAME>>>
	      '.TMP>>


<DEFMAC LSCPOP ()
	'<BIND ((TMP <1 ,LOOP-SOURCE-CODE>))
		<SETG LOOP-SOURCE-CODE <REST ,LOOP-SOURCE-CODE>>
		.TMP>>


<DEFINE LOOP-DO-FOR ("AUX" (REDEFINE T))
	<OR <EMPTY? ,LOOP-CONDITIONALS>
	    <ERROR FOR/AS-STARTING-INSIDE-OF-CONDITIONAL!-ERRORS>>
	<REPEAT (VAR
		 DATA-TYPE
		 KEYWORD
		 TEM
		 (TESTS '()) (IVINITS '()) (POSTTESTS '())
		 (INITS '()) (SETS '()) (STEPS '()))
		#DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FORM FALSE>
                      (TESTS POSTTESTS) <LIST [REST FORM]>
		      (IVINITS INITS STEPS SETS) <LIST [REST LIST]>)
		<CHECK-END>
		<SET VAR <LSCPOP>>
		<SET DATA-TYPE <LOOP-OPTIONAL-TYPE>>
		<CHECK-END>
		<SET KEYWORD <LSCPOP>>
		<OR <SET TEM <LOOP-LOOKUP-KEYWORD
				    .KEYWORD
				    ,LOOP-FOR-KEYWORDS>>
		     <ERROR UNKNOWN-KEYWORD-IN-FOR-OR-AS-CLAUSE!-ERRORS
			    .KEYWORD>>
		<CHECK-END>
		<SET TEM <APPLY ,<NTH .TEM 2> .VAR <LSCPOP> .DATA-TYPE 
				!<REST .TEM 2>>>
		<OR <EMPTY? <1 .TEM>>
		    <SET TESTS (<1 .TEM> !.TESTS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET POSTTESTS (<1 .TEM> !.POSTTESTS)>>
		<SET INITS (!<1 <SET TEM <REST .TEM>>> !.INITS)>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET IVINITS (<1 .TEM> !.IVINITS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		<SET SETS (<1 .TEM> !.SETS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		<SET STEPS (<1 .TEM> !.STEPS)>>
		<COND (<N==? <LSCFIRST>  AND>
		       <OR <EMPTY? .TESTS>
			   <SETG LOOP-TESTS (<FORM 'AND 
		        <COND (<EMPTY? <REST .TESTS>> <1 .TESTS>)
			      (ELSE <FORM OR !.TESTS>)> 
			   <FORM SET ,RETVAR T>>
		                         !,LOOP-TESTS)>>

		       <OR <EMPTY? .POSTTESTS>
			   <SETG LOOP-POSTTESTS (<FORM 'AND
			<COND (<EMPTY? <REST .POSTTESTS>> <1 .POSTTESTS>)
				(ELSE <FORM OR !.TESTS>)>
			<FORM SET ,RETVAR T>>
						 !,LOOP-TESTS)>>
	       <OR <EMPTY? .SETS>
	           <SETG LOOP-BODY (<LOOP-PSET .SETS> !,LOOP-BODY)>>

	       <OR <EMPTY? .STEPS>
                 <SETG LOOP-AFTER-BODY (<LOOP-PSET .STEPS> !,LOOP-AFTER-BODY)>>


	       <COND (<NOT <EMPTY? .INITS>>
		      <MAPF <> #FUNCTION ((V) <OR <MEMQ <1 .V> ,LOOP-ILIST>
						  <SETG LOOP-ILIST 
						       (<1 .V> !,LOOP-ILIST)>>)
			    .INITS>
		   <SETG LOOP-SET-LIST (<LOOP-PSET .INITS>
				    !,LOOP-SET-LIST)>)>
		       
	       <COND (<NOT <EMPTY? .IVINITS>> 
                      <MAPF <> #FUNCTION ((V) <OR <MEMQ <1 .V> ,LOOP-ILIST>
                                                  <SETG LOOP-ILIST
                                                    (<1 .V> !,LOOP-ILIST)>>)
                            .IVINITS>
		   <SETG LOOP-SET-LIST (<LOOP-PSET .IVINITS>
				    !,LOOP-SET-LIST)>)>
	       
	       <RETURN <>>)
	      (ELSE <CHECK-END> <LSCPOP>)>>>
		     

<DEFINE LOOP-OPTIONAL-TYPE ("AUX" (REDEFINE T) 
				  (TOKEN <LSCFIRST>) 
				  (TY <TYPE .TOKEN>))
	<COND (<==? .TY FORM> <LSCPOP>)
	      (<==? .TY LIST> <1 <LSCPOP>>)>>
	    


<DEFINE LOOP-FOR-EQUALS (VAR VAL DATA-TYPE "AUX" (REDEFINE T)
			     (NEXTVAL <COND (<==? <LSCFIRST> THEN>
					     <CHECK-END>
					     <LSCPOP> <LSCPOP>)
					    (ELSE .VAL)>))
        #DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FORM FALSE>)
	<AND .DATA-TYPE
	     <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE !,LOOP-DECLARATIONS)>>
	( <> <> <> (.VAR .VAL) <> (.VAR .NEXTVAL))>


<DEFINE LOOP-FOR-ON (VAR VAL DATA-TYPE "AUX" (REDEFINE T)
			 (VAR1 <LOOP-CREATE-VARIABLE>)
			 (SDTYPE <LOOP-OPTIONAL-TYPE>)
		         (STEP <COND (<==? <LSCFIRST> BY>
				      <LSCPOP> <CHECK-END> <LSCPOP>)
				     (ELSE REST)>))
	#DECL ((VAR) ATOM (DATA-TYPE SDTYPE) <OR FORM FALSE ATOM>
	       (VAR1) ATOM)
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE 
						!,LOOP-DECLARATIONS)>>
	<AND .SDTYPE <SETG LOOP-DECLARATIONS ((.VAR1) .SDTYPE
					     !,LOOP-DECLARATIONS)>>
	 (<FORM EMPTY? <FORM LVAL .VAR1>>
	 <>
	 ((.VAR1 .VAL))
         (.VAR <FORM LVAL .VAR1>)
	 (.VAR <FORM LVAL .VAR1>)
	 (.VAR1 <FORM .STEP <FORM LVAL .VAR1>>))>


<DEFINE LOOP-FOR-IN (VAR VAL DATA-TYPE "AUX" (REDEFINE T)
			 (VAR1 <LOOP-CREATE-VARIABLE>)
			 (SDTYPE <LOOP-OPTIONAL-TYPE>)
			 (STEP <COND (<==? <LSCFIRST> BY>
				      <LSCPOP> 
				      <CHECK-END>
				      <LSCPOP>)
				     (ELSE REST)>)
			 (APPLYING <COND (<==? <LSCFIRST> APPLYING>
					<LSCPOP>
					<CHECK-END>
 					<LSCPOP>)
				       (ELSE 1)>))
	#DECL ((VAR) ATOM (DATA-TYPE SDTYPE) <OR FORM FALSE ATOM>
	       (VAR1) ATOM)
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE
						!,LOOP-DECLARATIONS)>>
	<AND .SDTYPE <SETG LOOP-DECLARATIONS ((.VAR1) .SDTYPE
					     !,LOOP-DECLARATIONS)>>
	(<FORM EMPTY? <FORM LVAL .VAR1>>
	 <>
	 ((.VAR1 .VAL))
	 (.VAR <FORM OR <FORM EMPTY? <FORM LVAL .VAR1>>
		         <FORM .APPLYING <FORM LVAL .VAR1>>>)
	 (.VAR <FORM .APPLYING  <FORM LVAL .VAR1>>)
	 (.VAR1 <FORM .STEP <FORM LVAL .VAR1>>))>

<DEFINE LOOP-IN-PATH (PRNAME VAR DTYPE PPS INC? APPS "TUPLE" DATA 
						     "AUX" A)
	<SET A <1 .PPS>>
	<SET PPS <REST .PPS>>
	<SET A <2 .A>>
	<COND (.INC? <SET A <CONS .A .A>>)>
	<SET PPS <REPEAT ((L .PPS)  (M ())) 
			 <COND (<EMPTY? .L> <RETURN .M>)>
			 <SET M (!<1 .L> !.M)>
			 <SET L <REST .L>>>>
	<SETG LOOP-SOURCE-CODE (!.PPS !,LOOP-SOURCE-CODE)>
	(<> !<LOOP-FOR-IN .VAR .A .DTYPE>)>



<DEFMAC LSCFIRST ()
	'<AND <NOT <EMPTY? ,LOOP-SOURCE-CODE>>
	      <1 ,LOOP-SOURCE-CODE>>>


<DEFINE LOOP-CREATE-VARIABLE ("AUX" (REDEFINE T) SYMBOL)
	<SET SYMBOL <STRING "G" <UNPARSE 
			       <- <SETG LOOP-GENERATION-NUMBER 
					<+ 1 ,LOOP-GENERATION-NUMBER>> 1>>>
		>
	<OR <LOOKUP .SYMBOL ,ILOOP-OBLIST>
	    <INSERT .SYMBOL ,ILOOP-OBLIST>>>


<DEFINE LOOP-FOR-ARITHMETIC (VAR VAL DATA-TYPE FORCED-DIRECTION "AUX"
		 (REDEFINE T)
		 (HOWTO <AND <MEMQ <LSCFIRST> '![TO BELOW DOWNTO ABOVE]>
				 <LSCPOP>>)
		 (LIMIT <AND .HOWTO <NOT <CHECK-END>> <LSCPOP>>)
		 (DIRECTION <COND (<OR <==? .HOWTO TO>
				       <==? .HOWTO BELOW>> UP)
				  (<OR <==? .HOWTO DOWNTO>
				       <==? .HOWTO ABOVE>> DOWN)
				  (<NOT <STRUCTURED? .FORCED-DIRECTION>>
				   .FORCED-DIRECTION)
				  (ELSE UP)>)
		 (EXCLUSIVE <COND (<OR <==? .HOWTO ABOVE>
				       <==? .HOWTO BELOW>> T)>)
		 (STEP <>)
		 TEM)
	#DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FALSE FORM> 
	       (FORCED-DIRECTION DIRECTION HOWTO EXCLUSIVE) <OR ATOM FALSE>)
	<AND .FORCED-DIRECTION
	     <N==? .FORCED-DIRECTION .DIRECTION>
	     <ERROR STEPPING-IN-TWO-DIRECTIONS!-ERRORS .VAR>>
	<SET TEM <LSCFIRST>>
	<SET STEP <COND 
		   (<==? .TEM BY>
		    <LSCPOP> <CHECK-END> 
		    <FORM APPLY <LSCPOP> <FORM LVAL .VAR>>)
		   (ELSE <FORM + <FORM LVAL .VAR>
			       <COND (<==? .TEM STEP>
				      <LSCPOP>
				      <CHECK-END>
 				      <LSCPOP>)
				     (ELSE 1)>>)>>
	<AND <OR <==? <SET TEM <LSCFIRST>> BY>
		 <==? .TEM STEP>>
	     <ERROR CONFLICTING-STEP-KEYWORD-IN-FOR-CLAUSE!-ERRORS .TEM>>
	<COND (<NOT .LIMIT> <SET TEM <>>)
	      (ELSE <SET TEM  <FORM <COND (<==? .DIRECTION UP> G?)
					   (ELSE L?)> <FORM LVAL .VAR> .LIMIT>>
		    <AND .EXCLUSIVE 
			 <SET TEM <FORM OR <FORM ==? <FORM LVAL .VAR> .LIMIT>
					.TEM>>>)>
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE
						!,LOOP-DECLARATIONS)>>

       (.TEM <> <> (.VAR .VAL) <> (.VAR .STEP))>




<DEFINE LOOP-FOR-BEING (VAR VAL DTYPE "AUX" (REDEFINE T)
		        (IPPS '()) TEM INCLUSIVE (TEM1 T))
	#DECL ((VAR) ATOM (DTYPE) <OR ATOM FALSE FORM> 
	      (INCLUSIVE EACH) <OR ATOM FALSE> (IPPS) LIST)
	<COND (<OR <==? .VAL EACH> <==? .VAL THE>>
	       <SET TEM1 EACH> <SET VAL <LSCFIRST>>)
	      (ELSE <SETG LOOP-SOURCE-CODE (.VAL !,LOOP-SOURCE-CODE)>)>
	<COND (<SET TEM <LOOP-LOOKUP-PATH .VAL>>
	       <SET INCLUSIVE <>>
	       <LSCPOP>)
	      (ELSE <CHECK-END>
		    <SET VAL <LSCPOP>>
		    <SET IPPS ((OF .VAL))>
		    <COND (<==? <LSCFIRST> AND>
			   <AND <==? .TEM1 EACH>
			        <ERROR MALFORMED-BEING-CLAUSE!-ERRORS .VAR>>
			   <SET INCLUSIVE T>
			   <LSCPOP>
			   <CHECK-END>
			   <OR <MEMQ <LSCPOP>
				     '[ITS HIS HER THEIR EACH]>
			       <ERROR LOOP-EXPECTED-ITS-OR-EACH!-ERRORS .TEM>>
			   <COND (<SET TEM <LOOP-LOOKUP-PATH
					    <SET TEM1 <LSCFIRST>>>>
				  <LSCPOP>)
				 (ELSE <CHECK-END>
					<ERROR UNDEFINED-LOOP-PATHNAME!-ERRORS
					      <LSCFIRST>>)>)
			  (ELSE <ERROR UNDEFINED-LOOP-PATHNAME!-ERRORS
				       .VAL>)>)>
	<SET TEM <APPLY ,<NTH .TEM 2> .TEM1 .VAR .DTYPE 
			(!.IPPS !<LOOP-GATHER-PREPS <3 .TEM>>) .INCLUSIVE 
			<3 .TEM> !<REST .TEM 3>>>
	<AND <1 .TEM> <SETG LOOP-PROLOGUE (<1 .TEM> !,LOOP-PROLOGUE)>>
	<REST .TEM>>


<DEFINE LOOP-GATHER-PREPS (PREPS-ALLOWED "AUX" (REDEFINE T))
	<REPEAT ((L '()) (TOKEN <LSCFIRST>))
		#DECL ((L) LIST (TOKEN) ANY)
		<COND (<NOT <MEMQ .TOKEN .PREPS-ALLOWED>>
		       <RETURN <LREVERSE .L>>)>
		<COND (<EMPTY? <REST ,LOOP-SOURCE-CODE>>
		       <LSCPOP> <CHECK-END>)>
		<SET L ((<LSCPOP> <LSCPOP>) !.L)> ;"ONLY ONE ARG PER PREP"
		<SET TOKEN <LSCFIRST>>>>


<DEFINE DEFINE-LOOP-GENERATOR ("TUPLE" DATA-LIST "AUX" (REDEFINE T) 
						  (NAME <1 .DATA-LIST>))
	<SETG LOOP-PATHS ((!.DATA-LIST) !,LOOP-PATHS)>
	.NAME>


<DEFINE LOOP-DO-COLLECT
	(TYPE "AUX"
	      (REDEFINE T)
	      (FORMS <LOOP-GET-FORM>)
	      (TEM0 T)
	      (VAR1 <COND (<==? <LSCFIRST> INTO>
			   <SET TEM0 <>>
			   <LSCPOP>
			   <CHECK-END>
 			   <LSCPOP>)
			  (ELSE <COND (,LAST-COLLECT-1)
				      (ELSE <SETG LAST-COLLECT-1
						 <LOOP-CREATE-VARIABLE>>)>)>)


	      (VAR2 <>)
	      (TEM1 <MAPF <> #FUNCTION ((CV) #DECL ((CV) LIST)
					     <COND (<==? <1 .CV> .VAR1>
						    <MAPLEAVE .CV>)>)
			  ,LOOP-COLLECT-VARS>)
	      CTYP TEM2)
	#DECL ((VAR1 TYPE STRUC-TYPE) ATOM
               (VAR2 TEM0) <OR FALSE ATOM> 
	       (CTYP) ATOM (TEM1) <OR LIST FALSE>)
	<COND (<==? <LSCFIRST> AS-A>
	       <LSCPOP> 
	       <COND (<N==? <TYPE <LSCFIRST>> LIST>
		      <ERROR ACCUMULATION-STRUCTURE-DECL-NOT-IN-LIST>)>
	       <SET CTYP <1 <LSCPOP>>>

		;"NON-OPTIMAL FOR SIMPLE CASES AT PRESENT."
		;"WHEN THE MAPF/R HACK IS DONE SOMEDAY, "
		;"THIS SHOULD BE REIMPLEMENTED"

	       <SETG LOOP-PRE-EPILOGUE 
		     (<FORM SET .VAR1 <FORM CHTYPE <FORM <TYPEPRIM .CTYP>
					     <PARSE <STRING !\! !\.
					<UNPARSE .VAR1>>>> .CTYP>>
				       !,LOOP-PRE-EPILOGUE)>)>

	<COND (<==? .TYPE LIST>
	       <SET VAR2 
		    <COND (.TEM1 
			   <AND <EMPTY? <REST .TEM1>>
				<ERROR CONFLICTING-COLLECTS-IN-LOOP!-ERRORS>>
				 <2 .TEM1>)
			  (ELSE <LOOP-CREATE-VARIABLE>)>>)
	      (ELSE <COND (.TEM1
			   <OR <EMPTY? <REST .TEM1>>
			       <ERROR CONFLICTING-COLLECTS-IN-LOOP!-ERRORS
				      .TYPE>>)>)>
	<SET TEM2 <CHECKC <COND (<==? .TYPE LIST> 
				  <FORM SET .VAR2
			 <FORM COND (<FORM NOT <FORM EMPTY? <FORM LVAL .VAR1>>>
				     <FORM REST 
				   <FORM PUTREST <FORM LVAL .VAR2> (.FORMS)>>)
			       (<FORM SET .VAR1 (.FORMS)>)>>)
				 (<==? .TYPE SUM>
			   <FORM SET .VAR1 <FORM + .FORMS <FORM LVAL .VAR1>>>)
				 (<==? .TYPE COUNT>
				 <FORM SET .VAR1 <FORM + <FORM LVAL .VAR1> 1>>)
				 (<OR <==? .TYPE MAX>
				      <==? .TYPE MIN>>
				  <FORM AND 
					<FORM <COND (<==? .TYPE MAX> G?)(T L?)>
					      .FORMS <FORM LVAL .VAR1>>
					<FORM SET .VAR1 .FORMS>>)>>>
	<SETG LOOP-BODY (.TEM2 !,LOOP-BODY)>
	<COND (<NOT .TEM1>
	       <SETG LOOP-COLLECT-VARS ((.VAR1 !<COND (.VAR2 (.VAR2))>) 
				       !,LOOP-COLLECT-VARS)>
	       <COND (<==? .TYPE LIST>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
			   <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>
                           <SETG LOOP-SET-LIST 
				   (<FORM SET .VAR1 '()> !,LOOP-SET-LIST)>>
                     <SETG LOOP-ILIST (.VAR2 !,LOOP-ILIST)>
                     <SETG LOOP-SET-LIST 
				   (<FORM SET .VAR2 '()> !,LOOP-SET-LIST)>)
		     (<==? .TYPE COUNT>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		           <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>
			   <SETG LOOP-SET-LIST 
				   (<FORM SET .VAR1 0> !,LOOP-SET-LIST)>>)
		     (<==? .TYPE SUM>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		           <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>>
		           <SETG LOOP-SET-LIST (<FORM SET .VAR1 
						  <FORM - .FORMS .FORMS>>
					            !,LOOP-SET-LIST)>)
		     (ELSE
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		      <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>>
		      <SETG LOOP-SET-LIST (<FORM SET .VAR1 .FORMS> 
					   !,LOOP-SET-LIST)>)>


	       <AND .TEM0 <SETG LOOP-AFTER-EPILOGUE 
			       (<FORM RETURN <FORM LVAL .VAR1>>
					      !,LOOP-AFTER-EPILOGUE)>>
	       <AND <==? <TYPE .VAR1> ATOM>
		        <COND (<==? .TYPE LIST>
			       <SETG LOOP-DECLARATIONS ((.VAR2) LIST
			               		       !,LOOP-DECLARATIONS)>)

			  (ELSE
			   <SETG LOOP-DECLARATIONS ((.VAR1) 
						   <COND (<==? .TYPE COUNT>
							  FIX)
					

							 (ELSE 
							  <FORM OR FLOAT FIX>)>
						   !,LOOP-DECLARATIONS)>)>>)>>
		


<DEFINE CHECKC (F "AUX" (REDEFINE T))
	<COND (<EMPTY? ,LOOP-CONDITIONALS> .F)
	      (ELSE <SETG LOOP-CONDITIONALS (( .F !<1 ,LOOP-CONDITIONALS>) 
					    !<REST ,LOOP-CONDITIONALS>)>
		    <COND (<==? <LSCFIRST> AND> <LSCPOP> <>)
			  (ELSE <REPEAT ((L <REST ,LOOP-CONDITIONALS>) 
			   (C <1 [<FORM COND <LREVERSE <1 ,LOOP-CONDITIONALS>>>
				<SETG LOOP-CONDITIONALS '()>]>))
					#DECL ((L) LIST (C) FORM)
					<COND (<EMPTY? .L> <RETURN .C>)>
				    <SET C <FORM COND <LREVERSE (.C !<1 .L>)>>>
				    <SET L <REST .L>>>)>)>>


<DEFINE LOOP-DO-WHEN (TYPEC "AUX" (REDEFINE T) 
				  (CONDIT <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TYPEC) <OR  ATOM FALSE>)
	<AND .TYPEC <SET CONDIT <FORM NOT .CONDIT>>>
	<SETG LOOP-CONDITIONALS ((.CONDIT) !,LOOP-CONDITIONALS)>>


<DEFINE LREVERSE (TEM "AUX" LST VAL TMP)    ;"FROM SOMEWHERE ON DM"
	#DECL ((LST) LIST)
	<SET VAL ()>
	<SET LST .TEM>
	<REPEAT ()
		<COND (<EMPTY? .LST> <RETURN .VAL>)>
		<SET TMP <REST .LST>>
		<SET VAL <PUTREST .LST .VAL>>
		<SET LST .TMP>>>


<DEFINE LOOP-DO-ALWAYS (TRUE "AUX" (REDEFINE T) 
				   (FORM <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TRUE) <OR ATOM FALSE>)
	<OR .TRUE <SET FORM <FORM NOT .FORM>>>
	<SET FORM <CHECKC <FORM OR .FORM '<RETURN #FALSE ()>>>>
	<SETG LOOP-EPILOGUE ('<RETURN T> !,LOOP-EPILOGUE)>
        <LOOP-EMIT-BODY .FORM LOOP-BODY>>


<DEFINE LOOP-DO-THEREIS ("AUX" (FORM <OR <CHECK-END> <LSCPOP>>))
	<SET FORM <CHECKC <FORM AND .FORM <FORM RETURN .FORM>>>>
	<LOOP-EMIT-BODY .FORM LOOP-BODY>>



<DEFINE LOOP-DO-WHILE (TRUE "AUX" (FORM <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TRUE) <OR ATOM FALSE>)
	<OR .TRUE <SET FORM <FORM NOT .FORM>>>
	<SET FORM <CHECKC <FORM OR .FORM <FORM SET ,RETVAR T>>>>
	<LOOP-EMIT-BODY .FORM LOOP-TESTS>>


<DEFINE LOOP-DO-WITH ("AUX" (REDEFINE T))
	<AND <NOT <EMPTY? ,LOOP-CONDITIONALS>>
	     <ERROR WITH-CLAUSE-INSIDE-CONDITIONAL!-ERRORS>>
	<REPEAT (VAR
		 TEM
		 (VALS '())
		 DTYPE)
             #DECL ((VAR) ATOM (VALS) LIST 
		    (DTYPE) <OR ATOM FORM FALSE>)
	     <CHECK-END>
	     <SET VAR <LSCPOP>>
	     <SET DTYPE <LOOP-OPTIONAL-TYPE>>
	     <SET TEM <LSCFIRST>>
	     <COND (<==? .TEM => <LSCPOP> <CHECK-END>
				 <SET VALS ((.VAR <LSCPOP>) !.VALS)>)>
	     <OR <MEMQ .VAR ,LOOP-ILIST>
	     <SETG LOOP-ILIST (.VAR !,LOOP-ILIST)>>
	     <AND .DTYPE <SETG LOOP-DECLARATIONS ((.VAR) .DTYPE !,LOOP-DECLARATIONS)>>
	     <SET TEM <LSCFIRST>>
	     <COND (<N==? .TEM AND>
		    <AND <NOT <EMPTY? .VALS>>
		      <SETG LOOP-SET-LIST (<LOOP-PSET .VALS> !,LOOP-SET-LIST)>>
		    <RETURN>)
		   (ELSE <LSCPOP>)>>>

<DEFINE LOOP-DO-RETURN ("AUX" (REDEFINE T))
       <SETG LOOP-BODY (<CHECKC <FORM RETURN <LOOP-GET-FORM>>> !,LOOP-BODY)>>


<DEFINE LOOP-PSET (STEPS) 
	#DECL ((STEPS) <LIST [REST LIST]>)
	<REPEAT ((L .STEPS)
		 (S <LPOP L>)
		 (F <FORM SET !.S>))
		<COND (<EMPTY? .L> <RETURN .F>)>     ;"PROG1"
		<SET S <LPOP L>>
		<SET F <FORM BIND ((T <2 .S>))
			     .F
			     <FORM SET <1 .S> '.T>>>>>


<DEFINE LOOP-DO-NAMED ("AUX" (REDEFINE T))
	<CHECK-END>
	<SETG LOOP-NAME <LSCPOP>>>

<DEFMAC CHECK-END ()
	'<COND (<EMPTY? ,LOOP-SOURCE-CODE>
		<ERROR UNEXPECTED-END-OF-LOOP-FORM!-ERRORS>)>>


;"DEBUGGING HACK"

<DEFINE LOOP-EXPAND (BOOL "AUX" (LOOP-TRANS ,LOOP)
			        (MACROP <==? <TYPE .LOOP-TRANS> MACRO>))
	#DECL ((BOOL MACROP) ANY (LOOP-TRANS) <OR FUNCTION MACRO>)
	<COND (<AND .MACROP .BOOL> <GUNASSIGN LOOP>
	       <SETG LOOP <1 <CHTYPE .LOOP-TRANS LIST>>>)
	      (<AND <NOT .MACROP> <NOT .BOOL>> <GUNASSIGN LOOP>
               <SETG LOOP <CHTYPE (.LOOP-TRANS) MACRO>>)>
	.BOOL>

<DEFINE LOOP-MEMO () <FAST-MACROS>>

<DEFINE LOOP-DECLARE (L "AUX" (REDEFINE T))
	<COND (<==? <TYPE .L> LIST>
	       <SETG LOOP-DECLARATIONS (!.L !,LOOP-DECLARATIONS)>)>>

<ENDPACKAGE>
<PACKAGE "LOOP">

;"New Version 6/3/81"
;"Bugs, comments, gripes to MARKT"


<RENTRY ON DO IF TO>

<ENTRY  LOOP                	;"FUNCTIONS AND MACROS"
	LOOP-EXPAND 
	DEFINE-LOOP-GENERATOR
	LOOP-MEMO
	LOOP-DECLARATION        ;"FOR USE IN DEFINE-LOOP-PATH"
	LOOP-CREATE-VARIABLE
	LOOP-SOURCE-CODE
	LSCPOP
	LOOP-IN-PATH            ;"SIMPLE PATHS"
	LOOP-ON-PATH
	LOOP-ARITHMETIC-PATH
	INITIALLY 	        ;"KEYWORDS"
	FINALLY 
	COLLECT 
	COUNT 
	MAXIMIZE 
	MINIMIZE 
	SUM
	WHEN 
	UNLESS 
	WITH 
	ALWAYS 
	NEVER 
	FINISH 
	NAMED 
	THEREIS 
	WHILE 
	UNTIL 
	AS 
	FOR 
	= 
	BEING 
	FROM 
	DOWNFROM 
	UPFROM 
	INTO 
	AS-A
	ABOVE 
	BELOW
	BY 
	THE
	APPLYING
	STEP
	DOWNTO
	ITS
	HIS
	HER
	THEIR
	EACH
	OF
	THEN>

<SETG ILOOP-OBLIST <1 .OBLIST>>

<SETG LOOP-REGISTERS '![LOOP-PROLOGUE 
			LOOP-BODY 
			LOOP-EPILOGUE
			LOOP-PRE-EPILOGUE
			LOOP-AFTER-EPILOGUE 
			LOOP-CONDITIONALS 
			LOOP-STEPS 
			LOOP-DECLARATIONS
			LOOP-ILIST 
			LOOP-INIT-SET-LIST 
			LOOP-PRETESTS 
			LOOP-PRESETS
			LOOP-POSTSETS
			LOOP-POSTTESTS
			LOOP-COLLECT-VARS 
			LOOP-SOURCE-CODE]>


<GDECL (LOOP-NAME) <OR ATOM FALSE>
       (RETVAR) ATOM
       (LOOP-PROLOGUE LOOP-BODY LOOP-EPILOGUE
	LOOP-PRE-EPILOGUE LOOP-PRESETS LOOP-POSTSETS
	LOOP-AFTER-EPILOGUE LOOP-CONDITIONALS 
	LOOP-STEPS LOOP-DECLARATIONS
	LOOP-ILIST LOOP-INIT-SET-LIST LOOP-PRETESTS 
	LOOP-COLLECT-VARS LOOP-SOURCE-CODE)  LIST>


<SETG LOOP-KEYWORDS
     '![(FOR LOOP-DO-FOR)
	(WITH LOOP-DO-WITH)
	(COLLECT LOOP-DO-COLLECT LIST)
	(DO LOOP-DO-DO)
	(WHEN LOOP-DO-WHEN #FALSE ())
	(RETURN LOOP-DO-RETURN)
	(AS LOOP-DO-FOR)
	(INITIALLY LOOP-DO-INITIALLY)
	(FINALLY LOOP-DO-FINALLY)
	(COUNT LOOP-DO-COLLECT COUNT)
	(MAXIMIZE LOOP-DO-COLLECT MAX)
	(MINIMIZE LOOP-DO-COLLECT MIN)
	(SUM LOOP-DO-COLLECT SUM)
	(IF LOOP-DO-WHEN #FALSE ())
	(UNLESS LOOP-DO-WHEN T)
	(ALWAYS LOOP-DO-ALWAYS T)
	(NEVER LOOP-DO-ALWAYS #FALSE ())
	(NAMED LOOP-DO-NAMED)
	(THEREIS LOOP-DO-THEREIS)
	(WHILE LOOP-DO-WHILE T)
	(UNTIL LOOP-DO-WHILE #FALSE ())]>

<SETG LOOP-FOR-KEYWORDS 
     '![(= LOOP-FOR-EQUALS)
	(BEING LOOP-FOR-BEING)
	(FROM LOOP-FOR-ARITHMETIC #FALSE ())
	(DOWNFROM LOOP-FOR-ARITHMETIC -)
	(UPFROM LOOP-FOR-ARITHMETIC +)
	(IN LOOP-FOR-IN)
	(ON LOOP-FOR-ON)]>



<SETG LOOP-PATH-KEYWORDS '()>

<SETG LOOP-GENERATION-NUMBER 0>

<SETG LOOP-PATHS '()>

<GDECL (LOOP-GENERATION-NUMBER) FIX 
       (LOOP-REGISTERS) <UVECTOR [REST ATOM]>
       (LOOP-PATHS LOOP-PATH-KEYWORDS) LIST 
       (LOOP-KEYWORDS LOOP-FOR-KEYWORDS) <UVECTOR [REST LIST]>>


<DEFINE LOOP-LOOKUP-KEYWORD (WORD KWLIST)
	#DECL ((KWLIST) UVECTOR)
	<COND (<==? <TYPE .WORD> ATOM>
	       <MAPF <> <FUNCTION (L) <COND (<=? .WORD  <1 .L>>
					     <MAPLEAVE .L>)>>
		     .KWLIST>)>>


<DEFINE LOOP-LOOKUP-PATH (WORD)
	<COND (<==? <TYPE .WORD> ATOM>
	       <MAPF <> <FUNCTION (L) <COND (<MEMQ .WORD <1 .L>>
					     <MAPLEAVE .L>)>>
		     ,LOOP-PATHS>)>>


<DEFMAC LOOP ("ARGS" TEM-LOOP-SOURCE-CODE "AUX" (REDEFINE T))
    #DECL ((TEM-LOOP-SOURCE-CODE) LIST)
    <SETG LOOP-NAME <>>
    <SETG LAST-COLLECT-1 <>>
    <SETG RETVAR <LOOP-CREATE-VARIABLE>>
    <MAPF <> #FUNCTION ((AT) #DECL ((AT) ATOM)
			     <SETG .AT '()>)
	     ,LOOP-REGISTERS>
    <SETG LOOP-SOURCE-CODE .TEM-LOOP-SOURCE-CODE>
    <REPEAT (KEYWORD TEM TESTRETURN)
       <COND (<EMPTY? ,LOOP-SOURCE-CODE>
	      <RETURN 
		<FORM BIND ,LOOP-ILIST
		      !<AND <NOT <EMPTY? ,LOOP-DECLARATIONS>>
			    (<CHTYPE ,LOOP-DECLARATIONS DECL>)>
		      !<LREVERSE ,LOOP-INIT-SET-LIST>
		      !<LREVERSE ,LOOP-PROLOGUE>
		      <FORM REPEAT !<AND ,LOOP-NAME (,LOOP-NAME)>
			             ((,RETVAR '<>))
			    <CHTYPE ((,RETVAR) '<OR ATOM FALSE>) DECL>
			    !<AND <NOT <EMPTY? ,LOOP-PRETESTS>>
				  (<SET TESTRETURN 
				    <FORM COND (<COND (<EMPTY? <REST ,LOOP-PRETESTS>>
							<1 ,LOOP-PRETESTS>)
						       (ELSE <FORM OR !,LOOP-PRETESTS>)>
				                 !<LREVERSE ,LOOP-PRE-EPILOGUE>
				  		 !<LREVERSE ,LOOP-EPILOGUE>
				                 !<COND (<EMPTY? ,LOOP-AFTER-EPILOGUE>
					                 '(<RETURN>))
					                (ELSE ,LOOP-AFTER-EPILOGUE)>)>>)> 
				  !<LREVERSE ,LOOP-PRESETS>
				  !<LREVERSE ,LOOP-BODY>
				  !<LREVERSE ,LOOP-POSTTESTS>
				  !<AND <NOT <EMPTY? ,LOOP-POSTTESTS>>
					(<COND (<ASSIGNED? TESTRETURN>
						.TESTRETURN)
	               			       (ELSE 
						<FORM COND 
						      (<COND (<EMPTY? <REST  ,LOOP-POSTTESTS>>
							      <1 ,LOOP-POSTTESTS>)
							     (ELSE <FORM OR !,LOOP-POSTTESTS>)>
				                       !<LREVERSE ,LOOP-PRE-EPILOGUE>
				  		       !<LREVERSE ,LOOP-EPILOGUE>
				                       !<COND (<EMPTY? ,LOOP-AFTER-EPILOGUE>
					                       '(<RETURN>))
					                      (ELSE ,LOOP-AFTER-EPILOGUE)>)>)>)>
				!<LREVERSE ,LOOP-POSTSETS>
		 		!<LREVERSE ,LOOP-STEPS>>>>)

		      (<NOT <==? <TYPE <SET KEYWORD <LSCPOP>>> ATOM>>
		       <ERROR NON-ATOM-WHERE-KEYWORD-EXPECTED!-ERRORS
			      .KEYWORD>)
		      (<SET TEM <LOOP-LOOKUP-KEYWORD .KEYWORD ,LOOP-KEYWORDS>>
		       <APPLY ,<2 .TEM> !<REST .TEM 2>>)
		      (ELSE <ERROR UNKNOWN-LOOP-KEYWORD!-ERRORS .KEYWORD>)>>>


<DEFINE LOOP-EMIT-BODY (FORML PLACE "AUX" (REDEFINE T))
	#DECL ((PLACE) ATOM)
	<SETG .PLACE (<CHECKC .FORML> !,.PLACE)>>


<DEFINE LOOP-GET-FORM ("AUX" (REDEFINE T))
	<REPEAT ((FORMS '())
		 (NEXTFORM <LSCFIRST>))
		#DECL ((FORMS) LIST)
		<COND (<OR <EMPTY? ,LOOP-SOURCE-CODE>
			   <==? <TYPE .NEXTFORM> ATOM>>
		       <RETURN <COND (<EMPTY? .FORMS> <FORM>)
				     (<EMPTY? <REST .FORMS>> <1 .FORMS>)
			     (ELSE <FORM BIND '() !<LREVERSE .FORMS>>)>>)>
		<SET FORMS (<LSCPOP> !.FORMS)>
		<SET NEXTFORM <LSCFIRST>>>>


<DEFINE LOOP-DO-INITIALLY ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-PROLOGUE>>

<DEFINE LOOP-DO-DO ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-BODY>>

<DEFINE LOOP-DO-FINALLY ()
	<LOOP-EMIT-BODY <LOOP-GET-FORM> LOOP-EPILOGUE>>


<DEFMAC LPOP (LNAME)
	#DECL ((LNAME) ATOM)
	<FORM BIND ((TMP <FORM 1 <FORM LVAL .LNAME>>))
	      <FORM SET .LNAME 
		    <FORM REST <FORM LVAL .LNAME>>>
	      '.TMP>>


<DEFMAC LSCPOP ()
	'<BIND ((TMP <1 ,LOOP-SOURCE-CODE>))
		<SETG LOOP-SOURCE-CODE <REST ,LOOP-SOURCE-CODE>>
		.TMP>>


<DEFINE LOOP-DO-FOR ("AUX" (REDEFINE T))
	<OR <EMPTY? ,LOOP-CONDITIONALS>
	    <ERROR FOR/AS-STARTING-INSIDE-OF-CONDITIONAL!-ERRORS>>
	<REPEAT (VAR
		 DATA-TYPE
		 KEYWORD
		 TEM
		 THE-INITS
		 THE-PRE-SETS
		 THE-POST-SETS
		 (PRE-TESTS '()) (POST-TESTS '())
		 (STEPS '()) (IVINITS '()))
		 
		#DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FORM FALSE>
		       (TEM PRE-TESTS POST-TESTS) LIST 
		       (THE-PRE-SETS THE-POST-SETS) <LIST [REST LIST]>
		       (THE-INITS STEPS IVINITS) <LIST [REST LIST]>)

		<SET THE-INITS '()>
		<SET THE-PRE-SETS '()>
		<SET THE-POST-SETS '()>

		<CHECK-END>
		<SET VAR <LSCPOP>>
		<SET DATA-TYPE <LOOP-OPTIONAL-TYPE>>
		<CHECK-END>
		<SET KEYWORD <LSCPOP>>
		<OR <SET TEM <LOOP-LOOKUP-KEYWORD
				    .KEYWORD
				    ,LOOP-FOR-KEYWORDS>>
		    <ERROR UNKNOWN-KEYWORD-IN-FOR-OR-AS-CLAUSE!-ERRORS
			   .KEYWORD>>

		<CHECK-END>
		<SET TEM <APPLY ,<NTH .TEM 2> 
                            .VAR <LSCPOP> .DATA-TYPE !<REST .TEM 2>>>
	
		<OR <EMPTY? <1 .TEM>>
		    <SET THE-INITS <1 .TEM>>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET IVINITS (<1 .TEM> !.IVINITS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET PRE-TESTS (<1 .TEM> !.PRE-TESTS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET THE-PRE-SETS <1 .TEM>>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET POST-TESTS (<1 .TEM> !.POST-TESTS)>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET THE-POST-SETS <1 .TEM>>>
		<OR <EMPTY? <1 <SET TEM <REST .TEM>>>>
		    <SET STEPS (<1 .TEM> !.STEPS)>>

	        <MAPF <> #FUNCTION ((I "AUX" (V <1 .I>))
                            #DECL ((I) LIST (V) ATOM)
			    <COND (<NOT <MEMQ .V ,LOOP-ILIST>>
				   <SETG LOOP-ILIST (.V !,LOOP-ILIST)>
				   <SETG LOOP-INIT-SET-LIST
					 (<FORM SET !.I> 
					   !,LOOP-INIT-SET-LIST)>)>)
			 .THE-INITS>
		
		<MAPF <> #FUNCTION ((L) 
			    #DECL ((L) LIST)
			    <SETG LOOP-PRESETS (<FORM SET !.L> 
					       !,LOOP-PRESETS)>)
			 .THE-PRE-SETS>

		<MAPF <> #FUNCTION ((L)
			   #DECL ((L) LIST)
			    <SETG LOOP-POSTSETS (<FORM SET !.L> 
						 !,LOOP-POSTSETS)>)
			 .THE-POST-SETS>

	        <COND (<N==? <LSCFIRST>  AND>
		       <OR <EMPTY? .PRE-TESTS>
			   <SETG LOOP-PRETESTS 
                             (!.PRE-TESTS
		              !,LOOP-PRETESTS)>>

		       <OR <EMPTY? .POST-TESTS>
			   <SETG LOOP-POSTTESTS 
			     (!.POST-TESTS
			      !,LOOP-POSTTESTS)>>
	       
	       <COND (<NOT <EMPTY? .IVINITS>>
		      <SETG LOOP-INIT-SET-LIST 
 			    (<LOOP-PSET .IVINITS> !,LOOP-INIT-SET-LIST)>
		      <MAPF <> #FUNCTION ((I "AUX" (V <1 .I>))
				 #DECL ((I) LIST (V) ATOM)
				 <COND (<NOT <MEMQ .V ,LOOP-ILIST>>
					<SETG LOOP-ILIST (.V !,LOOP-ILIST)>)>)
			       .IVINITS>)>


	       <OR <EMPTY? .STEPS>
                 <SETG LOOP-STEPS (<LOOP-PSET .STEPS> !,LOOP-STEPS)>>
	       
	       <RETURN <>>)

	      (ELSE <CHECK-END> <LSCPOP>)>>>
		     

<DEFINE LOOP-OPTIONAL-TYPE ("AUX" (REDEFINE T) 
				  (TOKEN <LSCFIRST>) 
				  (TY <TYPE .TOKEN>))
	<COND (<==? .TY FORM> <LSCPOP>)
	      (<==? .TY LIST> <1 <LSCPOP>>)>>
	    


<DEFINE LOOP-FOR-EQUALS (VAR VAL DATA-TYPE "AUX" (REDEFINE T)
			     (NEXTVAL <COND (<==? <LSCFIRST> THEN>
					     <CHECK-END>
					     <LSCPOP> <LSCPOP>)
					    (ELSE .VAL)>))
        #DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FORM FALSE>)
	<AND .DATA-TYPE
	     <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE !,LOOP-DECLARATIONS)>>
	(<> (.VAR .VAL) <> <> <> <> (.VAR .NEXTVAL))>


<DEFINE LOOP-FOR-ON (VAR VAL DATA-TYPE 
	            "AUX" (REDEFINE T)
			  (VAR1 <LOOP-CREATE-VARIABLE>)
			  (SDTYPE <LOOP-OPTIONAL-TYPE>)
		          (STEP <COND (<==? <LSCFIRST> BY>
				       <LSCPOP> 
				       <CHECK-END> 
				       <LSCPOP>)
				      (ELSE REST)>))
	#DECL ((VAR) ATOM (DATA-TYPE SDTYPE) <OR FORM FALSE ATOM>
	       (VAR1) ATOM)
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE 
						!,LOOP-DECLARATIONS)>>
	<AND .SDTYPE <SETG LOOP-DECLARATIONS ((.VAR1) .SDTYPE
					      !,LOOP-DECLARATIONS)>>
	(((.VAR1 .VAL))
	 (.VAR .VAL)
	 <FORM EMPTY? <FORM LVAL .VAR1>>
	 ((.VAR <FORM LVAL .VAR1>))
	 <>
	 <>
	 (.VAR1 <FORM .STEP <FORM LVAL .VAR1>>))>

<DEFINE LOOP-FOR-IN (VAR VAL DATA-TYPE 
		    "AUX" (REDEFINE T)
			  (VAR1 <LOOP-CREATE-VARIABLE>)
			  (SDTYPE <LOOP-OPTIONAL-TYPE>)
			  (STEP <COND (<==? <LSCFIRST> BY>
				       <LSCPOP> 
				       <CHECK-END>
				       <LSCPOP>)
				      (ELSE REST)>)
			  (APPLYING <COND (<==? <LSCFIRST> APPLYING>
					   <LSCPOP>
					   <CHECK-END>
 					   <LSCPOP>)
				          (ELSE 1)>))
	#DECL ((VAR) ATOM (DATA-TYPE SDTYPE) <OR FORM FALSE ATOM>
	       (VAR1) ATOM)
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE
						 !,LOOP-DECLARATIONS)>>
	<AND .SDTYPE <SETG LOOP-DECLARATIONS ((.VAR1) .SDTYPE
					      !,LOOP-DECLARATIONS)>>

	(((.VAR1 .VAL))
	 (.VAR <FORM OR <FORM EMPTY? <FORM LVAL .VAR1>>
		        <FORM .APPLYING <FORM LVAL .VAR1>>>)
	 <FORM EMPTY? <FORM LVAL .VAR1>>
	 ((.VAR <FORM .APPLYING  <FORM LVAL .VAR1>>))
	 <>
	 <>
	 (.VAR1 <FORM .STEP <FORM LVAL .VAR1>>))>



<DEFINE LOOP-IN-PATH (CB VAR DTYPE PPS INCL? APPS
		      "TUPLE" DATA
		      "AUX" A 
			   (VAL <COND (<EMPTY? .PPS>
				       <ERROR PATH-EXPECTED-IN-PHRASE>)
				      (ELSE <SET A <1 .PPS>>
					    <SET PPS <REST .PPS>>
					    <2 .A>)>)
			   (STEP <COND (<OR <EMPTY? .PPS>
					    <N==? <1 <SET A <1 <SET PPS 
						<REST .PP>>>>> BY>>
					REST)
				       (ELSE <2 .A>)>)
			   (APPLYING <COND (<OR <EMPTY? .PPS>
						<N==? <1 <SET A <1 <SET PPS
						    <REST .PP>>>>> APPLYING>>
					'1)
				       (ELSE <2 .A>)>)
			   (V1 <LOOP-CREATE-VARIABLE>))
	
	 #DECL ((CB VAR) ATOM (DTYPE) <OR ATOM FALSE FORM>
	       (INCL?) <OR 'T '#FALSE()> (A) LIST (V1) ATOM)

	<AND <NOT <EMPTY? .DATA>>
	     <SET VAL <FORM <1 .DATA> .VAL>>>

	<AND .DTYPE <SETG LOOP-DECLARATIONS ((.VAR) .DTYPE 
					     !,LOOP-DECLARATIONS)>>
	<COND (.INCL? 
		(<>
		 ((.V1 .VAL)) 
		 (.VAR <FORM LVAL .V1>)
		 <>
		 <>
		 <FORM EMPTY? <FORM LVAL .V1>>
		 ((.VAR <FORM .APPLYING <FORM LVAL .V1>>))
		 (.V1 <FORM .STEP <FORM LVAL .V1>>)))
	      (ELSE 
		(<>
		 ((.V1 .VAL))
		 (.VAR <FORM OR <FORM EMPTY? <FORM LVAL .V1>>
				 <FORM .APPLYING <FORM LVAL .V1>>>)
		 <FORM EMPTY? <FORM LVAL .V1>>
		 ((.VAR <FORM .APPLYING <FORM LVAL .V1>>))
		 <>
		 <>
		 (.V1 <FORM .STEP <FORM LVAL .V1>>)))>>
	





<DEFMAC LSCFIRST ()
	'<AND <NOT <EMPTY? ,LOOP-SOURCE-CODE>>
	      <1 ,LOOP-SOURCE-CODE>>>


<DEFINE LOOP-CREATE-VARIABLE ("AUX" (REDEFINE T) SYMBOL)
	<SET SYMBOL <STRING "G" <UNPARSE 
			       <- <SETG LOOP-GENERATION-NUMBER 
					<+ 1 ,LOOP-GENERATION-NUMBER>> 1>>>>
	<OR <LOOKUP .SYMBOL ,ILOOP-OBLIST>
	    <INSERT .SYMBOL ,ILOOP-OBLIST>>>


<PUTPROP TO DIRECTION +>
<PUTPROP BELOW DIRECTION +>
<PUTPROP DOWNTO DIRECTION ->
<PUTPROP ABOVE DIRECTION ->
<PUTPROP TO ENDTEST G?>
<PUTPROP BELOW ENDTEST G=?>
<PUTPROP DOWNTO ENDTEST L?>
<PUTPROP ABOVE ENDTEST L=?>


<DEFINE LOOP-FOR-ARITHMETIC (VAR VAL DATA-TYPE FORCED-DIRECTION "AUX"
		 (REDEFINE T)
		 (GDIR <GETPROP <LSCFIRST> DIRECTION>)
		 (HOWTO <AND .GDIR <LSCPOP>>)
		 (LIMIT <AND .HOWTO <NOT <CHECK-END>> <LSCPOP>>)
		 (DIRECTION <COND (.GDIR)
				  (.FORCED-DIRECTION)
				  (ELSE +)>)
		 (STEP <>)
		 TEM)
	#DECL ((VAR) ATOM (DATA-TYPE) <OR ATOM FALSE FORM> 
	       (FORCED-DIRECTION DIRECTION HOWTO EXCLUSIVE) <OR ATOM FALSE>)
	<AND .FORCED-DIRECTION
	     <N==? .FORCED-DIRECTION .DIRECTION>
	     <ERROR STEPPING-IN-TWO-DIRECTIONS!-ERRORS .VAR>>
	<SET TEM <LSCFIRST>>
	<SET STEP <COND 
		   (<==? .TEM BY>
		    <LSCPOP> <CHECK-END> 
		    <FORM APPLY <LSCPOP> <FORM LVAL .VAR>>)
		   (ELSE <FORM .DIRECTION 
			       <FORM LVAL .VAR>
			       <COND (<==? .TEM STEP>
				      <LSCPOP>
				      <CHECK-END>
 				      <LSCPOP>)
				     (ELSE 1)>>)>>
	<AND <OR <==? <SET TEM <LSCFIRST>> BY>
		 <==? .TEM STEP>>
	     <ERROR CONFLICTING-STEP-KEYWORD-IN-FOR-CLAUSE!-ERRORS .TEM>>
	<COND (<NOT .LIMIT> <SET TEM <>>)
	      (ELSE <SET TEM  <FORM <GETPROP .HOWTO ENDTEST> 
				    <FORM LVAL .VAR> .LIMIT>>)>
	<AND .DATA-TYPE <SETG LOOP-DECLARATIONS ((.VAR) .DATA-TYPE
						!,LOOP-DECLARATIONS)>>

	(<> (.VAR .VAL) .TEM <> <> <> (.VAR .STEP))>



<DEFINE LOOP-FOR-BEING (VAR VAL DTYPE "AUX" (REDEFINE T)
		        (IPPS '()) TEM INCLUSIVE (TEM1 T))
	#DECL ((VAR) ATOM (DTYPE) <OR ATOM FALSE FORM> 
	      (INCLUSIVE EACH) <OR ATOM FALSE> (IPPS) LIST)
	<COND (<OR <==? .VAL EACH> <==? .VAL THE>>
	       <SET TEM1 EACH> <SET VAL <LSCFIRST>>)
	      (ELSE <SETG LOOP-SOURCE-CODE (.VAL !,LOOP-SOURCE-CODE)>)>
	<COND (<SET TEM <LOOP-LOOKUP-PATH .VAL>>
	       <SET INCLUSIVE <>>
	       <LSCPOP>)
	      (ELSE <CHECK-END>
		    <SET VAL <LSCPOP>>
		    <SET IPPS ((OF .VAL))>
		    <COND (<==? <LSCFIRST> AND>
			   <AND <==? .TEM1 EACH>
			        <ERROR MALFORMED-BEING-CLAUSE!-ERRORS .VAR>>
			   <SET INCLUSIVE T>
			   <LSCPOP>
			   <CHECK-END>
			   <OR <MEMQ <LSCPOP>
				     '![ITS HIS HER THEIR EACH]>
			       <ERROR LOOP-EXPECTED-ITS-OR-EACH!-ERRORS .TEM>>
			   <COND (<SET TEM <LOOP-LOOKUP-PATH
					    <SET TEM1 <LSCFIRST>>>>
				  <LSCPOP>)
				 (ELSE <CHECK-END>
					<ERROR UNDEFINED-LOOP-PATHNAME!-ERRORS
					      <LSCFIRST>>)>)
			  (ELSE <ERROR UNDEFINED-LOOP-PATHNAME!-ERRORS
				       .VAL>)>)>
	<SET TEM <APPLY ,<NTH .TEM 2> .TEM1 .VAR .DTYPE 
			(!.IPPS !<LOOP-GATHER-PREPS <3 .TEM>>) .INCLUSIVE 
			<3 .TEM> !<REST .TEM 3>>>
	<AND <1 .TEM> <SETG LOOP-PROLOGUE (<1 .TEM> !,LOOP-PROLOGUE)>>
	<REST .TEM>>


<DEFINE LOOP-GATHER-PREPS (PREPS-ALLOWED "AUX" (REDEFINE T))
	<REPEAT ((L '()) (TOKEN <LSCFIRST>))
		#DECL ((L) LIST (TOKEN) ANY)
		<COND (<NOT <MEMQ .TOKEN .PREPS-ALLOWED>>
		       <RETURN <LREVERSE .L>>)>
		<COND (<EMPTY? <REST ,LOOP-SOURCE-CODE>>
		       <LSCPOP> <CHECK-END>)>
		<SET L ((<LSCPOP> <LSCPOP>) !.L)> ;"only one argument is"
		<SET TOKEN <LSCFIRST>>>>          ;"allowed per preposition"


<DEFMAC DEFINE-LOOP-GENERATOR ("ARGS" DATA-LIST)
	<FORM BIND ((NAME <1 .DATA-LIST>))
	       <FORM SETG LOOP-PATHS (.DATA-LIST '!,LOOP-PATHS)>
	       '.NAME>> 

<DEFINE LOOP-DO-COLLECT
	(TYPE "AUX"
	      (REDEFINE T)
	      (FORMS <LOOP-GET-FORM>)
	      (TEM0 T)
	      (VAR1 <COND (<==? <LSCFIRST> INTO>
			   <SET TEM0 <>>
			   <LSCPOP>
			   <CHECK-END>
 			   <LSCPOP>)
			  (ELSE <COND (,LAST-COLLECT-1)
				      (ELSE <SETG LAST-COLLECT-1
						 <LOOP-CREATE-VARIABLE>>)>)>)


	      (VAR2 <>)
	      (TEM1 <MAPF <> #FUNCTION ((CV) #DECL ((CV) LIST)
					     <COND (<==? <1 .CV> .VAR1>
						    <MAPLEAVE .CV>)>)
			  ,LOOP-COLLECT-VARS>)
	      CTYP TEM2)
	#DECL ((VAR1 TYPE STRUC-TYPE) ATOM
               (VAR2 TEM0) <OR FALSE ATOM> 
	       (CTYP) ATOM (TEM1) <OR LIST FALSE>)
	<COND (<==? <LSCFIRST> AS-A>
	       <LSCPOP> 
	       <COND (<N==? <TYPE <LSCFIRST>> LIST>
		      <ERROR ACCUMULATION-STRUCTURE-DECL-NOT-IN-LIST>)>
	       <SET CTYP <1 <LSCPOP>>>

		;"NON-OPTIMAL FOR SIMPLE CASES AT PRESENT."
		;"WHEN THE MAPF/R HACK IS DONE SOMEDAY, "
		;"THIS SHOULD BE REIMPLEMENTED"

	       <SETG LOOP-PRE-EPILOGUE 
		     (<FORM SET .VAR1 <FORM CHTYPE <FORM <TYPEPRIM .CTYP>
					     <PARSE <STRING !\! !\.
					<UNPARSE .VAR1>>>> .CTYP>>
				       !,LOOP-PRE-EPILOGUE)>)>

	<COND (<==? .TYPE LIST>
	       <SET VAR2 
		    <COND (.TEM1 
			   <AND <EMPTY? <REST .TEM1>>
				<ERROR CONFLICTING-COLLECTS-IN-LOOP!-ERRORS>>
				 <2 .TEM1>)
			  (ELSE <LOOP-CREATE-VARIABLE>)>>)
	      (ELSE <COND (.TEM1
			   <OR <EMPTY? <REST .TEM1>>
			       <ERROR CONFLICTING-COLLECTS-IN-LOOP!-ERRORS
				      .TYPE>>)>)>
	<SET TEM2 <CHECKC <COND (<==? .TYPE LIST> 
				  <FORM SET .VAR2
			 <FORM COND (<FORM NOT <FORM EMPTY? <FORM LVAL .VAR1>>>
				     <FORM REST 
				   <FORM PUTREST <FORM LVAL .VAR2> (.FORMS)>>)
			       (<FORM SET .VAR1 (.FORMS)>)>>)
				 (<==? .TYPE SUM>
			   <FORM SET .VAR1 <FORM + .FORMS <FORM LVAL .VAR1>>>)
				 (<==? .TYPE COUNT>
				 <FORM SET .VAR1 <FORM + <FORM LVAL .VAR1> 1>>)
				 (<OR <==? .TYPE MAX>
				      <==? .TYPE MIN>>
				  <FORM AND 
					<FORM <COND (<==? .TYPE MAX> G?)(T L?)>
					      .FORMS <FORM LVAL .VAR1>>
					<FORM SET .VAR1 .FORMS>>)>>>
	<SETG LOOP-BODY (.TEM2 !,LOOP-BODY)>
	<COND (<NOT .TEM1>
	       <SETG LOOP-COLLECT-VARS ((.VAR1 !<COND (.VAR2 (.VAR2))>) 
				       !,LOOP-COLLECT-VARS)>
	       <COND (<==? .TYPE LIST>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
			   <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>
                           <SETG LOOP-INIT-SET-LIST 
 			    (<FORM SET .VAR1 '()> !,LOOP-INIT-SET-LIST)>>
                     <SETG LOOP-ILIST (.VAR2 !,LOOP-ILIST)>
                     <SETG LOOP-INIT-SET-LIST 
				  (<FORM SET .VAR2 '()> !,LOOP-INIT-SET-LIST)>)
		     (<==? .TYPE COUNT>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		           <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>
			   <SETG LOOP-INIT-SET-LIST 
				   (<FORM SET .VAR1 0> !,LOOP-INIT-SET-LIST)>>)
		     (<==? .TYPE SUM>
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		           <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>>
		           <SETG LOOP-INIT-SET-LIST (<FORM SET .VAR1 
						  <FORM - .FORMS .FORMS>>
					            !,LOOP-INIT-SET-LIST)>)
		     (ELSE
		      <AND <NOT <MEMQ .VAR1 ,LOOP-ILIST>>
		      <SETG LOOP-ILIST (.VAR1 !,LOOP-ILIST)>>
		      <SETG LOOP-INIT-SET-LIST (<FORM SET .VAR1 .FORMS> 
					   !,LOOP-INIT-SET-LIST)>)>


	       <AND .TEM0 <SETG LOOP-AFTER-EPILOGUE 
			       (<FORM RETURN <FORM LVAL .VAR1>>
					      !,LOOP-AFTER-EPILOGUE)>>
	       <AND <==? <TYPE .VAR1> ATOM>
		        <COND (<==? .TYPE LIST>
			       <SETG LOOP-DECLARATIONS ((.VAR2) LIST
			               		       !,LOOP-DECLARATIONS)>)

			  (ELSE
			   <SETG LOOP-DECLARATIONS ((.VAR1) 
						   <COND (<==? .TYPE COUNT>
							  FIX)
					

							 (ELSE 
							  <FORM OR FLOAT FIX>)>
						   !,LOOP-DECLARATIONS)>)>>)>>
		


<DEFINE CHECKC (F "AUX" (REDEFINE T))
	<COND (<EMPTY? ,LOOP-CONDITIONALS> .F)
	      (ELSE <SETG LOOP-CONDITIONALS (( .F !<1 ,LOOP-CONDITIONALS>) 
					    !<REST ,LOOP-CONDITIONALS>)>
		    <COND (<==? <LSCFIRST> AND> <LSCPOP> <>)
			  (ELSE <REPEAT ((L <REST ,LOOP-CONDITIONALS>) 
			   (C <1 [<FORM COND <LREVERSE <1 ,LOOP-CONDITIONALS>>>
				<SETG LOOP-CONDITIONALS '()>]>))
					#DECL ((L) LIST (C) FORM)
					<COND (<EMPTY? .L> <RETURN .C>)>
				    <SET C <FORM COND <LREVERSE (.C !<1 .L>)>>>
				    <SET L <REST .L>>>)>)>>


<DEFINE LOOP-DO-WHEN (TYPEC "AUX" (REDEFINE T) 
				  (CONDIT <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TYPEC) <OR  ATOM FALSE>)
	<AND .TYPEC <SET CONDIT <FORM NOT .CONDIT>>>
	<SETG LOOP-CONDITIONALS ((.CONDIT) !,LOOP-CONDITIONALS)>>


<DEFINE LREVERSE (TEM "AUX" LST VAL TMP)    ;"CLR'S LREVERSE"
	#DECL ((LST) LIST)
	<SET VAL ()>
	<SET LST .TEM>
	<REPEAT ()
		<COND (<EMPTY? .LST> <RETURN .VAL>)>
		<SET TMP <REST .LST>>
		<SET VAL <PUTREST .LST .VAL>>
		<SET LST .TMP>>>


<DEFINE LOOP-DO-ALWAYS (TRUE "AUX" (REDEFINE T) 
				   (FORM <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TRUE) <OR ATOM FALSE>)
	<OR .TRUE <SET FORM <FORM NOT .FORM>>>
	<SET FORM <CHECKC <FORM OR .FORM '<RETURN #FALSE ()>>>>
	<SETG LOOP-EPILOGUE ('<RETURN T> !,LOOP-EPILOGUE)>
        <LOOP-EMIT-BODY .FORM LOOP-BODY>>


<DEFINE LOOP-DO-THEREIS ("AUX" (FORM <OR <CHECK-END> <LSCPOP>>))
	<SET FORM <CHECKC <FORM AND .FORM <FORM RETURN .FORM>>>>
	<LOOP-EMIT-BODY .FORM LOOP-BODY>>



<DEFINE LOOP-DO-WHILE (TRUE "AUX" (FORM <OR <CHECK-END> <LSCPOP>>))
	#DECL ((TRUE) <OR ATOM FALSE>)
	<OR .TRUE <SET FORM <FORM NOT .FORM>>>
	<LOOP-EMIT-BODY <CHECKC .FORM> LOOP-PRETESTS>>


<DEFINE LOOP-DO-WITH ("AUX" (REDEFINE T))
	<AND <NOT <EMPTY? ,LOOP-CONDITIONALS>>
	     <ERROR WITH-CLAUSE-INSIDE-CONDITIONAL!-ERRORS>>
	<REPEAT (VAR
		 TEM
		 (VALS '())
		 DTYPE)
             #DECL ((VAR) ATOM (VALS) LIST 
		    (DTYPE) <OR ATOM FORM FALSE>)
	     <CHECK-END>
	     <SET VAR <LSCPOP>>
	     <SET DTYPE <LOOP-OPTIONAL-TYPE>>
	     <SET TEM <LSCFIRST>>
	     <COND (<==? .TEM => <LSCPOP> <CHECK-END>
				 <SET VALS ((.VAR <LSCPOP>) !.VALS)>)>
	     <OR <MEMQ .VAR ,LOOP-ILIST>
	     <SETG LOOP-ILIST (.VAR !,LOOP-ILIST)>>
	     <AND .DTYPE <SETG LOOP-DECLARATIONS ((.VAR) .DTYPE !,LOOP-DECLARATIONS)>>
	     <SET TEM <LSCFIRST>>
	     <COND (<N==? .TEM AND>
		    <AND <NOT <EMPTY? .VALS>>
		      <SETG LOOP-INIT-SET-LIST (<LOOP-PSET .VALS> 
                                                !,LOOP-INIT-SET-LIST)>>
		    <RETURN>)
		   (ELSE <LSCPOP>)>>>

<DEFINE LOOP-DO-RETURN ("AUX" (REDEFINE T))
       <SETG LOOP-BODY (<CHECKC <FORM RETURN <LOOP-GET-FORM>>> !,LOOP-BODY)>>


<DEFINE LOOP-PSET (STEPS) 
	#DECL ((STEPS) <LIST [REST LIST]>)
	<REPEAT ((L .STEPS)
		 (S <LPOP L>)
		 (F <FORM SET !.S>))
		<COND (<EMPTY? .L> <RETURN .F>)>     ;"PROG1"
		<SET S <LPOP L>>
		<SET F <FORM BIND ((T <2 .S>))
			     .F
			     <FORM SET <1 .S> '.T>>>>>


<DEFINE LOOP-DO-NAMED ("AUX" (REDEFINE T))
	<CHECK-END>
	<SETG LOOP-NAME <LSCPOP>>>

<DEFMAC CHECK-END ()
	'<COND (<EMPTY? ,LOOP-SOURCE-CODE>
		<ERROR UNEXPECTED-END-OF-LOOP-FORM!-ERRORS>)>>


;"DEBUGGING HACK"

<DEFINE LOOP-EXPAND (BOOL "AUX" (LOOP-TRANS ,LOOP)
			        (MACROP <==? <TYPE .LOOP-TRANS> MACRO>))
	#DECL ((BOOL MACROP) ANY (LOOP-TRANS) <OR FUNCTION MACRO>)
	<COND (<N=? <UNAME> "MARKT">
	       <ERROR FUNCTION-NO-LONGER-AVAILABLE>)>
	<COND (<AND .MACROP .BOOL> <GUNASSIGN LOOP>
	       <SETG LOOP <1 <CHTYPE .LOOP-TRANS LIST>>>)
	      (<AND <NOT .MACROP> <NOT .BOOL>> <GUNASSIGN LOOP>
               <SETG LOOP <CHTYPE (.LOOP-TRANS) MACRO>>)>
	.BOOL>

<DEFINE LOOP-MEMO () <USE "FMACRO"> <FAST-MACROS>>

<DEFINE LOOP-DECLARATION (L "AUX" (REDEFINE T))
	<COND (<==? <TYPE .L> LIST>
	       <SETG LOOP-DECLARATIONS (!.L !,LOOP-DECLARATIONS)>)>>

<ENDPACKAGE>